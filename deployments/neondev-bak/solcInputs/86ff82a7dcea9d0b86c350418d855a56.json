{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "ado-contracts/contracts/interfaces/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0 <0.9.0;\n\n/**\n* @dev EIP2362 Interface for pull oracles\n* https://github.com/adoracles/EIPs/blob/erc-2362/EIPS/eip-2362.md\n*/\ninterface IERC2362\n{\n\t/**\n\t * @dev Exposed function pertaining to EIP standards\n\t * @param _id bytes32 ID of the query\n\t * @return int,uint,uint returns the value, timestamp, and status code of query\n\t */\n\tfunction valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\n}"
    },
    "contracts/common/CommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/ICommunityIssuance.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\n\ncontract CommunityIssuance is ICommunityIssuance, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    // --- Data ---\n\n    string public constant NAME = \"CommunityIssuance\";\n\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    /* The issuance factor F determines the curvature of the issuance curve.\n     *\n     * Minutes in one year: 60*24*365 = 525600\n     *\n     * For 50% of remaining tokens issued each year, with minutes as time units, we have:\n     *\n     * F ** 525600 = 0.5\n     *\n     * Re-arranging:\n     *\n     * 525600 * ln(F) = ln(0.5)\n     * F = 0.5 ** (1/525600)\n     * F = 0.999998681227695000\n     */\n    uint256 public constant ISSUANCE_FACTOR = 999998681227695000;\n\n    /*\n     * The community ZKT supply cap is the starting balance of the Community Issuance contract.\n     * It should be minted to this contract by ZKToken, when the token is deployed.\n     *\n     * Set to 32M (slightly less than 1/3) of total ZKT supply.\n     */\n    uint256 public constant ZKTSupplyCap = 32e24; // 32 million\n\n    IZKToken public zkToken;\n\n    address public stabilityPoolAddress;\n\n    uint256 public totalZKTIssued;\n    uint256 public immutable deploymentTime;\n\n    constructor() {\n        deploymentTime = block.timestamp;\n    }\n\n    function setAddresses(\n        address _zkTokenAddress,\n        address _stabilityPoolAddress\n    ) external override onlyOwner {\n        checkContract(_zkTokenAddress);\n        checkContract(_stabilityPoolAddress);\n\n        zkToken = IZKToken(_zkTokenAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n\n        // When ZKToken deployed, it should have transferred CommunityIssuance's ZKT entitlement\n        uint256 ZKTBalance = zkToken.balanceOf(address(this));\n        assert(ZKTBalance >= ZKTSupplyCap);\n\n        emit ZKTokenAddressSet(_zkTokenAddress);\n        emit StabilityPoolAddressSet(_stabilityPoolAddress);\n\n        //renounceOwnership();\n    }\n\n    function issueZKT() external override returns (uint256) {\n        _requireCallerIsStabilityPool();\n\n        uint256 latestTotalZKTIssued = ZKTSupplyCap\n            .mul(_getCumulativeIssuanceFraction())\n            .div(DECIMAL_PRECISION);\n        uint256 issuance = latestTotalZKTIssued.sub(totalZKTIssued);\n\n        totalZKTIssued = latestTotalZKTIssued;\n        emit TotalZKTIssuedUpdated(latestTotalZKTIssued);\n\n        return issuance;\n    }\n\n    /* Gets 1-f^t    where: f < 1\n\n    f: issuance factor that determines the shape of the curve\n    t:  time passed since last ZKT issuance event  */\n    function _getCumulativeIssuanceFraction() internal view returns (uint256) {\n        // Get the time passed since deployment\n        uint256 timePassedInMinutes = block.timestamp.sub(deploymentTime).div(\n            SECONDS_IN_ONE_MINUTE\n        );\n\n        // f^t\n        uint256 power = FullMath._decPow(ISSUANCE_FACTOR, timePassedInMinutes);\n\n        //  (1 - f^t)\n        uint256 cumulativeIssuanceFraction = (\n            uint256(DECIMAL_PRECISION).sub(power)\n        );\n        assert(cumulativeIssuanceFraction <= DECIMAL_PRECISION); // must be in range [0,1]\n\n        return cumulativeIssuanceFraction;\n    }\n\n    function sendZKT(address _account, uint256 _ZKTamount) external override {\n        _requireCallerIsStabilityPool();\n\n        zkToken.transfer(_account, _ZKTamount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"CommunityIssuance: caller is not SP\"\n        );\n    }\n}\n"
    },
    "contracts/common/DepositManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IZKUSDToken {\n    function mintToDeposit(address _account, uint256 _amount) external;\n\n    function burnFromDeposit(address _account, uint256 _amount) external;\n\n    function balanceOf(address _account) external returns (uint256);\n}\n\ncontract DepositManager is Ownable {\n    receive() external payable {}\n\n    address public zkusdToken;\n    bool public refundAllowed;\n    event ZKUSDTokenChange(address _zkusdToken);\n    event DepoistRecord(\n        address indexed account,\n        uint256 amountIn,\n        uint256 amountBorrowed\n    );\n    event RefundRecord(\n        address indexed account,\n        uint256 amountOut,\n        uint256 amountBorrowed\n    );\n    event EnableRefund(bool allowed);\n\n    function setAddress(address _zkusdToken) external onlyOwner {\n        zkusdToken = _zkusdToken;\n        emit ZKUSDTokenChange(_zkusdToken);\n    }\n\n    constructor() {\n        refundAllowed = false;\n    }\n\n    uint256 NEON_ZKUSD_RATE = 1000;\n\n    function deposit(uint256 amount) public payable {\n        require(zkusdToken != address(0), \"DepositManager: not initialize\");\n        require(\n            msg.value > 0 && msg.value == amount,\n            \"DepositManager: invalid deposit value\"\n        );\n        uint256 amountToMint = amount * NEON_ZKUSD_RATE;\n        IZKUSDToken(zkusdToken).mintToDeposit(msg.sender, amountToMint);\n        emit DepoistRecord(msg.sender, amount, amountToMint);\n    }\n\n    function refund(uint256 amount) external {\n        require(refundAllowed == true, \"DepositManager: Not allowed\");\n        require(\n            IZKUSDToken(zkusdToken).balanceOf(msg.sender) >= amount,\n            \"DepositManager: insufficient amount\"\n        );\n        IZKUSDToken(zkusdToken).burnFromDeposit(msg.sender, amount);\n        uint256 amountOut = amount / NEON_ZKUSD_RATE;\n        payable(msg.sender).transfer(amountOut);\n        emit RefundRecord(msg.sender, amountOut, amount);\n    }\n\n    function enableRefund(bool _enableOrNot) external onlyOwner {\n        refundAllowed = _enableOrNot;\n        emit EnableRefund(_enableOrNot);\n    }\n\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    }\n\n    function withdrawToken(address token) external onlyOwner {\n        IERC20(token).transfer(\n            msg.sender,\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n}\n"
    },
    "contracts/common/LockupContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IZKToken.sol\";\n\n/*\n* The lockup contract architecture utilizes a single LockupContract, with an unlockTime. The unlockTime is passed as an argument\n* to the LockupContract's constructor. The contract's balance can be withdrawn by the beneficiary when block.timestamp > unlockTime.\n* At construction, the contract checks that unlockTime is at least one year later than the Liquity system's deployment time.\n\n* Within the first year from deployment, the deployer of the ZKToken (Liquity AG's address) may transfer ZKT only to valid\n* LockupContracts, and no other addresses (this is enforced in ZKToken.sol's transfer() function).\n*\n* The above two restrictions ensure that until one year after system deployment, ZKT tokens originating from Liquity AG cannot\n* enter circulating supply and cannot be staked to earn system revenue.\n*/\ncontract LockupContract {\n    using SafeMath for uint256;\n\n    // --- Data ---\n    string public constant NAME = \"LockupContract\";\n\n    uint256 public constant SECONDS_IN_ONE_YEAR = 31536000;\n\n    address public immutable beneficiary;\n\n    IZKToken public zkToken;\n\n    // Unlock time is the Unix point in time at which the beneficiary can withdraw.\n    uint256 public unlockTime;\n\n    // --- Events ---\n\n    event LockupContractCreated(address _beneficiary, uint256 _unlockTime);\n    event LockupContractEmptied(uint256 _ZKTwithdrawal);\n\n    // --- Functions ---\n\n    constructor(\n        address _zkTokenAddress,\n        address _beneficiary,\n        uint256 _unlockTime\n    ) {\n        zkToken = IZKToken(_zkTokenAddress);\n\n        /*\n         * Set the unlock time to a chosen instant in the future, as long as it is at least 1 year after\n         * the system was deployed\n         */\n        _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(_unlockTime);\n        unlockTime = _unlockTime;\n\n        beneficiary = _beneficiary;\n        emit LockupContractCreated(_beneficiary, _unlockTime);\n    }\n\n    function withdrawZKT() external {\n        _requireCallerIsBeneficiary();\n        _requireLockupDurationHasPassed();\n\n        IZKToken zkTokenCached = zkToken;\n        uint256 ZKTBalance = zkTokenCached.balanceOf(address(this));\n        zkTokenCached.transfer(beneficiary, ZKTBalance);\n        emit LockupContractEmptied(ZKTBalance);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBeneficiary() internal view {\n        require(\n            msg.sender == beneficiary,\n            \"LockupContract: caller is not the beneficiary\"\n        );\n    }\n\n    function _requireLockupDurationHasPassed() internal view {\n        require(\n            block.timestamp >= unlockTime,\n            \"LockupContract: The lockup duration must have passed\"\n        );\n    }\n\n    function _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(\n        uint256 _unlockTime\n    ) internal view {\n        uint256 systemDeploymentTime = zkToken.getDeploymentStartTime();\n        require(\n            _unlockTime >= systemDeploymentTime.add(SECONDS_IN_ONE_YEAR),\n            \"LockupContract: unlock time must be at least one year after system deployment\"\n        );\n    }\n}\n"
    },
    "contracts/common/LockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/ILockupContractFactory.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"./LockupContract.sol\";\n\n/*\n * The LockupContractFactory deploys LockupContracts - its main purpose is to keep a registry of valid deployed\n * LockupContracts.\n *\n * This registry is checked by ZKToken when the Liquity deployer attempts to transfer ZKT tokens. During the first year\n * since system deployment, the Liquity deployer is only allowed to transfer ZKT to valid LockupContracts that have been\n * deployed by and recorded in the LockupContractFactory. This ensures the deployer's ZKT can't be traded or staked in the\n * first year, and can only be sent to a verified LockupContract which unlocks at least one year after system deployment.\n *\n * LockupContracts can of course be deployed directly, but only those deployed through and recorded in the LockupContractFactory\n * will be considered \"valid\" by ZKToken. This is a convenient way to verify that the target address is a genuine\n * LockupContract.\n */\n\ncontract LockupContractFactory is\n    ILockupContractFactory,\n    Ownable,\n    CheckContract\n{\n    using SafeMath for uint256;\n\n    // --- Data ---\n    string public constant NAME = \"LockupContractFactory\";\n\n    uint256 public constant SECONDS_IN_ONE_YEAR = 31536000;\n\n    address public zkTokenAddress;\n\n    mapping(address => address) public lockupContractToDeployer;\n\n    // --- Functions ---\n\n    function setZKTokenAddress(\n        address _zkTokenAddress\n    ) external override onlyOwner {\n        checkContract(_zkTokenAddress);\n\n        zkTokenAddress = _zkTokenAddress;\n        emit ZKTokenAddressSet(_zkTokenAddress);\n\n        //renounceOwnership();\n    }\n\n    function deployLockupContract(\n        address _beneficiary,\n        uint256 _unlockTime\n    ) external override {\n        address zkTokenAddressCached = zkTokenAddress;\n        _requireZKTAddressIsSet(zkTokenAddressCached);\n        LockupContract lockupContract = new LockupContract(\n            zkTokenAddressCached,\n            _beneficiary,\n            _unlockTime\n        );\n\n        lockupContractToDeployer[address(lockupContract)] = msg.sender;\n        emit LockupContractDeployedThroughFactory(\n            address(lockupContract),\n            _beneficiary,\n            _unlockTime,\n            msg.sender\n        );\n    }\n\n    function isRegisteredLockup(\n        address _contractAddress\n    ) public view override returns (bool) {\n        return lockupContractToDeployer[_contractAddress] != address(0);\n    }\n\n    // --- 'require'  functions ---\n    function _requireZKTAddressIsSet(address _zkTokenAddress) internal pure {\n        require(_zkTokenAddress != address(0), \"LCF: ZKT Address is not set\");\n    }\n}\n"
    },
    "contracts/common/ZKToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/ERC2612Permit.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../interfaces/ILockupContractFactory.sol\";\n\ncontract ZKToken is IZKToken, CheckContract, ERC2612Permit {\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_YEAR_IN_SECONDS = 31536000; // 60 * 60 * 24 * 365\n\n    // uint256 for use with SafeMath\n    uint256 internal _1_MILLION = 1e24; // 1e6 * 1e18 = 1e24\n\n    uint256 internal immutable deploymentStartTime;\n\n    address public immutable communityIssuanceAddress;\n    address public immutable zktStakingAddress;\n\n    uint256 internal immutable lpRewardsEntitlement;\n\n    ILockupContractFactory public immutable lockupContractFactory;\n\n    address public multisigAddress;\n\n    constructor(\n        address _communityIssuanceAddress,\n        address _zktStakingAddress,\n        address _lockupFactoryAddress,\n        address _bountyAddress,\n        address _lpRewardsAddress,\n        address _multisigAddress\n    ) ERC20(\"ZKToken\", \"ZKT\") ERC2612Permit(\"ZKT\") {\n        checkContract(_communityIssuanceAddress);\n        checkContract(_zktStakingAddress);\n        checkContract(_lockupFactoryAddress);\n\n        multisigAddress = _multisigAddress;\n        deploymentStartTime = block.timestamp;\n\n        communityIssuanceAddress = _communityIssuanceAddress;\n        zktStakingAddress = _zktStakingAddress;\n        lockupContractFactory = ILockupContractFactory(_lockupFactoryAddress);\n\n        // --- Initial ZKT allocations ---\n\n        uint256 bountyEntitlement = _1_MILLION.mul(2); // Allocate 2 million for bounties/hackathons\n        _mint(_bountyAddress, bountyEntitlement);\n\n        uint256 depositorsAndFrontEndsEntitlement = _1_MILLION.mul(32); // Allocate 32 million to the algorithmic issuance schedule\n        _mint(_communityIssuanceAddress, depositorsAndFrontEndsEntitlement);\n\n        uint256 _lpRewardsEntitlement = _1_MILLION.mul(4).div(3); // Allocate 1.33 million for LP rewards\n        lpRewardsEntitlement = _lpRewardsEntitlement;\n        if (_lpRewardsAddress == address(0)) {\n            _mint(_multisigAddress, _lpRewardsEntitlement);\n        } else {\n            _mint(_lpRewardsAddress, _lpRewardsEntitlement);\n        }\n\n        // Allocate the remainder to the ZKT Multisig: (100 - 2 - 32 - 1.33) million = 64.66 million\n        uint256 multisigEntitlement = _1_MILLION\n            .mul(100)\n            .sub(bountyEntitlement)\n            .sub(depositorsAndFrontEndsEntitlement)\n            .sub(_lpRewardsEntitlement);\n\n        _mint(_multisigAddress, multisigEntitlement);\n    }\n\n    function getDeploymentStartTime() external view override returns (uint256) {\n        return deploymentStartTime;\n    }\n\n    function getLpRewardsEntitlement()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return lpRewardsEntitlement;\n    }\n\n    function sendToZKTStaking(\n        address _sender,\n        uint256 _amount\n    ) external override {\n        _requireCallerIsZKTStaking();\n        if (_isFirstYear()) {\n            _requireSenderIsNotMultisig(_sender);\n        } // Prevent the multisig from staking ZK\n        _transfer(_sender, zktStakingAddress, _amount);\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        return super.approve(spender, amount);\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        // Restrict the multisig's transfers in first year\n        if (_callerIsMultisig() && _isFirstYear()) {\n            _requireRecipientIsRegisteredLC(recipient);\n        }\n\n        _requireValidRecipient(recipient);\n\n        // Otherwise, standard transfer functionality\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        if (_isFirstYear()) {\n            _requireSenderIsNotMultisig(sender);\n        }\n\n        _requireValidRecipient(recipient);\n\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public override(ERC20) returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public override(ERC20) returns (bool) {\n        if (_isFirstYear()) {\n            _requireCallerIsNotMultisig();\n        }\n\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n\n    // --- Helper functions ---\n\n    function _callerIsMultisig() internal view returns (bool) {\n        return (msg.sender == multisigAddress);\n    }\n\n    function _isFirstYear() internal view returns (bool) {\n        return (block.timestamp.sub(deploymentStartTime) < ONE_YEAR_IN_SECONDS);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"ZK: Cannot transfer tokens directly to the ZK token contract or the zero address\"\n        );\n        require(\n            _recipient != communityIssuanceAddress &&\n                _recipient != zktStakingAddress,\n            \"ZK: Cannot transfer tokens directly to the community issuance or staking contract\"\n        );\n    }\n\n    function _requireRecipientIsRegisteredLC(address _recipient) internal view {\n        require(\n            lockupContractFactory.isRegisteredLockup(_recipient),\n            \"ZKToken: recipient must be a LockupContract registered in the Factory\"\n        );\n    }\n\n    function _requireSenderIsNotMultisig(address _sender) internal view {\n        require(\n            _sender != multisigAddress,\n            \"ZKToken: sender must not be the multisig\"\n        );\n    }\n\n    function _requireCallerIsNotMultisig() internal view {\n        require(\n            !_callerIsMultisig(),\n            \"ZKToken: caller must not be the multisig\"\n        );\n    }\n\n    function _requireCallerIsZKTStaking() internal view {\n        require(\n            msg.sender == zktStakingAddress,\n            \"ZKToken: caller must be the ZKTStaking contract\"\n        );\n    }\n}\n"
    },
    "contracts/common/ZKTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/ICommunityIssuance.sol\";\nimport \"../interfaces/IZKTStaking.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\n\ncontract ZKTStaking is IZKTStaking, Ownable, CheckContract {\n    using SafeMath for uint256;\n\n    // --- Data ---\n    string public constant NAME = \"ZKTStaking\";\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    mapping(address => uint256) public stakes;\n    uint256 public totalZKTStaked;\n\n    uint256 public F_NEON; // Running sum of NEON fees per-ZKT-staked\n    uint256 public F_ZKUSD; // Running sum of ZKT fees per-ZKT-staked\n\n    // User snapshots of F_NEON and F_ZKUSD, taken at the point at which their latest deposit was made\n    mapping(address => Snapshot) public snapshots;\n\n    struct Snapshot {\n        uint256 F_NEON_Snapshot;\n        uint256 F_ZKUSD_Snapshot;\n    }\n\n    IZKToken public zkToken;\n    IZKUSDToken public zkusdToken;\n\n    address public troveManagerAddress;\n    address public borrowerOperationsAddress;\n    address public activePoolAddress;\n\n    constructor(address _ownership) {\n        _transferOwnership(_ownership);\n    }\n\n    function setAddresses(\n        address _zkTokenAddress,\n        address _zkusdTokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external override onlyOwner {\n        checkContract(_zkTokenAddress);\n        checkContract(_zkusdTokenAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n\n        zkToken = IZKToken(_zkTokenAddress);\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\n        troveManagerAddress = _troveManagerAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit ZKTTokenAddressSet(_zkTokenAddress);\n        emit ZKTTokenAddressSet(_zkusdTokenAddress);\n        emit TroveManagerAddressSet(_troveManagerAddress);\n        emit BorrowerOperationsAddressSet(_borrowerOperationsAddress);\n        emit ActivePoolAddressSet(_activePoolAddress);\n\n        //renounceOwnership();\n    }\n\n    // If caller has a pre-existing stake, send any accumulated NEON and ZKUSD gains to them.\n    function stake(uint256 _ZKTamount) external override {\n        _requireNonZeroAmount(_ZKTamount);\n\n        uint256 currentStake = stakes[msg.sender];\n\n        uint256 NEONGain;\n        uint256 ZKUSDGain;\n        // Grab any accumulated NEON and ZKUSD gains from the current stake\n        if (currentStake != 0) {\n            NEONGain = _getPendingNEONGain(msg.sender);\n            ZKUSDGain = _getPendingZKUSDGain(msg.sender);\n        }\n\n        _updateUserSnapshots(msg.sender);\n\n        uint256 newStake = currentStake.add(_ZKTamount);\n\n        // Increase user’s stake and total ZKT staked\n        stakes[msg.sender] = newStake;\n        totalZKTStaked = totalZKTStaked.add(_ZKTamount);\n        emit TotalZKTStakedUpdated(totalZKTStaked);\n\n        // Transfer ZKT from caller to this contract\n        zkToken.sendToZKTStaking(msg.sender, _ZKTamount);\n\n        emit StakeChanged(msg.sender, newStake);\n        emit StakingGainsWithdrawn(msg.sender, ZKUSDGain, NEONGain);\n\n        // Send accumulated ZKUSD and NEON gains to the caller\n        if (currentStake != 0) {\n            zkusdToken.transfer(msg.sender, ZKUSDGain);\n            _sendNEONGainToUser(NEONGain);\n        }\n    }\n\n    // Unstake the ZKT and send the it back to the caller, along with their accumulated ZKUSD & NEON gains.\n    // If requested amount > stake, send their entire stake.\n    function unstake(uint256 _ZKTamount) external override {\n        uint256 currentStake = stakes[msg.sender];\n        _requireUserHasStake(currentStake);\n\n        // Grab any accumulated NEON and ZKUSD gains from the current stake\n        uint256 NEONGain = _getPendingNEONGain(msg.sender);\n        uint256 ZKUSDGain = _getPendingZKUSDGain(msg.sender);\n\n        _updateUserSnapshots(msg.sender);\n\n        if (_ZKTamount > 0) {\n            uint256 ZKTToWithdraw = Math.min(_ZKTamount, currentStake);\n\n            uint256 newStake = currentStake.sub(ZKTToWithdraw);\n\n            // Decrease user's stake and total ZKT staked\n            stakes[msg.sender] = newStake;\n            totalZKTStaked = totalZKTStaked.sub(ZKTToWithdraw);\n            emit TotalZKTStakedUpdated(totalZKTStaked);\n\n            // Transfer unstaked ZKT to user\n            zkToken.transfer(msg.sender, ZKTToWithdraw);\n\n            emit StakeChanged(msg.sender, newStake);\n        }\n\n        emit StakingGainsWithdrawn(msg.sender, ZKUSDGain, NEONGain);\n\n        // Send accumulated ZKUSD and NEON gains to the caller\n        zkusdToken.transfer(msg.sender, ZKUSDGain);\n        _sendNEONGainToUser(NEONGain);\n    }\n\n    // --- Reward-per-unit-staked increase functions. Called by Liquity core contracts ---\n\n    function increaseF_NEON(uint256 _NEONFee) external override {\n        _requireCallerIsTroveManager();\n        uint256 NEONFeePerZKTStaked;\n\n        if (totalZKTStaked > 0) {\n            NEONFeePerZKTStaked = _NEONFee.mul(DECIMAL_PRECISION).div(\n                totalZKTStaked\n            );\n        }\n\n        F_NEON = F_NEON.add(NEONFeePerZKTStaked);\n        emit F_NEONUpdated(F_NEON);\n    }\n\n    function increaseF_ZKUSD(uint256 _ZKUSDFee) external override {\n        _requireCallerIsBorrowerOperations();\n        uint256 ZKUSDFeePerZKTStaked;\n\n        if (totalZKTStaked > 0) {\n            ZKUSDFeePerZKTStaked = _ZKUSDFee.mul(DECIMAL_PRECISION).div(\n                totalZKTStaked\n            );\n        }\n\n        F_ZKUSD = F_ZKUSD.add(ZKUSDFeePerZKTStaked);\n        emit F_ZKUSDUpdated(F_ZKUSD);\n    }\n\n    // --- Pending reward functions ---\n\n    function getPendingNEONGain(\n        address _user\n    ) external view override returns (uint256) {\n        return _getPendingNEONGain(_user);\n    }\n\n    function _getPendingNEONGain(address _user) internal view returns (uint256) {\n        uint256 F_NEON_Snapshot = snapshots[_user].F_NEON_Snapshot;\n        uint256 NEONGain = stakes[_user].mul(F_NEON.sub(F_NEON_Snapshot)).div(\n            DECIMAL_PRECISION\n        );\n        return NEONGain;\n    }\n\n    function getPendingZKUSDGain(\n        address _user\n    ) external view override returns (uint256) {\n        return _getPendingZKUSDGain(_user);\n    }\n\n    function _getPendingZKUSDGain(\n        address _user\n    ) internal view returns (uint256) {\n        uint256 F_ZKUSD_Snapshot = snapshots[_user].F_ZKUSD_Snapshot;\n        uint256 ZKUSDGain = stakes[_user]\n            .mul(F_ZKUSD.sub(F_ZKUSD_Snapshot))\n            .div(DECIMAL_PRECISION);\n        return ZKUSDGain;\n    }\n\n    // --- Internal helper functions ---\n\n    function _updateUserSnapshots(address _user) internal {\n        snapshots[_user].F_NEON_Snapshot = F_NEON;\n        snapshots[_user].F_ZKUSD_Snapshot = F_ZKUSD;\n        emit StakerSnapshotsUpdated(_user, F_NEON, F_ZKUSD);\n    }\n\n    function _sendNEONGainToUser(uint256 NEONGain) internal {\n        emit NeonSent(msg.sender, NEONGain);\n        (bool success, ) = msg.sender.call{value: NEONGain}(\"\");\n        require(success, \"ZKTStaking: Failed to send accumulated NEONGain\");\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"ZKTStaking: caller is not TroveM\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"ZKTStaking: caller is not BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"ZKTStaking: caller is not ActivePool\"\n        );\n    }\n\n    function _requireUserHasStake(uint256 currentStake) internal pure {\n        require(\n            currentStake > 0,\n            \"ZKTStaking: User must have a non-zero stake\"\n        );\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"ZKTStaking: Amount must be non-zero\");\n    }\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n    }\n}\n"
    },
    "contracts/common/ZKUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/ERC2612Permit.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"hardhat/console.sol\";\n\ncontract ZKUSDToken is IZKUSDToken, CheckContract, ERC2612Permit {\n    using SafeMath for uint256;\n\n    // --- Addresses ---\n    address public immutable troveManagerAddress;\n    address public immutable stabilityPoolAddress;\n    address public immutable borrowerOperationsAddress;\n    address public immutable depositManagerAddress;\n\n    event DepositManagerAddressChanged(address _depositManagerAddress);\n\n    constructor(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        address _depositManagerAddress\n    ) ERC20(\"ZKUSD Stablecoin\", \"ZKUSD\") ERC2612Permit(\"ZKUSD Stablecoin\") {\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        depositManagerAddress = _depositManagerAddress;\n        emit DepositManagerAddressChanged(_depositManagerAddress);\n    }\n\n    function mintToDeposit(address _account, uint256 _amount) external {\n        require(\n            msg.sender == depositManagerAddress,\n            \"ZKUSDToken: Caller is not DepositManager\"\n        );\n        _mint(_account, _amount);\n    }\n\n    function burnFromDeposit(address _account, uint256 _amount) external {\n        require(\n            msg.sender == depositManagerAddress,\n            \"ZKUSDToken: Caller is not DepositManager\"\n        );\n        _burn(_account, _amount);\n    }\n\n    function mint(address _account, uint256 _amount) external override {\n        _requireCallerIsBorrowerOperations();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(\n        address _sender,\n        address _poolAddress,\n        uint256 _amount\n    ) external override {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(\n        address _poolAddress,\n        address _receiver,\n        uint256 _amount\n    ) external override {\n        _requireCallerIsTroveMorSP();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override(IERC20, ERC20) returns (bool) {\n        _requireValidRecipient(recipient);\n        return super.transferFrom(sender, recipient, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"ZKUSD: Cannot transfer tokens directly to the ZKUSD token contract or the zero address\"\n        );\n        require(\n            _recipient != stabilityPoolAddress &&\n                _recipient != troveManagerAddress &&\n                _recipient != borrowerOperationsAddress,\n            \"ZKUSD: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"ZKUSDToken: Caller is not BorrowerOperations\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"ZKUSD: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"ZKUSD: Caller is not the StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsTroveMorSP() internal view {\n        require(\n            msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"ZKUSD: Caller is neither TroveManager nor StabilityPool\"\n        );\n    }\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n     */\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n        require(\n            Address.isContract(_account),\n            \"Account code size cannot be zero\"\n        );\n    }\n}\n"
    },
    "contracts/dependencies/ERC2612Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/IERC2612.sol\";\n\nabstract contract ERC2612Permit is IERC2612, ERC20 {\n    string internal constant _VERSION = \"1\";\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 internal constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 internal immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 internal immutable _CACHED_CHAIN_ID;\n\n    bytes32 internal immutable _HASHED_NAME;\n    bytes32 internal immutable _HASHED_VERSION;\n    mapping(address => uint256) internal _nonces;\n\n    constructor(string memory name) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n            _TYPE_HASH,\n            hashedName,\n            hashedVersion\n        );\n    }\n\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return\n                _buildDomainSeparator(\n                    _TYPE_HASH,\n                    _HASHED_NAME,\n                    _HASHED_VERSION\n                );\n        }\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"ZKUSD: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        amount,\n                        _nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"ZKUSD: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 _typeHash,\n        bytes32 _name,\n        bytes32 _version\n    ) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    _typeHash,\n                    _name,\n                    _version,\n                    _chainID(),\n                    address(this)\n                )\n            );\n    }\n\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}\n"
    },
    "contracts/dependencies/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary FullMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 NEON,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint256 internal constant NICR_PRECISION = 1e20;\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x.mul(y);\n\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) FullManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(\n        uint256 _base,\n        uint256 _minutes\n    ) internal pure returns (uint256) {\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n.div(2);\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n.sub(1)).div(2);\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(\n        uint256 _a,\n        uint256 _b\n    ) internal pure returns (uint256) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeNominalCR(\n        uint256 _coll,\n        uint256 _debt\n    ) internal pure returns (uint256) {\n        if (_debt > 0) {\n            return _coll.mul(NICR_PRECISION).div(_debt);\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n\n    function _computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/ZKTProtocolBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"./FullMath.sol\";\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\nabstract contract ZKTProtocolBase {\n    using SafeMath for uint256;\n\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    uint256 public constant _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint256 public constant MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1500000000000000000; // 150%\n\n    // Amount of ZKUSD to be locked in gas pool on opening troves\n    uint256 public constant ZKUSD_GAS_COMPENSATION = 200e18;\n\n    // Minimum amount of net ZKUSD debt a trove must have\n    uint256 public constant MIN_NET_DEBT = 1800e18;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint256 public constant BORROWING_FEE_FLOOR =\n        (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n\n    IActivePool public activePool;\n\n    IDefaultPool public defaultPool;\n\n    IPriceFeed public priceFeed;\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint256 _debt) internal pure returns (uint256) {\n        return _debt.add(ZKUSD_GAS_COMPENSATION);\n    }\n\n    function _getNetDebt(uint256 _debt) internal pure returns (uint256) {\n        return _debt.sub(ZKUSD_GAS_COMPENSATION);\n    }\n\n    // Return the amount of NEON to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(\n        uint256 _entireColl\n    ) internal pure returns (uint256) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function getEntireSystemColl()\n        public\n        view\n        returns (uint256 entireSystemColl)\n    {\n        uint256 activeColl = activePool.getNEON();\n        uint256 liquidatedColl = defaultPool.getNEON();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt()\n        public\n        view\n        returns (uint256 entireSystemDebt)\n    {\n        uint256 activeDebt = activePool.getZKUSDDebt();\n        uint256 closedDebt = defaultPool.getZKUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl();\n        uint256 entireSystemDebt = getEntireSystemDebt();\n\n        TCR = FullMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\n        uint256 TCR = _getTCR(_price);\n\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal pure {\n        uint256 feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\n        require(\n            feePercentage <= _maxFeePercentage,\n            \"Fee exceeded provided maximum\"\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IPool.sol\";\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\n    event ActivePoolNEONBalanceUpdated(uint256 _NEON);\n\n    // --- Functions ---\n    function sendNEON(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ITroveManager.sol\";\nimport \"./IZKUSDToken.sol\";\nimport \"./IActivePool.sol\";\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 ZKUSDFee;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 ZKUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IZKUSDToken zkusdToken;\n    }\n\n    enum Operation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event ZKUSDTokenAddressChanged(address _zkusdTokenAddress);\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        Operation operation\n    );\n    event ZKUSDBorrowingFeePaid(address indexed _borrower, uint256 _ZKUSDFee);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _zkusdTokenAddress,\n        address _zktStakingAddress\n    ) external;\n\n    function openTrove(\n        uint256 _maxFee,\n        uint256 _ZKUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function addColl(address _upperHint, address _lowerHint) external payable;\n\n    function moveNEONGainToTrove(\n        address _user,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function withdrawColl(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function withdrawZKUSD(\n        uint256 _maxFee,\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function repayZKUSD(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(\n        uint256 _maxFee,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint256 _debt) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICollSurplusPool {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\n    event NeonSent(address _to, uint256 _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getNEON() external view returns (uint256);\n\n    function getCollateral(address _account) external view returns (uint256);\n\n    function accountSurplus(address _account, uint256 _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "contracts/interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICommunityIssuance {\n    // --- Events ---\n\n    event ZKTokenAddressSet(address _zkTokenAddress);\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\n    event TotalZKTIssuedUpdated(uint _totalZKTIssued);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _zkTokenAddress,\n        address _stabilityPoolAddress\n    ) external;\n\n    function issueZKT() external returns (uint);\n\n    function sendZKT(address _account, uint _ZKTamount) external;\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IPool.sol\";\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\n    event DefaultPoolNEONBalanceUpdated(uint256 _NEON);\n\n    // --- Functions ---\n    function sendNEONToActivePool(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n *\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\n     * a value in the near future. The deadline argument can be set to uint(-1) to\n     * create Permits that effectively never expire.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    function version() external pure returns (string memory);\n\n    function permitTypeHash() external pure returns (bytes32);\n\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/ILockupContractFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILockupContractFactory {\n    // --- Events ---\n\n    event ZKTokenAddressSet(address _zkTokenAddress);\n    event LockupContractDeployedThroughFactory(\n        address _lockupContractAddress,\n        address _beneficiary,\n        uint256 _unlockTime,\n        address _deployer\n    );\n\n    // --- Functions ---\n\n    function setZKTokenAddress(address _zkTokenAddress) external;\n\n    function deployLockupContract(\n        address _beneficiary,\n        uint256 _unlockTime\n    ) external;\n\n    function isRegisteredLockup(address _addr) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILPTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILPTokenWrapper {\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IMarketStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMarketStore {}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n\n    event NEONBalanceUpdated(uint256 _newBalance);\n    event ZKUSDBalanceUpdated(uint256 _newBalance);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event ConfluxSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    function getNEON() external view returns (uint256);\n\n    function getZKUSDDebt() external view returns (uint256);\n\n    function increaseZKUSDDebt(uint256 _amount) external;\n\n    function decreaseZKUSDDebt(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    // --- Events ---\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\n\n    // --- Function ---\n    function fetchPrice() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event NodeAdded(address _id, uint256 _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n\n    function setParams(\n        uint256 _size,\n        address _TroveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external;\n\n    function insert(\n        address _id,\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function remove(address _id) external;\n\n    function reInsert(\n        address _id,\n        uint256 _newICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (bool);\n\n    function findInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n * The Stability Pool holds ZKUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its ZKUSD debt gets offset with\n * ZKUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of ZKUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a ZKUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an NEON gain, as the NEON collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total ZKUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * --- ZKT ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An ZKT issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued ZKT in proportion to the deposit as a share of total deposits. The ZKT earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n */\ninterface IStabilityPool {\n    // --- Events ---\n\n    event StabilityPoolNEONBalanceUpdated(uint256 _newBalance);\n    event StabilityPoolZKUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(uint256 _S, uint256 _epoch, uint256 _scale);\n    event G_Updated(uint256 _G, uint256 _epoch, uint256 _scale);\n    event EpochUpdated(uint256 _currentEpoch);\n    event ScaleUpdated(uint256 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(\n        address indexed _depositor,\n        uint256 _P,\n        uint256 _S,\n        uint256 _G\n    );\n    event FrontEndSnapshotUpdated(\n        address indexed _frontEnd,\n        uint256 _P,\n        uint256 _G\n    );\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event NEONGainWithdrawn(\n        address indexed _depositor,\n        uint256 _NEON,\n        uint256 _ZKUSDLoss\n    );\n    event ZKTPaidToDepositor(address indexed _depositor, uint256 _ZKT);\n    event ZKTPaidToFrontEnd(address indexed _frontEnd, uint256 _ZKT);\n    event NeonSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other Liquity contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress,\n        address _vault\n    ) external;\n\n    /*\n     * Initial checks:\n     * - _amount is not zero\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some NEON gain\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors\n     * - Sends all depositor's ZKT gain to  depositor\n     * - Transfers the depositor's entire NEON gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged\n     */\n    function withdrawNEONGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the ZKUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's NEON collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    /*\n     * Returns the total amount of NEON held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like NEON received from a self-destruct.\n     */\n    function getNEON() external view returns (uint256);\n\n    /*\n     * Returns ZKUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalZKUSDDeposits() external view returns (uint256);\n\n    /*\n     * Calculates the NEON gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorNEONGain(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Calculate the ZKT gain earned by a deposit since its last snapshots were taken.\n     * The depositor gets a 99.9% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the defaultKickbackRate\n     * which they made their deposit.\n     */\n    function getDepositorZKTGain(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Return the ZKT gain earned by the front end(depositor).\n     */\n    function getFrontEndZKTGain(\n        address _frontEnd\n    ) external view returns (uint256);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedZKUSDDeposit(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(\n        address _frontEnd\n    ) external view returns (uint256);\n\n    /*\n     * Fallback function\n     * Only callable by Active Pool, it just accounts for NEON received\n     * receive() external payable;\n     */\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IStabilityPool.sol\";\nimport \"./IZKUSDToken.sol\";\nimport \"./IZKToken.sol\";\nimport \"./IZKTStaking.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event ZKTokenAddressChanged(address _zkTokenAddress);\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\n\n    event Liquidation(\n        uint256 _liquidatedDebt,\n        uint256 _liquidatedColl,\n        uint256 _collGasCompensation,\n        uint256 _ZKUSDGasCompensation\n    );\n    event Redemption(\n        uint256 _attemptedZKUSDAmount,\n        uint256 _actualZKUSDAmount,\n        uint256 _NEONSent,\n        uint256 _NEONFee\n    );\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        Operation operation\n    );\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        Operation operation\n    );\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n    event TotalStakesUpdated(uint256 _newTotalStakes);\n    event SystemSnapshotsUpdated(\n        uint256 _totalStakesSnapshot,\n        uint256 _totalCollateralSnapshot\n    );\n    event LTermsUpdated(uint256 _L_NEON, uint256 _L_ZKUSDDebt);\n    event TroveSnapshotsUpdated(uint256 _L_NEON, uint256 _L_ZKUSDDebt);\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\n\n    enum Operation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _zkTokenAddress,\n        address _zktStakingAddress\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n\n    function zkusdToken() external view returns (IZKUSDToken);\n\n    function zkToken() external view returns (IZKToken);\n\n    function zktStaking() external view returns (IZKTStaking);\n\n    function getTroveOwnersCount() external view returns (uint256);\n\n    function getTroveFromTroveOwnersArray(\n        uint256 _index\n    ) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint256);\n\n    function getCurrentICR(\n        address _borrower,\n        uint256 _price\n    ) external view returns (uint256);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint256 _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint256 _ZKUSDAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFee\n    ) external;\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external returns (uint256);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external returns (uint256 index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingNEONReward(\n        address _borrower\n    ) external view returns (uint256);\n\n    function getPendingZKUSDDebtReward(\n        address _borrower\n    ) external view returns (uint256);\n\n    function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 pendingZKUSDDebtReward,\n            uint256 pendingNEONReward\n        );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint256);\n\n    function getRedemptionRateWithDecay() external view returns (uint256);\n\n    function getRedemptionFeeWithDecay(\n        uint256 _NEONDrawn\n    ) external view returns (uint256);\n\n    function getBorrowingRate() external view returns (uint256);\n\n    function getBorrowingRateWithDecay() external view returns (uint256);\n\n    function getBorrowingFee(uint256 ZKUSDDebt) external view returns (uint256);\n\n    function getBorrowingFeeWithDecay(\n        uint256 _ZKUSDDebt\n    ) external view returns (uint256);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint256);\n\n    function getTroveStake(address _borrower) external view returns (uint256);\n\n    function getTroveDebt(address _borrower) external view returns (uint256);\n\n    function getTroveColl(address _borrower) external view returns (uint256);\n\n    function setTroveStatus(address _borrower, uint256 num) external;\n\n    function increaseTroveColl(\n        address _borrower,\n        uint256 _collIncrease\n    ) external returns (uint256);\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint256 _collDecrease\n    ) external returns (uint256);\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint256 _debtIncrease\n    ) external returns (uint256);\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint256 _collDecrease\n    ) external returns (uint256);\n\n    function getTCR(uint256 _price) external view returns (uint256);\n\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IUnipool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUnipool {\n    function setParams(\n        address _lqtyTokenAddress,\n        address _uniTokenAddress,\n        uint256 _duration\n    ) external;\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function withdrawAndClaim() external;\n\n    function claimReward() external;\n}\n"
    },
    "contracts/interfaces/IZKToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IZKToken is IERC20 {\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\n    event ZKTStakingAddressSet(address _zktStakingAddress);\n    event LockupContractFactoryAddressSet(\n        address _lockupContractFactoryAddress\n    );\n\n    // --- Functions ---\n\n    function sendToZKTStaking(address _sender, uint256 _amount) external;\n\n    function getDeploymentStartTime() external view returns (uint256);\n\n    function getLpRewardsEntitlement() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZKTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IZKTStaking {\n    // --- Events --\n\n    event ZKTTokenAddressSet(address _zkTokenAddress);\n    event ZKUSDTokenAddressSet(address _zkusdTokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n\n    event StakeChanged(address indexed staker, uint256 newStake);\n    event StakingGainsWithdrawn(\n        address indexed staker,\n        uint256 ZKUSDGain,\n        uint256 NEONGain\n    );\n    event F_NEONUpdated(uint256 _F_NEON);\n    event F_ZKUSDUpdated(uint256 _F_ZKUSD);\n    event TotalZKTStakedUpdated(uint256 _totalZKTStaked);\n    event NeonSent(address _account, uint256 _amount);\n    event StakerSnapshotsUpdated(\n        address _staker,\n        uint256 _F_NEON,\n        uint256 _F_ZKUSD\n    );\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _zkTokenAddress,\n        address _zkusdTokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function stake(uint256 _ZKTamount) external;\n\n    function unstake(uint256 _ZKTamount) external;\n\n    function increaseF_NEON(uint256 _NEONFee) external;\n\n    function increaseF_ZKUSD(uint256 _ZKTFee) external;\n\n    function getPendingNEONGain(address _user) external view returns (uint256);\n\n    function getPendingZKUSDGain(address _user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZKUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IZKUSDToken is IERC20 {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n\n    event ZKUSDTokenBalanceUpdated(address _user, uint256 _amount);\n\n    // --- Functions ---\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(\n        address _sender,\n        address poolAddress,\n        uint256 _amount\n    ) external;\n\n    function returnFromPool(\n        address poolAddress,\n        address user,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/mocks/BorrowerOperationsTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../protocol/BorrowerOperations.sol\";\n\n/* Tester contract inherits from BorrowerOperations, and provides external functions\nfor testing the parent's internal functions. */\ncontract BorrowerOperationsTester is BorrowerOperations {\n    function getNewICRFromTroveChange(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool isCollIncrease,\n        uint _debtChange,\n        bool isDebtIncrease,\n        uint _price\n    ) external pure returns (uint) {\n        return\n            _getNewICRFromTroveChange(\n                _coll,\n                _debt,\n                _collChange,\n                isCollIncrease,\n                _debtChange,\n                isDebtIncrease,\n                _price\n            );\n    }\n\n    function getNewTCRFromTroveChange(\n        uint _collChange,\n        bool isCollIncrease,\n        uint _debtChange,\n        bool isDebtIncrease,\n        uint _price\n    ) external view returns (uint) {\n        return\n            _getNewTCRFromTroveChange(\n                _collChange,\n                isCollIncrease,\n                _debtChange,\n                isDebtIncrease,\n                _price\n            );\n    }\n\n    function getUSDValue(uint _coll, uint _price) external pure returns (uint) {\n        return _getUSDValue(_coll, _price);\n    }\n\n    function callInternalAdjustLoan(\n        address _borrower,\n        uint _collWithdrawal,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        _adjustTrove(\n            _borrower,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Payable fallback function\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(address from, address to, uint256 value) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/mocks/NonPayable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\n\ncontract NonPayable {\n    bool isPayable;\n\n    function setPayable(bool _isPayable) external {\n        isPayable = _isPayable;\n    }\n\n    function forward(address _dest, bytes calldata _data) external payable {\n        (bool success, bytes memory returnData) = _dest.call{value: msg.value}(\n            _data\n        );\n        require(success, bytesToString(returnData));\n    }\n\n    function bytesToString(\n        bytes memory input\n    ) public pure returns (string memory) {\n        uint256 length;\n        for (uint256 i = 0; i < input.length; i++) {\n            uint charCode = uint8(input[i]);\n            if (charCode >= 0x20 && charCode <= 0x7E) {\n                length++;\n            }\n        }\n\n        bytes memory output = new bytes(length);\n        uint256 index;\n        for (uint256 i = 0; i < input.length; i++) {\n            uint charCode = uint8(input[i]);\n            if (charCode >= 0x20 && charCode <= 0x7E) {\n                output[index++] = input[i];\n            }\n        }\n        return string(output);\n    }\n\n    receive() external payable {\n        require(isPayable);\n    }\n}\n"
    },
    "contracts/mocks/PriceFeedTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IPriceFeed.sol\";\n\ncontract PriceFeedTestnet is IPriceFeed {\n    uint256 private _price = 200 * 1e18;\n\n    uint256 public lastGoodPrice;\n\n    // --- Dependency setters ---\n    function setAddresses(bytes4, address) external {}\n\n    // View price getter for simplicity in tests\n    function getPrice() external view returns (uint256) {\n        return _price;\n    }\n\n    function fetchPrice() external override returns (uint256) {\n        emit LastGoodPriceUpdated(_price);\n        lastGoodPrice = _price;\n        return lastGoodPrice;\n    }\n\n    function setPrice(uint256 price) external returns (bool) {\n        _price = price;\n        lastGoodPrice = _price;\n\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/SortedTrovesTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ISortedTroves.sol\";\n\ncontract SortedTrovesTester {\n    ISortedTroves sortedTroves;\n\n    function setSortedTroves(address _sortedTrovesAddress) external {\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n    }\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external {\n        sortedTroves.insert(_id, _NICR, _prevId, _nextId);\n    }\n\n    function remove(address _id) external {\n        sortedTroves.remove(_id);\n    }\n\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external {\n        sortedTroves.reInsert(_id, _newNICR, _prevId, _nextId);\n    }\n\n    function getNominalICR(address) external pure returns (uint256) {\n        return 1;\n    }\n\n    function getCurrentICR(address, uint256) external pure returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/mocks/StabilityPoolTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../protocol/StabilityPool.sol\";\n\ncontract StabilityPoolTester is StabilityPool {\n    function unprotectedPayable() external payable {\n        NEON = NEON + msg.value;\n    }\n\n    function setCurrentScale(uint128 _currentScale) external {\n        currentScale = _currentScale;\n    }\n\n    function setTotalDeposits(uint _totalZKUSDDeposits) external {\n        totalZKUSDDeposits = _totalZKUSDDeposits;\n    }\n}\n"
    },
    "contracts/mocks/TestUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./TestUniswapV2Pair.sol\";\n\ninterface IUniswapV2Pair {\n    function initialize(address, address) external;\n}\n\ncontract TestUniswapV2Factory {\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"TestUniswapV2: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"TestUniswapV2: ZERO_ADDRESS\");\n        require(\n            getPair[token0][token1] == address(0),\n            \"TestUniswapV2: PAIR_EXISTS\"\n        ); // single check is sufficient\n        bytes memory bytecode = type(TestUniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"TestUniswapV2: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"TestUniswapV2: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/mocks/TestUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\ninterface IUniswapV2Factory {\n    function feeTo() external view returns (address);\n}\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ncontract TestUniswapV2Pair is ERC20 {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"TestUniswapV2: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TestUniswapV2: TRANSFER_FAILED\"\n        );\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() ERC20(\"TestUniswapV2Pair\", \"TEST_UNIV2_LP\") {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"TestUniswapV2: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= type(uint112).max && balance1 <= type(uint112).max,\n            \"TestUniswapV2: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply().mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply() can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                amount0.mul(_totalSupply) / _reserve0,\n                amount1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"TestUniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address to\n    ) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf(address(this));\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply() can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 && amount1 > 0,\n            \"TestUniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"TestUniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"TestUniswapV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(\n                to != _token0 && to != _token1,\n                \"TestUniswapV2: INVALID_TO\"\n            );\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IUniswapV2Callee(to).uniswapV2Call(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"TestUniswapV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"TestUniswapV2: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n}\n"
    },
    "contracts/mocks/TroveManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../dependencies/FullMath.sol\";\nimport \"../protocol/TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions\nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n    function computeICR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) external pure returns (uint256) {\n        return FullMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(\n        uint256 _coll\n    ) external pure returns (uint256) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getZKUSDGasCompensation() external pure returns (uint256) {\n        return ZKUSD_GAS_COMPENSATION;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing()\n        external\n        returns (uint256)\n    {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= DECIMAL_PRECISION);\n\n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint256) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint256 _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(\n        uint256 _NEONDrawn\n    ) external view returns (uint256) {\n        return _getRedemptionFee(_NEONDrawn);\n    }\n\n    function getActualDebtFromComposite(\n        uint256 _debtVal\n    ) external pure returns (uint256) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint256 troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/mocks/WrapToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract WrapToken is ERC20 {\n    constructor() ERC20(\"Wrapped Token\", \"WT\") {}\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        (bool success, ) = payable(msg.sender).call{value: wad}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"
    },
    "contracts/oracle/ChainlinkPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\n\n/*\n * PriceFeed for mainnet deployment, to be connected to Chainlink's live CFX:USD aggregator reference\n *\n * The PriceFeed uses Chainlink as primary oracle.\n */\ncontract ChainlinkPriceFeed is IPriceFeed, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"ChainlinkPriceFeed\";\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    AggregatorV3Interface public priceAggregator; // Mainnet Chainlink aggregator\n\n    // Use to convert a price answer to an 18-digit precision uint\n    uint256 public constant TARGET_DIGITS = 18;\n\n    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.\n    uint256 public constant TIMEOUT = 14400; // 4 hours: 60 * 60 * 4\n\n    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.\n    uint256 public constant MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND = 5e17; // 50%\n\n    // The last good price seen from an oracle by zkt\n    uint256 public lastGoodPrice;\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 timestamp;\n        bool success;\n        uint8 decimals;\n    }\n\n    // --- Dependency setters ---\n    function setAddresses(address _priceAggregatorAddress) external onlyOwner {\n        checkContract(_priceAggregatorAddress);\n\n        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);\n\n        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice\n        ChainlinkResponse\n            memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse\n            memory prevChainlinkResponse = _getPrevChainlinkResponse(\n                chainlinkResponse.roundId,\n                chainlinkResponse.decimals\n            );\n\n        require(\n            !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&\n                !_chainlinkIsFrozen(chainlinkResponse),\n            \"PriceFeed: Chainlink must be working and current\"\n        );\n\n        _storeChainlinkPrice(chainlinkResponse);\n\n        //renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /*\n     * fetchPrice():\n     * Returns the latest price obtained from the Oracle. Called by zkt functions that require a current price.\n     *\n     * Also callable by anyone externally.\n     *\n     * Non-view function - it stores the last good price seen by zkt.\n     *\n     * Uses a main oracle (Chainlink)\n     * it uses the last good price seen.\n     *\n     */\n    function fetchPrice() external override returns (uint256) {\n        ChainlinkResponse\n            memory chainlinkResponse = _getCurrentChainlinkResponse();\n        ChainlinkResponse\n            memory prevChainlinkResponse = _getPrevChainlinkResponse(\n                chainlinkResponse.roundId,\n                chainlinkResponse.decimals\n            );\n\n        // If Chainlink breaks, now both oracles are untrusted\n        if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {\n            return lastGoodPrice;\n        }\n\n        if (_chainlinkIsFrozen(chainlinkResponse)) {\n            return lastGoodPrice;\n        }\n\n        if (\n            _chainlinkPriceChangeAboveMax(\n                chainlinkResponse,\n                prevChainlinkResponse\n            )\n        ) {\n            return lastGoodPrice;\n        }\n\n        return _storeChainlinkPrice(chainlinkResponse);\n    }\n\n    // --- Helper functions ---\n\n    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round\n     * for two reasons:\n     *\n     * 1) It is necessary data for the price deviation check in case 1,\n     * and\n     * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\n     * peace of mind when using or returning to Chainlink.\n     */\n    function _chainlinkIsBroken(\n        ChainlinkResponse memory _currentResponse,\n        ChainlinkResponse memory _prevResponse\n    ) internal view returns (bool) {\n        return\n            _badChainlinkResponse(_currentResponse) ||\n            _badChainlinkResponse(_prevResponse);\n    }\n\n    function _badChainlinkResponse(\n        ChainlinkResponse memory _response\n    ) internal view returns (bool) {\n        // Check for response call reverted\n        if (!_response.success) {\n            return true;\n        }\n        // Check for an invalid roundId that is 0\n        if (_response.roundId == 0) {\n            return true;\n        }\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {\n            return true;\n        }\n        // Check for non-positive price\n        if (_response.answer <= 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _chainlinkIsFrozen(\n        ChainlinkResponse memory _response\n    ) internal view returns (bool) {\n        return block.timestamp.sub(_response.timestamp) > TIMEOUT;\n    }\n\n    function _chainlinkPriceChangeAboveMax(\n        ChainlinkResponse memory _currentResponse,\n        ChainlinkResponse memory _prevResponse\n    ) internal pure returns (bool) {\n        uint256 currentScaledPrice = _scaleChainlinkPriceByDigits(\n            uint256(_currentResponse.answer),\n            _currentResponse.decimals\n        );\n        uint256 prevScaledPrice = _scaleChainlinkPriceByDigits(\n            uint256(_prevResponse.answer),\n            _prevResponse.decimals\n        );\n\n        uint256 minPrice = Math.min(currentScaledPrice, prevScaledPrice);\n        uint256 maxPrice = Math.max(currentScaledPrice, prevScaledPrice);\n\n        /*\n         * Use the larger price as the denominator:\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\n         * - If price increased, the percentage deviation is in relation to the current price.\n         */\n        uint256 percentDeviation = maxPrice\n            .sub(minPrice)\n            .mul(DECIMAL_PRECISION)\n            .div(maxPrice);\n\n        // Return true if price has more than doubled, or more than halved.\n        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;\n    }\n\n    function _scaleChainlinkPriceByDigits(\n        uint256 _price,\n        uint256 _answerDigits\n    ) internal pure returns (uint256) {\n        /*\n         * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by zkt.\n         * At date of zkt launch, Chainlink uses an 8-digit price, but we also handle the possibility of\n         * future changes.\n         *\n         */\n        uint256 price;\n        if (_answerDigits >= TARGET_DIGITS) {\n            // Scale the returned price value down to zkt's target precision\n            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));\n        } else if (_answerDigits < TARGET_DIGITS) {\n            // Scale the returned price value up to zkt's target precision\n            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));\n        }\n        return price;\n    }\n\n    function _storePrice(uint256 _currentPrice) internal {\n        lastGoodPrice = _currentPrice;\n        emit LastGoodPriceUpdated(_currentPrice);\n    }\n\n    function _storeChainlinkPrice(\n        ChainlinkResponse memory _chainlinkResponse\n    ) internal returns (uint256) {\n        uint256 scaledChainlinkPrice = _scaleChainlinkPriceByDigits(\n            uint256(_chainlinkResponse.answer),\n            _chainlinkResponse.decimals\n        );\n        _storePrice(scaledChainlinkPrice);\n\n        return scaledChainlinkPrice;\n    }\n\n    function _getCurrentChainlinkResponse()\n        internal\n        view\n        returns (ChainlinkResponse memory chainlinkResponse)\n    {\n        // First, try to get current decimal precision:\n        try priceAggregator.decimals() returns (uint8 decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            chainlinkResponse.decimals = decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // If call to Chainlink succeeds, return the response and success = true\n            chainlinkResponse.roundId = roundId;\n            chainlinkResponse.answer = answer;\n            chainlinkResponse.timestamp = timestamp;\n            chainlinkResponse.success = true;\n            return chainlinkResponse;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return chainlinkResponse;\n        }\n    }\n\n    function _getPrevChainlinkResponse(\n        uint80 _currentRoundId,\n        uint8 _currentDecimals\n    ) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {\n        /*\n         * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\n         */\n\n        // Try to get the price data from the previous round:\n        try priceAggregator.getRoundData(_currentRoundId - 1) returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // If call to Chainlink succeeds, return the response and success = true\n            prevChainlinkResponse.roundId = roundId;\n            prevChainlinkResponse.answer = answer;\n            prevChainlinkResponse.timestamp = timestamp;\n            prevChainlinkResponse.decimals = _currentDecimals;\n            prevChainlinkResponse.success = true;\n            return prevChainlinkResponse;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response with success = false\n            return prevChainlinkResponse;\n        }\n    }\n}\n"
    },
    "contracts/oracle/PythPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\n\n/*\n * PriceFeed for mainnet deployment, to be connected to Pyth-netowrk's live `NATIVE`:USD aggregator reference\n *\n * The PriceFeed uses Pyth-network as primary oracle.\n */\ncontract PythPriceFeed is IPriceFeed, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    event UpdatePythPriceByData(\n        bytes[] priceUpdateData,\n        PythStructs.Price price\n    );\n\n    string public constant NAME = \"PythNetworkPriceFeed\";\n    uint256 public constant PYTH_MAX_AGE = 20;\n\n    // Pyth network\n    IPyth public pythAggregator;\n    bytes32 public priceFeedId;\n\n    uint256 public lastGoodPrice;\n    PythStructs.Price internal _lastGoodRetrievedPrice;\n\n    // Use to convert a price answer to an 18-digit precision uint\n    uint256 public constant TARGET_DIGITS = 18;\n\n    // --- Dependency setters ---\n    function setAddresses(\n        bytes32 _priceFeedId,\n        address _priceAggregatorAddress\n    ) external onlyOwner {\n        checkContract(_priceAggregatorAddress);\n\n        priceFeedId = _priceFeedId;\n        pythAggregator = IPyth(_priceAggregatorAddress);\n\n        (\n            uint256 price,\n            ,\n            PythStructs.Price memory retrievedPrice\n        ) = _getPythPrice();\n        lastGoodPrice = price;\n        _lastGoodRetrievedPrice = retrievedPrice;\n    }\n\n    // --- Functions ---\n\n    /*\n     * fetchPrice():\n     * Returns the latest price obtained from the Oracle. Called by zkt functions that require a current price.\n     *\n     * Also callable by anyone externally.\n     *\n     * Non-view function - it stores the last good price seen by zkt.\n     *\n     * Uses a main oracle (PythNetwork)\n     * it uses the last good price seen.\n     *\n     */\n    function fetchPrice() external override returns (uint256) {\n        (\n            uint256 price,\n            uint256 publishTime,\n            PythStructs.Price memory retrievedPrice\n        ) = _getPythPrice();\n        if (block.timestamp - publishTime > PYTH_MAX_AGE) {\n            uint256 _lastGoodRetrievedPriceValue = _calculatePrice(\n                _lastGoodRetrievedPrice\n            );\n            if (\n                block.timestamp - _lastGoodRetrievedPrice.publishTime <=\n                PYTH_MAX_AGE\n            ) {\n                return _lastGoodRetrievedPriceValue;\n            } else if (publishTime > _lastGoodRetrievedPrice.publishTime) {\n                return price;\n            } else {\n                return _lastGoodRetrievedPriceValue;\n            }\n        } else {\n            lastGoodPrice = price;\n            _lastGoodRetrievedPrice = retrievedPrice;\n        }\n        return price;\n    }\n\n    function updatePythPrice(\n        bytes[] calldata priceUpdateData\n    ) external payable {\n        // Updates price for all submitted price feeds\n        uint256 fee = pythAggregator.getUpdateFee(priceUpdateData);\n        require(msg.value >= fee, \"Insufficient fee\");\n        pythAggregator.updatePriceFeeds{value: fee}(priceUpdateData);\n        _lastGoodRetrievedPrice = pythAggregator.getPrice(priceFeedId);\n        lastGoodPrice = _calculatePrice(_lastGoodRetrievedPrice);\n        emit UpdatePythPriceByData(priceUpdateData, _lastGoodRetrievedPrice);\n\n        if (msg.value - fee > 0) {\n            // Need to refund msg.sender. Try to return unused value, or revert if failed\n            // solhint-disable-next-line  avoid-low-level-calls\n            (bool success, ) = payable(msg.sender).call{value: msg.value - fee}(\n                \"\"\n            );\n            require(success, \"Failed to refund msg.sender\");\n        }\n    }\n\n    function _getPythPrice()\n        internal\n        view\n        returns (uint256, uint256, PythStructs.Price memory)\n    {\n        // It will revert if the price is older than maxAge\n        PythStructs.Price memory retrievedPrice = pythAggregator.getPriceUnsafe(\n            priceFeedId\n        );\n\n        // Convert price to 18 decimals\n        uint256 price = _calculatePrice(retrievedPrice);\n        uint256 publishTime = retrievedPrice.publishTime;\n\n        return (price, publishTime, retrievedPrice);\n    }\n\n    function _calculatePrice(\n        PythStructs.Price memory retrievedPrice\n    ) internal pure returns (uint256 price) {\n        /*\n        retrievedPrice.price fixed-point representation base\n        retrievedPrice.expo fixed-point representation exponent (to go from base to decimal)\n        retrievedPrice.conf fixed-point representation of confidence\n        i.e.\n        .price = 12276250\n        .expo = -5\n        price = 12276250 * 10^(-5) =  122.76250\n        to go to 18 decimals => rebasedPrice = 12276250 * 10^(18-5) = 122762500000000000000\n        */\n\n        // Adjust exponent (using base as 18 decimals)\n        uint256 baseConvertion = 10 **\n            uint256(int256(TARGET_DIGITS) + retrievedPrice.expo);\n\n        price = uint256(retrievedPrice.price * int256(baseConvertion));\n    }\n}\n"
    },
    "contracts/oracle/WitnetPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"witnet-solidity-bridge/contracts/interfaces/IWitnetPriceRouter.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\n\ncontract WitnetPriceFeed is IPriceFeed, Ownable, CheckContract {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"WitnetPriceFeed\";\n\n    IWitnetPriceRouter public priceRouter;\n    bytes4 public priceFeedId;\n\n    // Use to convert a price answer to an 18-digit precision uint256\n    uint256 public constant TARGET_DIGITS = 18;\n    uint256 public constant WITNET_DIGITS = 6;\n\n    /// last good price fetch by troveManage\n    uint256 public lastGoodPrice;\n    WitnetResponse public latestGoodResponse;\n\n    struct WitnetResponse {\n        int256 lastPrice;\n        uint256 lastTimestamp;\n        uint256 lastUpdateStatus;\n    }\n\n    // --- Dependency setters ---\n    function setAddresses(\n        bytes4 _priceFeedId,\n        address _priceRouter\n    ) external onlyOwner {\n        checkContract(_priceRouter);\n\n        priceFeedId = _priceFeedId;\n        priceRouter = IWitnetPriceRouter(_priceRouter);\n        WitnetResponse memory witnetResponse = _getCurrentResponse();\n        _storeLocalPrice(witnetResponse);\n    }\n\n    function fetchPrice() external override returns (uint256) {\n        WitnetResponse memory witnetResponse = _getCurrentResponse();\n        if (latestGoodResponse.lastTimestamp > witnetResponse.lastTimestamp) {\n            return\n                _scalePriceByDigits(\n                    uint256(latestGoodResponse.lastPrice),\n                    WITNET_DIGITS\n                );\n        } else {\n            _storeLocalPrice(witnetResponse);\n            return lastGoodPrice;\n        }\n    }\n\n    function _getCurrentResponse()\n        internal\n        view\n        returns (WitnetResponse memory witnetResponse)\n    {\n        //try to get latest price data:\n        try priceRouter.valueFor(bytes32(priceFeedId)) returns (\n            int256 lastPrice,\n            uint256 lastTimestamp,\n            uint256 lastUpdateStatus\n        ) {\n            // If call to Witnet succeeds, return the response and success = true\n            witnetResponse.lastPrice = lastPrice;\n            witnetResponse.lastTimestamp = lastTimestamp;\n            witnetResponse.lastUpdateStatus = lastUpdateStatus;\n            return witnetResponse;\n        } catch {\n            // If call to Witnet aggregator reverts, return a zero response with success = false\n            return witnetResponse;\n        }\n    }\n\n    function _storeLocalPrice(WitnetResponse memory witnetResponse) internal {\n        uint256 scaledPrice = _scalePriceByDigits(\n            uint256(witnetResponse.lastPrice),\n            WITNET_DIGITS\n        );\n        lastGoodPrice = scaledPrice;\n        latestGoodResponse = witnetResponse;\n        emit LastGoodPriceUpdated(lastGoodPrice);\n    }\n\n    function _scalePriceByDigits(\n        uint256 _price,\n        uint256 _digits\n    ) internal pure returns (uint256 price) {\n        /*\n         * Convert the price returned by the Witnet oracle to an 18-digit decimal for use by Liquity.\n         * At date of Rime launch, Witnet uses an 6-digit price, but we also handle the possibility of\n         * future changes.\n         *\n         */\n        if (_digits >= TARGET_DIGITS) {\n            // Scale the returned price value down to Liquity's target precision\n            price = _price.div(10 ** (_digits - TARGET_DIGITS));\n        } else if (_digits < TARGET_DIGITS) {\n            // Scale the returned price value up to Liquity's target precision\n            price = _price.mul(10 ** (TARGET_DIGITS - _digits));\n        }\n        return price;\n    }\n}\n"
    },
    "contracts/protocol/ActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IActivePool.sol\";\n\n/*\n * The Active Pool holds the NEON collateral and ZKUSD debt (but not ZKUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's NEON and ZKUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"ActivePool\";\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    uint256 internal NEON; // deposited ether tracker\n    uint256 internal ZKUSDDebt;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n     * Returns the NEON state variable.\n     *\n     *Not necessarily equal to the the contract's raw NEON balance - ether can be forcibly sent to contracts.\n     */\n    function getNEON() external view override returns (uint256) {\n        return NEON;\n    }\n\n    function getZKUSDDebt() external view override returns (uint256) {\n        return ZKUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendNEON(address _account, uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        NEON = NEON.sub(_amount);\n        emit ActivePoolNEONBalanceUpdated(NEON);\n        emit ConfluxSent(_account, _amount);\n\n        (bool success, ) = _account.call{value: _amount}(\"\");\n        require(success, \"ActivePool: sending NEON failed\");\n    }\n\n    function increaseZKUSDDebt(uint256 _amount) external override {\n        _requireCallerIsBOorTroveM();\n        ZKUSDDebt = ZKUSDDebt.add(_amount);\n        emit ActivePoolZKUSDDebtUpdated(ZKUSDDebt);\n    }\n\n    function decreaseZKUSDDebt(uint256 _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        ZKUSDDebt = ZKUSDDebt.sub(_amount);\n        emit ActivePoolZKUSDDebtUpdated(ZKUSDDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        NEON = NEON.add(msg.value);\n        emit ActivePoolNEONBalanceUpdated(NEON);\n    }\n}\n"
    },
    "contracts/protocol/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IZKTStaking.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\nimport \"../dependencies/ZKTProtocolBase.sol\";\n\ncontract BorrowerOperations is\n    IBorrowerOperations,\n    ZKTProtocolBase,\n    CheckContract,\n    Ownable\n{\n    using SafeMath for uint256;\n\n    string public constant NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IZKTStaking public zktStaking;\n    address public zktStakingAddress;\n\n    IZKUSDToken public zkusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _zkusdTokenAddress,\n        address _zktStakingAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn ZKUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_zkusdTokenAddress);\n        checkContract(_zktStakingAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\n        zktStakingAddress = _zktStakingAddress;\n        zktStaking = IZKTStaking(_zktStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit ZKUSDTokenAddressChanged(_zkusdTokenAddress);\n        emit ZKTStakingAddressChanged(_zktStakingAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _ZKUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            zkusdToken\n        );\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.ZKUSDFee;\n        vars.netDebt = _ZKUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.ZKUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.zkusdToken,\n                _ZKUSDAmount,\n                _maxFeePercentage\n            );\n            vars.netDebt = vars.netDebt.add(vars.ZKUSDFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested ZKUSD amount + ZKUSD borrowing fee + ZKUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n\n        vars.ICR = FullMath._computeCR(\n            msg.value,\n            vars.compositeDebt,\n            vars.price\n        );\n        vars.NICR = FullMath._computeNominalCR(msg.value, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                msg.value,\n                true,\n                vars.compositeDebt,\n                true,\n                vars.price\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, msg.value);\n        contractsCache.troveManager.increaseTroveDebt(\n            msg.sender,\n            vars.compositeDebt\n        );\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            msg.sender\n        );\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(\n            msg.sender\n        );\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the ether to the Active Pool, and mint the ZKUSDAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, msg.value);\n        _withdrawZKUSD(\n            contractsCache.activePool,\n            contractsCache.zkusdToken,\n            msg.sender,\n            _ZKUSDAmount,\n            vars.netDebt\n        );\n        // Move the ZKUSD gas compensation to the Gas Pool\n        _withdrawZKUSD(\n            contractsCache.activePool,\n            contractsCache.zkusdToken,\n            gasPoolAddress,\n            ZKUSD_GAS_COMPENSATION,\n            ZKUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.compositeDebt,\n            msg.value,\n            vars.stake,\n            Operation.openTrove\n        );\n        emit ZKUSDBorrowingFeePaid(msg.sender, vars.ZKUSDFee);\n    }\n\n    // Send NEON as collateral to a trove\n    function addColl(\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send NEON as collateral to a trove. Called by only the Stability Pool.\n    function moveNEONGainToTrove(\n        address _borrower,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw NEON collateral from a trove\n    function withdrawColl(\n        uint256 _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            _collWithdrawal,\n            0,\n            false,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Withdraw ZKUSD tokens from a trove: mint new ZKUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawZKUSD(\n        uint256 _maxFeePercentage,\n        uint256 _ZKUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _ZKUSDAmount,\n            true,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    // Repay ZKUSD tokens to a Trove: Burn the repaid ZKUSD tokens, and reduce the trove's debt accordingly\n    function repayZKUSD(\n        uint256 _ZKUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _ZKUSDAmount,\n            false,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    function adjustTrove(\n        uint256 _maxFeePercentage,\n        uint256 _collWithdrawal,\n        uint256 _ZKUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external payable override {\n        _adjustTrove(\n            msg.sender,\n            _collWithdrawal,\n            _ZKUSDChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    /*\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     *\n     * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n     *\n     * If both are positive, it will revert.\n     */\n    function _adjustTrove(\n        address _borrower,\n        uint256 _collWithdrawal,\n        uint256 _ZKUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) internal {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            zkusdToken\n        );\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_ZKUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _ZKUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure NEON transfer from the Stability Pool to a trove\n        assert(\n            msg.sender == _borrower ||\n                (msg.sender == stabilityPoolAddress &&\n                    msg.value > 0 &&\n                    _ZKUSDChange == 0)\n        );\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not NEON was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(\n            msg.value,\n            _collWithdrawal\n        );\n\n        vars.netDebtChange = _ZKUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) {\n            vars.ZKUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.zkusdToken,\n                _ZKUSDChange,\n                _maxFeePercentage\n            );\n            vars.netDebtChange = vars.netDebtChange.add(vars.ZKUSDFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = FullMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease,\n            vars.price\n        );\n\n        assert(_collWithdrawal <= vars.coll);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            _collWithdrawal,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough ZKUSD\n        if (!_isDebtIncrease && _ZKUSDChange > 0) {\n            _requireAtLeastMinNetDebt(\n                _getNetDebt(vars.debt).sub(vars.netDebtChange)\n            );\n            _requireValidZKUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientZKUSDBalance(\n                contractsCache.zkusdToken,\n                _borrower,\n                vars.netDebtChange\n            );\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            _borrower,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            _borrower\n        );\n\n        // Re-insert trove in to the sorted list\n        uint256 newNICR = _getNewNominalICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(\n            _borrower,\n            vars.newDebt,\n            vars.newColl,\n            vars.stake,\n            Operation.adjustTrove\n        );\n        emit ZKUSDBorrowingFeePaid(msg.sender, vars.ZKUSDFee);\n\n        // Use the unmodified _ZKUSDChange here, as we don't send the fee to the user\n        _moveTokensAndNEONfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.zkusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _ZKUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IZKUSDToken zkusdTokenCached = zkusdToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint256 price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint256 coll = troveManagerCached.getTroveColl(msg.sender);\n        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientZKUSDBalance(\n            zkusdTokenCached,\n            msg.sender,\n            debt.sub(ZKUSD_GAS_COMPENSATION)\n        );\n\n        uint256 newTCR = _getNewTCRFromTroveChange(\n            coll,\n            false,\n            debt,\n            false,\n            price\n        );\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, Operation.closeTrove);\n\n        // Burn the repaid ZKUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayZKUSD(\n            activePoolCached,\n            zkusdTokenCached,\n            msg.sender,\n            debt.sub(ZKUSD_GAS_COMPENSATION)\n        );\n        _repayZKUSD(\n            activePoolCached,\n            zkusdTokenCached,\n            gasPoolAddress,\n            ZKUSD_GAS_COMPENSATION\n        );\n\n        // Send the collateral back to the user\n        activePoolCached.sendNEON(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send NEON from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IZKUSDToken _zkusdToken,\n        uint256 _ZKUSDAmount,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 ZKUSDFee = _troveManager.getBorrowingFee(_ZKUSDAmount);\n\n        _requireUserAcceptsFee(ZKUSDFee, _ZKUSDAmount, _maxFeePercentage);\n\n        // Send fee to ZKT staking contract\n        zktStaking.increaseF_ZKUSD(ZKUSDFee);\n        _zkusdToken.mint(zktStakingAddress, ZKUSDFee);\n\n        return ZKUSDFee;\n    }\n\n    function _getUSDValue(\n        uint256 _coll,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        uint256 usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    ) internal pure returns (uint256 collChange, bool isCollIncrease) {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal returns (uint256, uint256) {\n        uint256 newColl = (_isCollIncrease)\n            ? _troveManager.increaseTroveColl(_borrower, _collChange)\n            : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint256 newDebt = (_isDebtIncrease)\n            ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n            : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndNEONfromAdjustment(\n        IActivePool _activePool,\n        IZKUSDToken _zkusdToken,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _ZKUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawZKUSD(\n                _activePool,\n                _zkusdToken,\n                _borrower,\n                _ZKUSDChange,\n                _netDebtChange\n            );\n        } else {\n            _repayZKUSD(_activePool, _zkusdToken, _borrower, _ZKUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendNEON(_borrower, _collChange);\n        }\n    }\n\n    // Send NEON to Active Pool and increase its recorded NEON balance\n    function _activePoolAddColl(\n        IActivePool _activePool,\n        uint256 _amount\n    ) internal {\n        (bool success, ) = address(_activePool).call{value: _amount}(\"\");\n        require(success, \"Operation: Sending NEON to ActivePool failed\");\n    }\n\n    // Issue the specified amount of ZKUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a ZKUSDFee)\n    function _withdrawZKUSD(\n        IActivePool _activePool,\n        IZKUSDToken _zkusdToken,\n        address _account,\n        uint256 _ZKUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseZKUSDDebt(_netDebtIncrease);\n        _zkusdToken.mint(_account, _ZKUSDAmount);\n    }\n\n    // Burn the specified amount of ZKUSD from _account and decreases the total active debt\n    function _repayZKUSD(\n        IActivePool _activePool,\n        IZKUSDToken _zkusdToken,\n        address _account,\n        uint256 _ZKUSD\n    ) internal {\n        _activePool.decreaseZKUSDDebt(_ZKUSD);\n        _zkusdToken.burn(_account, _ZKUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint256 _collWithdrawal) internal view {\n        require(\n            msg.value == 0 || _collWithdrawal == 0,\n            \"Operation: Cannot withdraw and add coll\"\n        );\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(\n            msg.sender == _borrower,\n            \"Operation: Caller must be the borrower for a withdrawal\"\n        );\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256 _collWithdrawal,\n        uint256 _ZKUSDChange\n    ) internal view {\n        require(\n            msg.value != 0 || _collWithdrawal != 0 || _ZKUSDChange != 0,\n            \"Operation: There must be either a collateral change or a debt change\"\n        );\n    }\n\n    function _requireTroveisActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        uint256 status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"Operation: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        uint256 status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"Operation: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _ZKUSDChange) internal pure {\n        require(\n            _ZKUSDChange > 0,\n            \"Operation: Debt increase requires non-zero debtChange\"\n        );\n    }\n\n    function _requireNotInRecoveryMode(uint256 _price) internal view {\n        require(\n            !_checkRecoveryMode(_price),\n            \"Operation: Operation not permitted during Recovery Mode\"\n        );\n    }\n\n    function _requireNoCollWithdrawal(uint256 _collWithdrawal) internal pure {\n        require(\n            _collWithdrawal == 0,\n            \"Operation: Collateral withdrawal not permitted Recovery Mode\"\n        );\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease,\n                _vars.price\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= MCR,\n            \"Operation: An operation that would result in ICR < MCR is not permitted\"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= CCR,\n            \"Operation: Operation must leave trove with ICR >= CCR\"\n        );\n    }\n\n    function _requireNewICRisAboveOldICR(\n        uint256 _newICR,\n        uint256 _oldICR\n    ) internal pure {\n        require(\n            _newICR >= _oldICR,\n            \"Operation: Cannot decrease your Trove's ICR in Recovery Mode\"\n        );\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(\n            _newTCR >= CCR,\n            \"Operation: An operation that would result in TCR < CCR is not permitted\"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt >= MIN_NET_DEBT,\n            \"Operation: Trove's net debt must be greater than minimum\"\n        );\n    }\n\n    function _requireValidZKUSDRepayment(\n        uint256 _currentDebt,\n        uint256 _debtRepayment\n    ) internal pure {\n        require(\n            _debtRepayment <= _currentDebt.sub(ZKUSD_GAS_COMPENSATION),\n            \"Operation: Amount repaid must not be larger than the Trove's debt\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"Operation: Caller is not Stability Pool\"\n        );\n    }\n\n    function _requireSufficientZKUSDBalance(\n        IZKUSDToken _zkusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _zkusdToken.balanceOf(_borrower) >= _debtRepayment,\n            \"Operation: Caller doesnt have enough ZKUSD to make repayment\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint256 _maxFeePercentage,\n        bool _isRecoveryMode\n    ) internal pure {\n        if (_isRecoveryMode) {\n            require(\n                _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\"\n            );\n        } else {\n            require(\n                _maxFeePercentage >= BORROWING_FEE_FLOOR &&\n                    _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\"\n            );\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint256 newNICR = FullMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint256 newICR = FullMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256, uint256) {\n        uint256 newColl = _coll;\n        uint256 newDebt = _debt;\n\n        newColl = _isCollIncrease\n            ? _coll.add(_collChange)\n            : _coll.sub(_collChange);\n        newDebt = _isDebtIncrease\n            ? _debt.add(_debtChange)\n            : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease\n            ? totalColl.add(_collChange)\n            : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease\n            ? totalDebt.add(_debtChange)\n            : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = FullMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(\n        uint256 _debt\n    ) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n"
    },
    "contracts/protocol/CollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\n\ncontract CollSurplusPool is Ownable, CheckContract, ICollSurplusPool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"CollSurplusPool\";\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public activePoolAddress;\n\n    // Deposited NEON tracker\n    uint256 internal NEON;\n    // Collateral surplus claimable by trove owners\n    mapping(address => uint256) internal balances;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        //renounceOwnership();\n    }\n\n    /* Returns the NEON state variable at ActivePool address.\n    Not necessarily equal to the raw NEON balance - NEON can be forcibly sent to contracts. */\n    function getNEON() external view override returns (uint256) {\n        return NEON;\n    }\n\n    function getCollateral(\n        address _account\n    ) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    // --- Pool functionality ---\n\n    function accountSurplus(\n        address _account,\n        uint256 _amount\n    ) external override {\n        _requireCallerIsTroveManager();\n\n        uint256 newAmount = balances[_account].add(_amount);\n        balances[_account] = newAmount;\n\n        emit CollBalanceUpdated(_account, newAmount);\n    }\n\n    function claimColl(address _account) external override {\n        _requireCallerIsBorrowerOperations();\n        uint256 claimableColl = balances[_account];\n        require(\n            claimableColl > 0,\n            \"CollSurplusPool: No collateral available to claim\"\n        );\n\n        balances[_account] = 0;\n        emit CollBalanceUpdated(_account, 0);\n\n        NEON = NEON.sub(claimableColl);\n        emit NeonSent(_account, claimableColl);\n\n        (bool success, ) = _account.call{value: claimableColl}(\"\");\n        require(success, \"CollSurplusPool: sending NEON failed\");\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"CollSurplusPool: Caller is not Borrower Operations\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"CollSurplusPool: Caller is not TroveManager\"\n        );\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"CollSurplusPool: Caller is not Active Pool\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        NEON = NEON.add(msg.value);\n    }\n}\n"
    },
    "contracts/protocol/DefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\n\n/*\n * The Default Pool holds the NEON and ZKUSD debt (but not ZKUSD tokens) from liquidations that have been redistributed\n * to active troves but not yet \"applied\", i.e. not yet recorded on a recipient active trove's struct.\n *\n * When a trove makes an operation that applies its pending NEON and ZKUSD debt, its pending NEON and ZKUSD debt is moved\n * from the Default Pool to the Active Pool.\n */\ncontract DefaultPool is Ownable, CheckContract, IDefaultPool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"DefaultPool\";\n\n    address public troveManagerAddress;\n    address public activePoolAddress;\n    uint256 internal NEON; // deposited NEON tracker\n    uint256 internal ZKUSDDebt; // debt\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external onlyOwner {\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n     * Returns the NEON state variable.\n     *\n     * Not necessarily equal to the the contract's raw NEON balance - NEON can be forcibly sent to contracts.\n     */\n    function getNEON() external view override returns (uint256) {\n        return NEON;\n    }\n\n    function getZKUSDDebt() external view override returns (uint256) {\n        return ZKUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendNEONToActivePool(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        address activePool = activePoolAddress; // cache to save an SLOAD\n        NEON = NEON.sub(_amount);\n        emit DefaultPoolNEONBalanceUpdated(NEON);\n        emit ConfluxSent(activePool, _amount);\n\n        (bool success, ) = activePool.call{value: _amount}(\"\");\n        require(success, \"DefaultPool: sending NEON failed\");\n    }\n\n    function increaseZKUSDDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        ZKUSDDebt = ZKUSDDebt.add(_amount);\n        emit DefaultPoolZKUSDDebtUpdated(ZKUSDDebt);\n    }\n\n    function decreaseZKUSDDebt(uint256 _amount) external override {\n        _requireCallerIsTroveManager();\n        ZKUSDDebt = ZKUSDDebt.sub(_amount);\n        emit DefaultPoolZKUSDDebtUpdated(ZKUSDDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"DefaultPool: Caller is not the ActivePool\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"DefaultPool: Caller is not the TroveManager\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        NEON = NEON.add(msg.value);\n        emit DefaultPoolNEONBalanceUpdated(NEON);\n    }\n}\n"
    },
    "contracts/protocol/GasPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * The purpose of this contract is to hold ZKUSD tokens for gas compensation:\n * When a borrower opens a trove, an additional 50 ZKUSD debt is issued,\n * and 50 ZKUSD is minted and sent to this contract.\n * When a borrower closes their active trove, this gas compensation is refunded:\n * 50 ZKUSD is burned from the this contract's balance, and the corresponding\n * 50 ZKUSD debt on the trove is cancelled.\n * See this issue for more context: https://github.com/liquity/dev/issues/186\n */\ncontract GasPool {\n    // do nothing, as the core contracts have permission to send to and burn from this address\n}\n"
    },
    "contracts/protocol/HintHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../dependencies/FullMath.sol\";\nimport \"../dependencies/ZKTProtocolBase.sol\";\nimport \"../dependencies/CheckContract.sol\";\n\ncontract HintHelpers is ZKTProtocolBase, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"HintHelpers\";\n\n    ISortedTroves public sortedTroves;\n    ITroveManager public troveManager;\n\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _sortedTrovesAddress,\n        address _troveManagerAddress\n    ) external onlyOwner {\n        checkContract(_sortedTrovesAddress);\n        checkContract(_troveManagerAddress);\n\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().\n     *\n     * It simulates a redemption of `_ZKUSDamount` to figure out where the redemption sequence will start and what state the final Trove\n     * of the sequence will end up in.\n     *\n     * Returns three hints:\n     *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).\n     *  - `partialRedemptionHintNICR` is the final nominal ICR of the last Trove of the sequence after being hit by partial redemption,\n     *     or zero in case of no partial redemption.\n     *  - `truncatedZKUSDamount` is the maximum amount that can be redeemed out of the the provided `_ZKUSDamount`. This can be lower than\n     *    `_ZKUSDamount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the\n     *    minimum allowed value (i.e. MIN_NET_DEBT).\n     *\n     * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero\n     * will leave it uncapped.\n     */\n\n    function getRedemptionHints(\n        uint256 _ZKUSDamount,\n        uint256 _price,\n        uint256 _maxIterations\n    )\n        external\n        view\n        returns (\n            address firstRedemptionHint,\n            uint256 partialRedemptionHintNICR,\n            uint256 truncatedZKUSDamount\n        )\n    {\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        uint256 remainingZKUSD = _ZKUSDamount;\n        address currentTroveuser = sortedTrovesCached.getLast();\n\n        while (\n            currentTroveuser != address(0) &&\n            troveManager.getCurrentICR(currentTroveuser, _price) < MCR\n        ) {\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n        }\n\n        firstRedemptionHint = currentTroveuser;\n\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n\n        while (\n            currentTroveuser != address(0) &&\n            remainingZKUSD > 0 &&\n            _maxIterations-- > 0\n        ) {\n            uint256 netZKUSDDebt = _getNetDebt(\n                troveManager.getTroveDebt(currentTroveuser)\n            ).add(troveManager.getPendingZKUSDDebtReward(currentTroveuser));\n\n            if (netZKUSDDebt > remainingZKUSD) {\n                if (netZKUSDDebt > MIN_NET_DEBT) {\n                    uint256 maxRedeemableZKUSD = Math.min(\n                        remainingZKUSD,\n                        netZKUSDDebt.sub(MIN_NET_DEBT)\n                    );\n\n                    uint256 NEON = troveManager\n                        .getTroveColl(currentTroveuser)\n                        .add(\n                            troveManager.getPendingNEONReward(currentTroveuser)\n                        );\n\n                    uint256 newColl = NEON.sub(\n                        maxRedeemableZKUSD.mul(DECIMAL_PRECISION).div(_price)\n                    );\n                    uint256 newDebt = netZKUSDDebt.sub(maxRedeemableZKUSD);\n\n                    uint256 compositeDebt = _getCompositeDebt(newDebt);\n                    partialRedemptionHintNICR = FullMath._computeNominalCR(\n                        newColl,\n                        compositeDebt\n                    );\n\n                    remainingZKUSD = remainingZKUSD.sub(maxRedeemableZKUSD);\n                }\n                break;\n            } else {\n                remainingZKUSD = remainingZKUSD.sub(netZKUSDDebt);\n            }\n\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\n        }\n\n        truncatedZKUSDamount = _ZKUSDamount.sub(remainingZKUSD);\n    }\n\n    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the\nsortedTroves list from the correct insert position of the Trove to be inserted.\n\nNote: The output address is worst-case O(n) positions away from the correct insert position, however, the function\nis probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\n\nSubmitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will\nbe <= sqrt(length) positions away from the correct insert position.\n*/\n    function getApproxHint(\n        uint256 _CR,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed\n    )\n        external\n        view\n        returns (address hintAddress, uint256 diff, uint256 latestRandomSeed)\n    {\n        uint256 arrayLength = troveManager.getTroveOwnersCount();\n\n        if (arrayLength == 0) {\n            return (address(0), 0, _inputRandomSeed);\n        }\n\n        hintAddress = sortedTroves.getLast();\n        diff = FullMath._getAbsoluteDifference(\n            _CR,\n            troveManager.getNominalICR(hintAddress)\n        );\n        latestRandomSeed = _inputRandomSeed;\n\n        uint256 i = 1;\n\n        while (i < _numTrials) {\n            latestRandomSeed = uint256(\n                keccak256(abi.encodePacked(latestRandomSeed))\n            );\n\n            uint256 arrayIndex = latestRandomSeed % arrayLength;\n            address currentAddress = troveManager.getTroveFromTroveOwnersArray(\n                arrayIndex\n            );\n            uint256 currentNICR = troveManager.getNominalICR(currentAddress);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\n            uint256 currentDiff = FullMath._getAbsoluteDifference(\n                currentNICR,\n                _CR\n            );\n\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n    }\n\n    function computeNominalCR(\n        uint256 _coll,\n        uint256 _debt\n    ) external pure returns (uint256) {\n        return FullMath._computeNominalCR(_coll, _debt);\n    }\n\n    function computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) external pure returns (uint256) {\n        return FullMath._computeCR(_coll, _debt, _price);\n    }\n}\n"
    },
    "contracts/protocol/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        uint256 snapshotNEON;\n        uint256 snapshotZKUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(\n        int256 _startIdx,\n        uint256 _count\n    ) external view returns (CombinedTroveData[] memory _troves) {\n        uint256 startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint256(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint256(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint256 sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint256 maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotNEON,\n                _troves[idx].snapshotZKUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotNEON,\n                _troves[idx].snapshotZKUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/protocol/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../dependencies/CheckContract.sol\";\n\n/*\n * A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n * change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n * but maintains their order. A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n * to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n *\n *\n * Changes made in the Liquity implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the CFX:USD price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n */\ncontract SortedTroves is ISortedTroves, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"SortedTroves\";\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId; // Id of next node (smaller NICR) in the list\n        address prevId; // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head; // Head of the list. Also the node in the list with the largest NICR\n        address tail; // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize; // Maximum size of the list\n        uint256 size; // Current size of the list\n        mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters ---\n\n    function setParams(\n        uint256 _size,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cannot be zero\");\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        //renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function _insert(\n        ITroveManager _troveManager,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(\n                _troveManager,\n                _NICR,\n                prevId,\n                nextId\n            );\n        }\n\n        data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size = data.size.add(1);\n        emit NodeAdded(_id, _NICR);\n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data\n                    .nodes[_id]\n                    .nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data\n                    .nodes[_id]\n                    .prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size = data.size.sub(1);\n        emit NodeRemoved(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return\n                data.head == _nextId &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return\n                data.tail == _prevId &&\n                _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return\n                data.nodes[_prevId].nextId == _nextId &&\n                _troveManager.getNominalICR(_prevId) >= _NICR &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (\n            data.head == _startId &&\n            _NICR >= _troveManager.getNominalICR(_startId)\n        ) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (\n            prevId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (\n            data.tail == _startId &&\n            _NICR <= _troveManager.getNominalICR(_startId)\n        ) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (\n            nextId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (\n                !contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)\n            ) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (\n                !contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)\n            ) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"SortedTroves: Caller is not the TroveManager\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM(\n        ITroveManager _troveManager\n    ) internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == address(_troveManager),\n            \"SortedTroves: Caller is neither BO nor TroveM\"\n        );\n    }\n}\n"
    },
    "contracts/protocol/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/IZKTStaking.sol\";\nimport \"../interfaces/ICommunityIssuance.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\nimport \"../dependencies/ZKTProtocolBase.sol\";\n\n/*\n * The Stability Pool holds ZKUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its ZKUSD debt gets offset with\n * ZKUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of ZKUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a ZKUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an NEON gain, as the NEON collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total ZKUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and NEON gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and NEON gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated NEON gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated NEON gain is derived here:\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated NEON gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding NEON gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated NEON gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion ZKUSD has depleted to < 1 ZKUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S NEON GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated NEON gain, during the epoch in which the deposit was non-zero and earned NEON.\n *\n * We calculate the depositor's accumulated NEON gain for the scale at which they made the deposit, using the NEON gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated NEON gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / NEON gain derivations:\n *\n *\n * --- ZKT ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An ZKT issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued ZKT in proportion to the deposit as a share of total deposits. The ZKT earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * We use the same mathematical product-sum approach to track ZKT gains for depositors, where 'G' is the sum corresponding to ZKT gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is\n    IStabilityPool,\n    ZKTProtocolBase,\n    CheckContract,\n    Ownable\n{\n    using SafeMath for uint256;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    IZKUSDToken public zkusdToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    uint256 internal NEON; // deposited conflux tracker\n\n    // Tracker for ZKUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalZKUSDDeposits;\n\n    // --- Data structures ---\n\n    struct Snapshots {\n        uint256 S;\n        uint256 P;\n        uint256 G;\n        uint256 scale;\n        uint256 epoch;\n    }\n\n    mapping(address => uint256) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n\n    // remove frontEnd and use adminVault instead, each FrontEnds is treasury address with 99.9% kickbackRate\n    address public treasury;\n    uint256 public constant DefaultKickbackRate =\n        DECIMAL_PRECISION - (10 * DECIMAL_PRECISION) / 1000;\n\n    mapping(address => uint256) public frontEndStakes; // depositer address (front end address)[expired] -> last recorded total deposits, tagged with that front end\n    mapping(address => Snapshots) public frontEndSnapshots; // depositer address (front end address)[expired] -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some ZKUSD debt with the deposit.\n     *\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     */\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint256 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint256 public currentEpoch;\n\n    /* NEON Gain sum 'S': During its lifetime, each deposit d_t earns an NEON gain of ( d_t * [S - S_t] )/P_t, where S_t\n     * is the depositor's snapshot of S taken at the time t when the deposit was made.\n     *\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n     *\n     * - The inner mapping records the sum S at different scales\n     * - The outer mapping records the (scale => sum) mappings, for different epochs.\n     */\n    mapping(uint256 => mapping(uint256 => uint256)) public epochToScaleToSum;\n\n    /*\n     * Similarly, the sum 'G' is used to calculate ZKT gains. During it's lifetime, each deposit d_t earns a ZKT gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n     *\n     *  ZKT reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the ZKT reward is issued (i.e. G is updated), before other state changes are made.\n     */\n    mapping(uint256 => mapping(uint256 => uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the ZKT issuance calculation\n    uint256 public lastZKTError;\n    // Error trackers for the error correction in the offset calculation\n    uint256 public lastNEONError_Offset;\n    uint256 public lastZKUSDLossError_Offset;\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress,\n        address _treasuryAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_zkusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        treasury = _treasuryAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit ZKUSDTokenAddressChanged(_zkusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getNEON() external view override returns (uint256) {\n        return NEON;\n    }\n\n    function getTotalZKUSDDeposits() external view override returns (uint256) {\n        return totalZKUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n     *\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Sends the tagged front end's accumulated ZKT gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint256 _amount) external override {\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender];\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerZKTIssuance(communityIssuanceCached);\n\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\n\n        // First pay out any ZKT gains\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\n            msg.sender\n        );\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\n\n        _sendZKUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedZKUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss); // ZKUSD Loss required for event log\n\n        _sendNEONGainToDepositor(depositorNEONGain);\n    }\n\n    /*  withdrawFromSP():\n     *\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Sends the tagged front end's accumulated ZKT gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender];\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerZKTIssuance(communityIssuanceCached);\n\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\n\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\n        uint256 ZKUSDtoWithdraw = Math.min(_amount, compoundedZKUSDDeposit);\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\n\n        // First pay out any ZKT gains\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\n            msg.sender\n        );\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(ZKUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\n\n        _sendZKUSDToDepositor(msg.sender, ZKUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedZKUSDDeposit.sub(ZKUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss); // ZKUSD Loss required for event log\n\n        _sendNEONGainToDepositor(depositorNEONGain);\n    }\n\n    /* withdrawNEONGainToTrove:\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's ZKT gain to  depositor\n     * - Sends all tagged front end's ZKT gain to the tagged front end\n     * - Transfers the depositor's entire NEON gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawNEONGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external override {\n        uint256 initialDeposit = deposits[msg.sender];\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasNEONGain(msg.sender);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerZKTIssuance(communityIssuanceCached);\n\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\n\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\n\n        // First pay out any ZKT gains\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\n            msg.sender\n        );\n        uint256 newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedZKUSDDeposit);\n\n        /* Emit events before transferring NEON gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the NEON gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss);\n        emit UserDepositChanged(msg.sender, compoundedZKUSDDeposit);\n\n        NEON = NEON.sub(depositorNEONGain);\n        emit StabilityPoolNEONBalanceUpdated(NEON);\n        emit NeonSent(msg.sender, depositorNEONGain);\n\n        borrowerOperations.moveNEONGainToTrove{value: depositorNEONGain}(\n            msg.sender,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    // --- ZKT issuance functions ---\n\n    function _triggerZKTIssuance(\n        ICommunityIssuance _communityIssuance\n    ) internal {\n        uint256 ZKTIssuance = _communityIssuance.issueZKT();\n        _updateG(ZKTIssuance);\n    }\n\n    function _updateG(uint256 _ZKTIssuance) internal {\n        uint256 totalZKUSD = totalZKUSDDeposits; // cached to save an SLOAD\n        /*\n         * When total deposits is 0, G is not updated. In this case, the ZKT issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         *\n         */\n        if (totalZKUSD == 0 || _ZKTIssuance == 0) {\n            return;\n        }\n\n        uint256 ZKTPerUnitStaked;\n        ZKTPerUnitStaked = _computeZKTPerUnitStaked(_ZKTIssuance, totalZKUSD);\n\n        uint256 marginalZKTGain = ZKTPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[\n            currentEpoch\n        ][currentScale].add(marginalZKTGain);\n\n        emit G_Updated(\n            epochToScaleToG[currentEpoch][currentScale],\n            currentEpoch,\n            currentScale\n        );\n    }\n\n    function _computeZKTPerUnitStaked(\n        uint256 _ZKTIssuance,\n        uint256 _totalZKUSDDeposits\n    ) internal returns (uint256) {\n        /*\n         * Calculate the ZKT-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n         * cumulative error low in the running total G:\n         *\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint256 ZKTNumerator = _ZKTIssuance.mul(DECIMAL_PRECISION).add(\n            lastZKTError\n        );\n\n        uint256 ZKTPerUnitStaked = ZKTNumerator.div(_totalZKUSDDeposits);\n        lastZKTError = ZKTNumerator.sub(\n            ZKTPerUnitStaked.mul(_totalZKUSDDeposits)\n        );\n\n        return ZKTPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n     * Cancels out the specified debt against the ZKUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's NEON collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(\n        uint256 _debtToOffset,\n        uint256 _collToAdd\n    ) external override {\n        _requireCallerIsTroveManager();\n        uint256 totalZKUSD = totalZKUSDDeposits; // cached to save an SLOAD\n        if (totalZKUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerZKTIssuance(communityIssuance);\n\n        (\n            uint256 NEONGainPerUnitStaked,\n            uint256 ZKUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalZKUSD);\n\n        _updateRewardSumAndProduct(\n            NEONGainPerUnitStaked,\n            ZKUSDLossPerUnitStaked\n        ); // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint256 _collToAdd,\n        uint256 _debtToOffset,\n        uint256 _totalZKUSDDeposits\n    )\n        internal\n        returns (uint256 NEONGainPerUnitStaked, uint256 ZKUSDLossPerUnitStaked)\n    {\n        /*\n         * Compute the ZKUSD and NEON rewards. Uses a \"feedback\" error correction, to keep\n         * the cumulative error in the P and S state variables low:\n         *\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store these errors for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint256 NEONNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(\n            lastNEONError_Offset\n        );\n\n        assert(_debtToOffset <= _totalZKUSDDeposits);\n        if (_debtToOffset == _totalZKUSDDeposits) {\n            ZKUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastZKUSDLossError_Offset = 0;\n        } else {\n            uint256 ZKUSDLossNumerator = _debtToOffset\n                .mul(DECIMAL_PRECISION)\n                .sub(lastZKUSDLossError_Offset);\n            /*\n             * Add 1 to make error in quotient positive. We want \"slightly too much\" ZKUSD loss,\n             * which ensures the error in any given compoundedZKUSDDeposit favors the Stability Pool.\n             */\n            ZKUSDLossPerUnitStaked = (\n                ZKUSDLossNumerator.div(_totalZKUSDDeposits)\n            ).add(1);\n            lastZKUSDLossError_Offset = (\n                ZKUSDLossPerUnitStaked.mul(_totalZKUSDDeposits)\n            ).sub(ZKUSDLossNumerator);\n        }\n\n        NEONGainPerUnitStaked = NEONNumerator.div(_totalZKUSDDeposits);\n        lastNEONError_Offset = NEONNumerator.sub(\n            NEONGainPerUnitStaked.mul(_totalZKUSDDeposits)\n        );\n\n        return (NEONGainPerUnitStaked, ZKUSDLossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        uint256 _NEONGainPerUnitStaked,\n        uint256 _ZKUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        assert(_ZKUSDLossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool ZKUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - ZKUSDLossPerUnitStaked)\n         */\n        uint256 newProductFactor = uint(DECIMAL_PRECISION).sub(\n            _ZKUSDLossPerUnitStaked\n        );\n\n        uint256 currentScaleCached = currentScale;\n        uint256 currentEpochCached = currentEpoch;\n        uint256 currentS = epochToScaleToSum[currentEpochCached][\n            currentScaleCached\n        ];\n\n        /*\n         * Calculate the new S first, before we update P.\n         * The NEON gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         *\n         * Since S corresponds to NEON gain, and P to deposit loss, we update S first.\n         */\n        uint256 marginalNEONGain = _NEONGainPerUnitStaked.mul(currentP);\n        uint256 newS = currentS.add(marginalNEONGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (\n            currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR\n        ) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(\n                DECIMAL_PRECISION\n            );\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(\n        uint256 _collToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n\n        // Cancel the liquidated ZKUSD debt with the ZKUSD in the stability pool\n        activePoolCached.decreaseZKUSDDebt(_debtToOffset);\n        _decreaseZKUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        zkusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendNEON(address(this), _collToAdd);\n    }\n\n    function _decreaseZKUSD(uint256 _amount) internal {\n        uint256 newTotalZKUSDDeposits = totalZKUSDDeposits.sub(_amount);\n        totalZKUSDDeposits = newTotalZKUSDDeposits;\n        emit StabilityPoolZKUSDBalanceUpdated(newTotalZKUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the NEON gain earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     */\n    function getDepositorNEONGain(\n        address _depositor\n    ) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor];\n\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 NEONGain = _getNEONGainFromSnapshots(initialDeposit, snapshots);\n        return NEONGain;\n    }\n\n    function _getNEONGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots memory snapshots\n    ) internal view returns (uint256) {\n        /*\n         * Grab the sum 'S' from the epoch at which the stake was made. The NEON gain may span up to one scale change.\n         * If it does, the second portion of the NEON gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint256 epochSnapshot = snapshots.epoch;\n        uint256 scaleSnapshot = snapshots.scale;\n        uint256 S_Snapshot = snapshots.S;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot]\n            .sub(S_Snapshot);\n        uint256 secondPortion = epochToScaleToSum[epochSnapshot][\n            scaleSnapshot.add(1)\n        ].div(SCALE_FACTOR);\n\n        uint256 NEONGain = initialDeposit\n            .mul(firstPortion.add(secondPortion))\n            .div(P_Snapshot)\n            .div(DECIMAL_PRECISION);\n\n        return NEONGain;\n    }\n\n    /*\n     * Calculate the ZKT gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  ZKT = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     */\n    function getDepositorZKTGain(\n        address _depositor\n    ) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor];\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 ZKTGain = DefaultKickbackRate\n            .mul(_getZKTGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return ZKTGain;\n    }\n\n    /*\n     * Return the ZKT gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     *\n     * D0 is the last recorded value of the front end's total tagged deposits.\n     */\n    function getFrontEndZKTGain(\n        address _frontEnd\n    ) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(\n            DefaultKickbackRate\n        );\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 ZKTGain = frontEndShare\n            .mul(_getZKTGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return ZKTGain;\n    }\n\n    function _getZKTGainFromSnapshots(\n        uint256 initialStake,\n        Snapshots memory snapshots\n    ) internal view returns (uint256) {\n        /*\n         * Grab the sum 'G' from the epoch at which the stake was made. The ZKT gain may span up to one scale change.\n         * If it does, the second portion of the ZKT gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint256 epochSnapshot = snapshots.epoch;\n        uint256 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot]\n            .sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][\n            scaleSnapshot.add(1)\n        ].div(SCALE_FACTOR);\n\n        uint256 ZKTGain = initialStake\n            .mul(firstPortion.add(secondPortion))\n            .div(P_Snapshot)\n            .div(DECIMAL_PRECISION);\n\n        return ZKTGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n     */\n    function getCompoundedZKUSDDeposit(\n        address _depositor\n    ) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor];\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(\n            initialDeposit,\n            snapshots\n        );\n        return compoundedDeposit;\n    }\n\n    /*\n     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken at the last time\n     * when one of the front end's tagged deposits updated their deposit.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(\n        address _frontEnd\n    ) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(\n            frontEndStake,\n            snapshots\n        );\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint256 initialStake,\n        Snapshots memory snapshots\n    ) internal view returns (uint256) {\n        uint256 snapshot_P = snapshots.P;\n        uint256 scaleSnapshot = snapshots.scale;\n        uint256 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint256 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(\n                SCALE_FACTOR\n            );\n        } else {\n            // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         *\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n         * than it's theoretical value.\n         *\n         * Thus it's unclear whNEONer this line is still really needed.\n         */\n        if (compoundedStake < initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for ZKUSD deposit, NEON gains and ZKT gains ---\n\n    // Transfer the ZKUSD tokens from the user to the Stability Pool's address, and update its recorded ZKUSD\n    function _sendZKUSDtoStabilityPool(\n        address _address,\n        uint256 _amount\n    ) internal {\n        zkusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalZKUSDDeposits = totalZKUSDDeposits.add(_amount);\n        totalZKUSDDeposits = newTotalZKUSDDeposits;\n        emit StabilityPoolZKUSDBalanceUpdated(newTotalZKUSDDeposits);\n    }\n\n    function _sendNEONGainToDepositor(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n        uint256 newNEON = NEON.sub(_amount);\n        NEON = newNEON;\n        emit StabilityPoolNEONBalanceUpdated(newNEON);\n        emit NeonSent(msg.sender, _amount);\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"StabilityPool: sending NEON failed\");\n    }\n\n    // Send ZKUSD to user and decrease ZKUSD in Pool\n    function _sendZKUSDToDepositor(\n        address _depositor,\n        uint256 ZKUSDWithdrawal\n    ) internal {\n        if (ZKUSDWithdrawal == 0) {\n            return;\n        }\n\n        zkusdToken.returnFromPool(address(this), _depositor, ZKUSDWithdrawal);\n        _decreaseZKUSD(ZKUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    function _updateDepositAndSnapshots(\n        address _depositor,\n        uint256 _newValue\n    ) internal {\n        deposits[_depositor] = _newValue;\n\n        if (_newValue == 0) {\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint256 currentScaleCached = currentScale;\n        uint256 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint256 currentS = epochToScaleToSum[currentEpochCached][\n            currentScaleCached\n        ];\n        uint256 currentG = epochToScaleToG[currentEpochCached][\n            currentScaleCached\n        ];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(\n        address _frontEnd,\n        uint256 _newValue\n    ) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint256 currentScaleCached = currentScale;\n        uint256 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][\n            currentScaleCached\n        ];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutZKTGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor\n    ) internal {\n        // Pay out front end's ZKT gain\n        uint256 frontEndZKTGain = getFrontEndZKTGain(_depositor);\n        _communityIssuance.sendZKT(treasury, frontEndZKTGain);\n        emit ZKTPaidToFrontEnd(treasury, frontEndZKTGain);\n\n        // Pay out depositor's ZKT gain\n        uint256 depositorZKTGain = getDepositorZKTGain(_depositor);\n        _communityIssuance.sendZKT(_depositor, depositorZKTGain);\n        emit ZKTPaidToDepositor(_depositor, depositorZKTGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == address(activePool),\n            \"StabilityPool: Caller is not ActivePool\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"StabilityPool: Caller is not TroveManager\"\n        );\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint256 price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(\n            ICR >= MCR,\n            \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\"\n        );\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(\n            _initialDeposit > 0,\n            \"StabilityPool: User must have a non-zero deposit\"\n        );\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address];\n        require(\n            initialDeposit == 0,\n            \"StabilityPool: User must have no deposit\"\n        );\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(\n            troveManager.getTroveStatus(_depositor) == 1,\n            \"StabilityPool: caller must have an active trove to withdraw NEONGain to\"\n        );\n    }\n\n    function _requireUserHasNEONGain(address _depositor) internal view {\n        uint256 NEONGain = getDepositorNEONGain(_depositor);\n        require(\n            NEONGain > 0,\n            \"StabilityPool: caller must have non-zero NEON Gain\"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate <= DECIMAL_PRECISION,\n            \"StabilityPool: Kickback rate must be in range [0,1]\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        NEON = NEON.add(msg.value);\n        emit StabilityPoolNEONBalanceUpdated(NEON);\n    }\n}\n"
    },
    "contracts/protocol/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../interfaces/IZKTStaking.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\nimport \"../dependencies/ZKTProtocolBase.sol\";\n\ncontract TroveManager is\n    ITroveManager,\n    ZKTProtocolBase,\n    CheckContract,\n    Ownable\n{\n    using SafeMath for uint256;\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public override stabilityPool;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IZKUSDToken public override zkusdToken;\n\n    IZKToken public override zkToken;\n\n    IZKTStaking public override zktStaking;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint256 public constant MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint256 public constant REDEMPTION_FEE_FLOOR =\n        (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n    uint256 public constant MAX_BORROWING_FEE = (DECIMAL_PRECISION / 100) * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint256 public constant BOOTSTRAP_PERIOD = 14 days;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the white paper.\n     */\n    uint256 public constant BETA = 2;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new ZKUSD issuance)\n    uint256 public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint256 arrayIndex;\n    }\n\n    mapping(address => Trove) public Troves;\n\n    uint256 public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 public totalCollateralSnapshot;\n\n    /*\n     * L_NEON and L_ZKUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n     *\n     * A NEON gain of ( stake * [L_NEON - L_NEON(0)] )\n     * A ZKUSDDebt increase  of ( stake * [L_ZKUSDDebt - L_ZKUSDDebt(0)] )\n     *\n     * Where L_NEON(0) and L_ZKUSDDebt(0) are snapshots of L_NEON and L_ZKUSDDebt for the active Trove taken at the instant the stake was made\n     */\n    uint256 public L_NEON;\n    uint256 public L_ZKUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping(address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the NEON and ZKUSD snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 NEON;\n        uint256 ZKUSDDebt;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 public lastNEONError_Redistribution;\n    uint256 public lastZKUSDDebtError_Redistribution;\n\n    /*\n     * --- Variable container structs for liquidations ---\n     *\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\n     **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 price;\n        uint256 ZKUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n        uint256 liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint256 collToLiquidate;\n        uint256 pendingDebtReward;\n        uint256 pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingZKUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        uint256 entireTroveColl;\n        uint256 collGasCompensation;\n        uint256 ZKUSDGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalCollInSequence;\n        uint256 totalDebtInSequence;\n        uint256 totalCollGasCompensation;\n        uint256 totalZKUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        uint256 totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        uint256 totalCollToRedistribute;\n        uint256 totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        IZKUSDToken zkusdToken;\n        IZKTStaking zktStaking;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n        address gasPoolAddress;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint256 remainingZKUSD;\n        uint256 totalZKUSDToRedeem;\n        uint256 totalNEONDrawn;\n        uint256 NEONFee;\n        uint256 NEONToSendToRedeemer;\n        uint256 decayedBaseRate;\n        uint256 price;\n        uint256 totalZKUSDSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 ZKUSDLot;\n        uint256 NEONLot;\n        bool cancelledPartial;\n    }\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _zkTokenAddress,\n        address _zktStakingAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_zkusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_zkTokenAddress);\n        checkContract(_zktStakingAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        zkToken = IZKToken(_zkTokenAddress);\n        zktStaking = IZKTStaking(_zktStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit ZKUSDTokenAddressChanged(_zkusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit ZKTokenAddressChanged(_zkTokenAddress);\n        emit ZKTStakingAddressChanged(_zktStakingAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint256) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(\n        uint256 _index\n    ) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ZKUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        );\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n        uint256 collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute\n        ) = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            collToLiquidate,\n            _ZKUSDInStabPool\n        );\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            Operation.liquidateInNormalMode\n        );\n        emit TroveUpdated(_borrower, 0, 0, 0, Operation.liquidateInNormalMode);\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _ZKUSDInStabPool,\n        uint256 _TCR,\n        uint256 _price\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {\n            return singleLiquidation;\n        } // don't liquidate if last trove\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation\n                .entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n\n            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            (\n                singleLiquidation.debtToOffset,\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.debtToRedistribute,\n                singleLiquidation.collToRedistribute\n            ) = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _ZKUSDInStabPool\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n            /*\n             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is ZKUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             */\n        } else if (\n            (_ICR >= MCR) &&\n            (_ICR < _TCR) &&\n            (singleLiquidation.entireTroveDebt <= _ZKUSDInStabPool)\n        ) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            assert(_ZKUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                _price\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(\n                    _borrower,\n                    singleLiquidation.collSurplus\n                );\n            }\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.collToSendToSP,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _ZKUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves.\n     */\n    function _getOffsetAndRedistributionVals(\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _ZKUSDInStabPool\n    )\n        internal\n        pure\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute\n        )\n    {\n        if (_ZKUSDInStabPool > 0) {\n            /*\n             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             *\n             *  If the trove's debt is larger than the deposited ZKUSD in the Stability Pool:\n             *\n             *  - Offset an amount of the trove's debt equal to the ZKUSD in the Stability Pool\n             *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n             *\n             */\n            debtToOffset = Math.min(_debt, _ZKUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n     *  Get its offset coll/debt and NEON gas comp, and close the trove.\n     */\n    function _getCappedOffsetVals(\n        uint256 _entireTroveDebt,\n        uint256 _entireTroveColl,\n        uint256 _price\n    ) internal pure returns (LiquidationValues memory singleLiquidation) {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint256 cappedCollPortion = _entireTroveDebt.mul(MCR).div(_price);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            cappedCollPortion\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(\n            singleLiquidation.collGasCompensation\n        );\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n     * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards\n     */\n    function liquidateTroves(uint256 _n) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            IZKUSDToken(address(0)),\n            IZKTStaking(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0)),\n            address(0)\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.ZKUSDInStabPool = stabilityPoolCached.getTotalZKUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n                contractsCache,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _n\n            );\n        } else {\n            // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _n\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated NEON and ZKUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            contractsCache.activePool,\n            contractsCache.defaultPool,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendNEON(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            contractsCache.activePool,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalZKUSDGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            contractsCache.activePool,\n            msg.sender,\n            totals.totalZKUSDGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n        ContractsCache memory _contractsCache,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        uint256 _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingZKUSDInStabPool == 0) {\n                    break;\n                }\n\n                uint256 TCR = FullMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingZKUSDInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        uint256 _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(\n        address[] memory _troveArray\n    ) public override {\n        require(\n            _troveArray.length != 0,\n            \"TroveManager: Calldata address array must not be empty\"\n        );\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.ZKUSDInStabPool = stabilityPoolCached.getTotalZKUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated NEON and ZKUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendNEON(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalZKUSDGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            msg.sender,\n            totals.totalZKUSDGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) {\n                continue;\n            }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingZKUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = FullMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingZKUSDInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals\n            .totalCollGasCompensation\n            .add(singleLiquidation.collGasCompensation);\n        newTotals.totalZKUSDGasCompensation = oldTotals\n            .totalZKUSDGasCompensation\n            .add(singleLiquidation.ZKUSDGasCompensation);\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(\n            singleLiquidation.entireTroveColl\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals\n            .totalDebtToRedistribute\n            .add(singleLiquidation.debtToRedistribute);\n        newTotals.totalCollToRedistribute = oldTotals\n            .totalCollToRedistribute\n            .add(singleLiquidation.collToRedistribute);\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(\n            singleLiquidation.collSurplus\n        );\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        if (_ZKUSD > 0) {\n            zkusdToken.returnFromPool(gasPoolAddress, _liquidator, _ZKUSD);\n        }\n\n        if (_NEON > 0) {\n            _activePool.sendNEON(_liquidator, _NEON);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        _defaultPool.decreaseZKUSDDebt(_ZKUSD);\n        _activePool.increaseZKUSDDebt(_ZKUSD);\n        _defaultPool.sendNEONToActivePool(_NEON);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for ZKUSD up to _maxZKUSDamount\n    function _redeemCollateralFromTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint256 _maxZKUSDamount,\n        uint256 _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.ZKUSDLot = Math.min(\n            _maxZKUSDamount,\n            Troves[_borrower].debt.sub(ZKUSD_GAS_COMPENSATION)\n        );\n\n        // Get the NEONLot of equivalent value in USD\n        singleRedemption.NEONLot = singleRedemption\n            .ZKUSDLot\n            .mul(DECIMAL_PRECISION)\n            .div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the ZKUSD lot and corresponding NEON to send\n        uint256 newDebt = (Troves[_borrower].debt).sub(\n            singleRedemption.ZKUSDLot\n        );\n        uint256 newColl = (Troves[_borrower].coll).sub(singleRedemption.NEONLot);\n\n        if (newDebt == ZKUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(\n                _contractsCache,\n                _borrower,\n                ZKUSD_GAS_COMPENSATION,\n                newColl\n            );\n            emit TroveUpdated(_borrower, 0, 0, 0, Operation.redeemCollateral);\n        } else {\n            uint256 newNICR = FullMath._computeNominalCR(newColl, newDebt);\n\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n             */\n            if (\n                newNICR != _partialRedemptionHintNICR ||\n                _getNetDebt(newDebt) < MIN_NET_DEBT\n            ) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            _contractsCache.sortedTroves.reInsert(\n                _borrower,\n                newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                newDebt,\n                newColl,\n                Troves[_borrower].stake,\n                Operation.redeemCollateral\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n     * Called when a full redemption occurs, and closes the trove.\n     * The redeemer swaps (debt - liquidation reserve) ZKUSD for (debt - liquidation reserve) worth of NEON, so the ZKUSD liquidation reserve left corresponds to the remaining debt.\n     * In order to close the trove, the ZKUSD liquidation reserve is burned, and the corresponding debt is removed from the active pool.\n     * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n     * Any surplus NEON left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n     */\n    function _redeemCloseTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        _contractsCache.zkusdToken.burn(gasPoolAddress, _ZKUSD);\n        // Update Active Pool ZKUSD, and send NEON to account\n        _contractsCache.activePool.decreaseZKUSDDebt(_ZKUSD);\n\n        // send NEON from Active Pool to CollSurplus Pool\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _NEON);\n        _contractsCache.activePool.sendNEON(\n            address(_contractsCache.collSurplusPool),\n            _NEON\n        );\n    }\n\n    function _isValidFirstRedemptionHint(\n        ISortedTroves _sortedTroves,\n        address _firstRedemptionHint,\n        uint256 _price\n    ) internal view returns (bool) {\n        if (\n            _firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n        return\n            nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _ZKUSDamount ZKUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n     * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n     *\n     * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n     * splitting the total _amount in appropriate chunks and calling the function multiple times.\n     *\n     * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n     * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n     * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n     * costs can vary.\n     *\n     * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n     * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n     * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n     * in the sortedTroves list along with the ICR value that the hint was found for.\n     *\n     * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n     * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n     * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining ZKUSD amount, which they can attempt\n     * to redeem later.\n     */\n    function redeemCollateral(\n        uint256 _ZKUSDamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            zkusdToken,\n            zktStaking,\n            sortedTroves,\n            collSurplusPool,\n            gasPoolAddress\n        );\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice();\n        _requireTCRoverMCR(totals.price);\n        _requireAmountGreaterThanZero(_ZKUSDamount);\n        _requireZKUSDBalanceCoversRedemption(\n            contractsCache.zkusdToken,\n            msg.sender,\n            _ZKUSDamount\n        );\n\n        totals.totalZKUSDSupplyAtStart = getEntireSystemDebt();\n        // Confirm redeemer's balance is less than total ZKUSD supply\n        assert(\n            contractsCache.zkusdToken.balanceOf(msg.sender) <=\n                totals.totalZKUSDSupplyAtStart\n        );\n\n        totals.remainingZKUSD = _ZKUSDamount;\n        address currentBorrower;\n\n        if (\n            _isValidFirstRedemptionHint(\n                contractsCache.sortedTroves,\n                _firstRedemptionHint,\n                totals.price\n            )\n        ) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = contractsCache.sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (\n                currentBorrower != address(0) &&\n                getCurrentICR(currentBorrower, totals.price) < MCR\n            ) {\n                currentBorrower = contractsCache.sortedTroves.getPrev(\n                    currentBorrower\n                );\n            }\n        }\n\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of ZKUSD is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n        while (\n            currentBorrower != address(0) &&\n            totals.remainingZKUSD > 0 &&\n            _maxIterations > 0\n        ) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(\n                currentBorrower\n            );\n\n            _applyPendingRewards(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                currentBorrower\n            );\n\n            SingleRedemptionValues\n                memory singleRedemption = _redeemCollateralFromTrove(\n                    contractsCache,\n                    currentBorrower,\n                    totals.remainingZKUSD,\n                    totals.price,\n                    _upperPartialRedemptionHint,\n                    _lowerPartialRedemptionHint,\n                    _partialRedemptionHintNICR\n                );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalZKUSDToRedeem = totals.totalZKUSDToRedeem.add(\n                singleRedemption.ZKUSDLot\n            );\n            totals.totalNEONDrawn = totals.totalNEONDrawn.add(\n                singleRedemption.NEONLot\n            );\n\n            totals.remainingZKUSD = totals.remainingZKUSD.sub(\n                singleRedemption.ZKUSDLot\n            );\n            currentBorrower = nextUserToCheck;\n        }\n        require(\n            totals.totalNEONDrawn > 0,\n            \"TroveManager: Unable to redeem any amount\"\n        );\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total ZKUSD supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(\n            totals.totalNEONDrawn,\n            totals.price,\n            totals.totalZKUSDSupplyAtStart\n        );\n\n        // Calculate the NEON fee\n        totals.NEONFee = _getRedemptionFee(totals.totalNEONDrawn);\n\n        _requireUserAcceptsFee(\n            totals.NEONFee,\n            totals.totalNEONDrawn,\n            _maxFeePercentage\n        );\n\n        // Send the NEON fee to the ZKT staking contract\n        contractsCache.activePool.sendNEON(\n            address(contractsCache.zktStaking),\n            totals.NEONFee\n        );\n        contractsCache.zktStaking.increaseF_NEON(totals.NEONFee);\n\n        totals.NEONToSendToRedeemer = totals.totalNEONDrawn.sub(totals.NEONFee);\n\n        emit Redemption(\n            _ZKUSDamount,\n            totals.totalZKUSDToRedeem,\n            totals.totalNEONDrawn,\n            totals.NEONFee\n        );\n\n        // Burn the total ZKUSD that is cancelled with debt, and send the redeemed NEON to msg.sender\n        contractsCache.zkusdToken.burn(msg.sender, totals.totalZKUSDToRedeem);\n        // Update Active Pool ZKUSD, and send NEON to account\n        contractsCache.activePool.decreaseZKUSDDebt(totals.totalZKUSDToRedeem);\n        contractsCache.activePool.sendNEON(\n            msg.sender,\n            totals.NEONToSendToRedeemer\n        );\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(\n        address _borrower\n    ) public view override returns (uint256) {\n        (\n            uint256 currentNEON,\n            uint256 currentZKUSDDebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint256 NICR = FullMath._computeNominalCR(currentNEON, currentZKUSDDebt);\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(\n        address _borrower,\n        uint256 _price\n    ) public view override returns (uint256) {\n        (\n            uint256 currentNEON,\n            uint256 currentZKUSDDebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint256 ICR = FullMath._computeCR(currentNEON, currentZKUSDDebt, _price);\n        return ICR;\n    }\n\n    function _getCurrentTroveAmounts(\n        address _borrower\n    ) internal view returns (uint256, uint256) {\n        uint256 pendingNEONReward = getPendingNEONReward(_borrower);\n        uint256 pendingZKUSDDebtReward = getPendingZKUSDDebtReward(_borrower);\n\n        uint256 currentNEON = Troves[_borrower].coll.add(pendingNEONReward);\n        uint256 currentZKUSDDebt = Troves[_borrower].debt.add(\n            pendingZKUSDDebtReward\n        );\n\n        return (currentNEON, currentZKUSDDebt);\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower\n    ) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending rewards\n            uint256 pendingNEONReward = getPendingNEONReward(_borrower);\n            uint256 pendingZKUSDDebtReward = getPendingZKUSDDebtReward(\n                _borrower\n            );\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(\n                pendingNEONReward\n            );\n            Troves[_borrower].debt = Troves[_borrower].debt.add(\n                pendingZKUSDDebtReward\n            );\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                pendingZKUSDDebtReward,\n                pendingNEONReward\n            );\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].coll,\n                Troves[_borrower].stake,\n                Operation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_NEON and L_ZKUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].NEON = L_NEON;\n        rewardSnapshots[_borrower].ZKUSDDebt = L_ZKUSDDebt;\n        emit TroveSnapshotsUpdated(L_NEON, L_ZKUSDDebt);\n    }\n\n    // Get the borrower's pending accumulated NEON reward, earned by their stake\n    function getPendingNEONReward(\n        address _borrower\n    ) public view override returns (uint256) {\n        uint256 snapshotNEON = rewardSnapshots[_borrower].NEON;\n        uint256 rewardPerUnitStaked = L_NEON.sub(snapshotNEON);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint256 stake = Troves[_borrower].stake;\n\n        uint256 pendingNEONReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingNEONReward;\n    }\n\n    // Get the borrower's pending accumulated ZKUSD reward, earned by their stake\n    function getPendingZKUSDDebtReward(\n        address _borrower\n    ) public view override returns (uint256) {\n        uint256 snapshotZKUSDDebt = rewardSnapshots[_borrower].ZKUSDDebt;\n        uint256 rewardPerUnitStaked = L_ZKUSDDebt.sub(snapshotZKUSDDebt);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint256 stake = Troves[_borrower].stake;\n\n        uint256 pendingZKUSDDebtReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingZKUSDDebtReward;\n    }\n\n    function hasPendingRewards(\n        address _borrower\n    ) public view override returns (bool) {\n        /*\n         * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n         * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n         * pending rewards\n         */\n        if (Troves[_borrower].status != Status.active) {\n            return false;\n        }\n\n        return (rewardSnapshots[_borrower].NEON < L_NEON);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 pendingZKUSDDebtReward,\n            uint256 pendingNEONReward\n        )\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingZKUSDDebtReward = getPendingZKUSDDebtReward(_borrower);\n        pendingNEONReward = getPendingNEONReward(_borrower);\n\n        debt = debt.add(pendingZKUSDDebtReward);\n        coll = coll.add(pendingNEONReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint256 stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(\n        address _borrower\n    ) internal returns (uint256) {\n        uint256 newStake = _computeNewStake(Troves[_borrower].coll);\n        uint256 oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n        emit TotalStakesUpdated(totalStakes);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n             * The following assert() holds true because:\n             * - The system always contains >= 1 trove\n             * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n             * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debt,\n        uint256 _coll\n    ) internal {\n        if (_debt == 0) {\n            return;\n        }\n\n        /*\n         * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n         * error correction, to keep the cumulative error low in the running totals L_NEON and L_ZKUSDDebt:\n         *\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store these errors for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint256 NEONNumerator = _coll.mul(DECIMAL_PRECISION).add(\n            lastNEONError_Redistribution\n        );\n        uint256 ZKUSDDebtNumerator = _debt.mul(DECIMAL_PRECISION).add(\n            lastZKUSDDebtError_Redistribution\n        );\n\n        // Get the per-unit-staked terms\n        uint256 NEONRewardPerUnitStaked = NEONNumerator.div(totalStakes);\n        uint256 ZKUSDDebtRewardPerUnitStaked = ZKUSDDebtNumerator.div(\n            totalStakes\n        );\n\n        lastNEONError_Redistribution = NEONNumerator.sub(\n            NEONRewardPerUnitStaked.mul(totalStakes)\n        );\n        lastZKUSDDebtError_Redistribution = ZKUSDDebtNumerator.sub(\n            ZKUSDDebtRewardPerUnitStaked.mul(totalStakes)\n        );\n\n        // Add per-unit-staked terms to the running totals\n        L_NEON = L_NEON.add(NEONRewardPerUnitStaked);\n        L_ZKUSDDebt = L_ZKUSDDebt.add(ZKUSDDebtRewardPerUnitStaked);\n\n        emit LTermsUpdated(L_NEON, L_ZKUSDDebt);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseZKUSDDebt(_debt);\n        _defaultPool.increaseZKUSDDebt(_debt);\n        _activePool.sendNEON(address(_defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        assert(\n            closedStatus != Status.nonExistent && closedStatus != Status.active\n        );\n\n        uint256 TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].NEON = 0;\n        rewardSnapshots[_borrower].ZKUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /*\n     * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n     * Used in a liquidation sequence.\n     *\n     * The calculation excludes a portion of collateral that is in the ActivePool:\n     *\n     * the total NEON gas compensation from the liquidation sequence\n     *\n     * The NEON as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n     */\n    function _updateSystemSnapshots_excludeCollRemainder(\n        IActivePool _activePool,\n        uint256 _collRemainder\n    ) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getNEON();\n        uint256 liquidatedColl = defaultPool.getNEON();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(\n            liquidatedColl\n        );\n\n        emit SystemSnapshotsUpdated(\n            totalStakesSnapshot,\n            totalCollateralSnapshot\n        );\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external override returns (uint256 index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(\n        address _borrower\n    ) internal returns (uint256 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum ZKUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 ZKUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = TroveOwners.length.sub(1);\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /*\n     * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n     * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n     */\n    function _removeTroveOwner(\n        address _borrower,\n        uint256 TroveOwnersArrayLength\n    ) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function `_closeTrove`\n        assert(\n            troveStatus != Status.nonExistent && troveStatus != Status.active\n        );\n\n        uint256 index = Troves[_borrower].arrayIndex;\n        uint256 length = TroveOwnersArrayLength;\n        uint256 idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR(uint256 _price) external view override returns (uint256) {\n        return _getTCR(_price);\n    }\n\n    function checkRecoveryMode(\n        uint256 _price\n    ) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given a NEON:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint256 _entireSystemColl,\n        uint256 _entireSystemDebt,\n        uint256 _price\n    ) internal pure returns (bool) {\n        uint256 TCR = FullMath._computeCR(\n            _entireSystemColl,\n            _entireSystemDebt,\n            _price\n        );\n\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or ZKUSD borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint _NEONDrawn,\n        uint _price,\n        uint _totalZKUSDSupply\n    ) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn NEON back to ZKUSD at face value rate (1 ZKUSD:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint redeemedZKUSDFraction = _NEONDrawn.mul(_price).div(\n            _totalZKUSDSupply\n        );\n\n        uint newBaseRate = decayedBaseRate.add(redeemedZKUSDFraction.div(BETA));\n        newBaseRate = Math.min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return\n            Math.min(\n                REDEMPTION_FEE_FLOOR.add(_baseRate),\n                DECIMAL_PRECISION // cap at a maximum of 100%\n            );\n    }\n\n    function _getRedemptionFee(uint _NEONDrawn) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _NEONDrawn);\n    }\n\n    function getRedemptionFeeWithDecay(\n        uint _NEONDrawn\n    ) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _NEONDrawn);\n    }\n\n    function _calcRedemptionFee(\n        uint _redemptionRate,\n        uint _NEONDrawn\n    ) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_NEONDrawn).div(\n            DECIMAL_PRECISION\n        );\n        require(\n            redemptionFee < _NEONDrawn,\n            \"TroveManager: Fee would eat up all returned collateral\"\n        );\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return Math.min(BORROWING_FEE_FLOOR.add(_baseRate), MAX_BORROWING_FEE);\n    }\n\n    function getBorrowingFee(\n        uint _ZKUSDDebt\n    ) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _ZKUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(\n        uint _ZKUSDDebt\n    ) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _ZKUSDDebt);\n    }\n\n    function _calcBorrowingFee(\n        uint _borrowingRate,\n        uint _ZKUSDDebt\n    ) internal pure returns (uint) {\n        return _borrowingRate.mul(_ZKUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or ZKUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION); // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = FullMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return\n            (block.timestamp.sub(lastFeeOperationTime)).div(\n                SECONDS_IN_ONE_MINUTE\n            );\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"TroveManager: Caller is not the BorrowerOperations contract\"\n        );\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(\n            Troves[_borrower].status == Status.active,\n            \"TroveManager: Trove does not exist or is closed\"\n        );\n    }\n\n    function _requireZKUSDBalanceCoversRedemption(\n        IZKUSDToken _zkusdToken,\n        address _redeemer,\n        uint _amount\n    ) internal view {\n        require(\n            _zkusdToken.balanceOf(_redeemer) >= _amount,\n            \"TroveManager: Requested redemption amount must be <= user's ZKUSD token balance\"\n        );\n    }\n\n    function _requireMoreThanOneTroveInSystem(\n        uint TroveOwnersArrayLength\n    ) internal view {\n        require(\n            TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1,\n            \"TroveManager: Only one trove in the system\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    function _requireTCRoverMCR(uint _price) internal view {\n        require(\n            _getTCR(_price) >= MCR,\n            \"TroveManager: Cannot redeem when TCR < MCR\"\n        );\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = zkToken.getDeploymentStartTime();\n        require(\n            block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD),\n            \"TroveManager: Redemptions are not allowed during bootstrap phase\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint _maxFeePercentage\n    ) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR &&\n                _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(\n        address _borrower\n    ) external view override returns (uint256) {\n        return uint256(Troves[_borrower].status);\n    }\n\n    function getTroveStake(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint256 _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(\n        address _borrower,\n        uint256 _collIncrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint256 _collDecrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint256 _debtIncrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint256 _debtDecrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "contracts/rewards/Unipool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../dependencies/CheckContract.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../interfaces/ILPTokenWrapper.sol\";\nimport \"../interfaces/IUnipool.sol\";\n\n// Adapted from: https://github.com/Synthetixio/Unipool/blob/master/contracts/Unipool.sol\n// Some more useful references:\n// Synthetix proposal: https://sips.synthetix.io/sips/sip-31\n// Original audit: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf\n// Incremental changes (commit by commit) from the original to this version: https://github.com/liquity/dev/pull/271\n\n// LPTokenWrapper contains the basic staking functionality\ncontract LPTokenWrapper is ILPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public uniToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual override {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        uniToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual override {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        uniToken.safeTransfer(msg.sender, amount);\n    }\n}\n\n/*\n * On deployment a new Uniswap pool will be created for the pair ZKUSD/NEON and its token will be set here.\n\n * Essentially the way it works is:\n\n * - Liquidity providers add funds to the Uniswap pool, and get UNIv2 LP tokens in exchange\n * - Liquidity providers stake those UNIv2 LP tokens into Unipool rewards contract\n * - Liquidity providers accrue rewards, proportional to the amount of staked tokens and staking time\n * - Liquidity providers can claim their rewards when they want\n * - Liquidity providers can unstake UNIv2 LP tokens to exit the program (i.e., stop earning rewards) when they want\n\n * Funds for rewards will only be added once, on deployment of ZKT token,\n * which will happen after this contract is deployed and before this `setParams` in this contract is called.\n\n * If at some point the total amount of staked tokens is zero, the clock will be “stopped”,\n * so the period will be extended by the time during which the staking pool is empty,\n * in order to avoid getting ZKT tokens locked.\n * That also means that the start time for the program will be the event that occurs first:\n * either ZKT token contract is deployed, and therefore ZKT tokens are minted to Unipool contract,\n * or first liquidity provider stakes UNIv2 LP tokens into it.\n */\ncontract Unipool is LPTokenWrapper, Ownable, CheckContract, IUnipool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Unipool\";\n\n    uint256 public duration;\n    IZKToken public zkToken;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event ZKTokenAddressChanged(address _zkTokenAddress);\n    event UniTokenAddressChanged(address _uniTokenAddress);\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    // initialization function\n    function setParams(\n        address _zkTokenAddress,\n        address _uniTokenAddress,\n        uint256 _duration\n    ) external override onlyOwner {\n        checkContract(_zkTokenAddress);\n        checkContract(_uniTokenAddress);\n\n        uniToken = IERC20(_uniTokenAddress);\n        zkToken = IZKToken(_zkTokenAddress);\n        duration = _duration;\n\n        _notifyRewardAmount(zkToken.getLpRewardsEntitlement(), _duration);\n\n        emit ZKTokenAddressChanged(_zkTokenAddress);\n        emit UniTokenAddressChanged(_uniTokenAddress);\n\n        // renounceOwnership();\n    }\n\n    // Returns current timestamp if the rewards program has not finished yet, end time otherwise\n    function lastTimeRewardApplicable() public view override returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    // Returns the amount of rewards that correspond to each staked token\n    function rewardPerToken() public view override returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    // Returns the amount that an account can claim\n    function earned(address account) public view override returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override {\n        require(amount > 0, \"Cannot stake 0\");\n        require(\n            address(uniToken) != address(0),\n            \"ZKTProtocol Pool Token has not been set yet\"\n        );\n\n        _updatePeriodFinish();\n        _updateAccountReward(msg.sender);\n\n        super.stake(amount);\n\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(\n            address(uniToken) != address(0),\n            \"ZKTProtocol Pool Token has not been set yet\"\n        );\n\n        _updateAccountReward(msg.sender);\n\n        super.withdraw(amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    // Shortcut to be able to unstake tokens and claim rewards in one transaction\n    function withdrawAndClaim() external override {\n        withdraw(balanceOf(msg.sender));\n        claimReward();\n    }\n\n    function claimReward() public override {\n        require(\n            address(uniToken) != address(0),\n            \"ZKTProtocol Pool Token has not been set yet\"\n        );\n\n        _updatePeriodFinish();\n        _updateAccountReward(msg.sender);\n\n        uint256 reward = earned(msg.sender);\n\n        require(reward > 0, \"Nothing to claim\");\n\n        rewards[msg.sender] = 0;\n        zkToken.transfer(msg.sender, reward);\n        emit RewardPaid(msg.sender, reward);\n    }\n\n    // Used only on initialization, sets the reward rate and the end time for the program\n    function _notifyRewardAmount(uint256 _reward, uint256 _duration) internal {\n        require(_reward > 0, \"reward need greater than zero\");\n        require(\n            _reward == zkToken.balanceOf(address(this)),\n            \"reward should be equal to zkToken balance of this\"\n        );\n        require(\n            periodFinish == 0,\n            \"periodFinish should not be initialize until now\"\n        );\n\n        _updateReward();\n\n        rewardRate = _reward.div(_duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(_duration);\n        emit RewardAdded(_reward);\n    }\n\n    // Adjusts end time for the program after periods of zero total supply\n    function _updatePeriodFinish() internal {\n        if (totalSupply() == 0) {\n            assert(periodFinish > 0);\n            /*\n             * If the finish period has been reached (but there are remaining rewards due to zero stake),\n             * to get the new finish date we must add to the current timestamp the difference between\n             * the original finish time and the last update, i.e.:\n             *\n             * periodFinish = block.timestamp.add(periodFinish.sub(lastUpdateTime));\n             *\n             * If we have not reached the end yet, we must extend it by adding to it the difference between\n             * the current timestamp and the last update (the period where the supply has been empty), i.e.:\n             *\n             * periodFinish = periodFinish.add(block.timestamp.sub(lastUpdateTime));\n             *\n             * Both formulas are equivalent.\n             */\n            periodFinish = periodFinish.add(\n                block.timestamp.sub(lastUpdateTime)\n            );\n        }\n    }\n\n    function _updateReward() internal {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n    }\n\n    function _updateAccountReward(address account) internal {\n        _updateReward();\n\n        assert(account != address(0));\n\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "witnet-solidity-bridge/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n"
    },
    "witnet-solidity-bridge/contracts/interfaces/IWitnetPriceRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"ado-contracts/contracts/interfaces/IERC2362.sol\";\nimport \"./IERC165.sol\";\n\n/// @title The Witnet Price Router basic interface.\n/// @dev Guides implementation of price feeds aggregation contracts.\n/// @author The Witnet Foundation.\nabstract contract IWitnetPriceRouter\n    is\n        IERC2362 \n{\n    /// Emitted everytime a currency pair is attached to a new price feed contract\n    /// @dev See https://github.com/adoracles/ADOIPs/blob/main/adoip-0010.md \n    /// @dev to learn how these ids are created.\n    event CurrencyPairSet(bytes32 indexed erc2362ID, IERC165 pricefeed);\n\n    /// Helper pure function: returns hash of the provided ERC2362-compliant currency pair caption (aka ID).\n    function currencyPairId(string memory) external pure virtual returns (bytes32);\n\n    /// Returns the ERC-165-compliant price feed contract currently serving \n    /// updates on the given currency pair.\n    function getPriceFeed(bytes32 _erc2362id) external view virtual returns (IERC165);\n\n    /// Returns human-readable ERC2362-based caption of the currency pair being\n    /// served by the given price feed contract address. \n    /// @dev Should fail if the given price feed contract address is not currently\n    /// @dev registered in the router.\n    function getPriceFeedCaption(IERC165) external view virtual returns (string memory);\n\n    /// Returns human-readable caption of the ERC2362-based currency pair identifier, if known.\n    function lookupERC2362ID(bytes32 _erc2362id) external view virtual returns (string memory);\n\n    /// Register a price feed contract that will serve updates for the given currency pair.\n    /// @dev Setting zero address to a currency pair implies that it will not be served any longer.\n    /// @dev Otherwise, should fail if the price feed contract does not support the `IWitnetPriceFeed` interface,\n    /// @dev or if given price feed is already serving another currency pair (within this WitnetPriceRouter instance).\n    function setPriceFeed(\n            IERC165 _pricefeed,\n            uint256 _decimals,\n            string calldata _base,\n            string calldata _quote\n        )\n        external virtual;\n\n    /// Returns list of known currency pairs IDs.\n    function supportedCurrencyPairs() external view virtual returns (bytes32[] memory);\n\n    /// Returns `true` if given pair is currently being served by a compliant price feed contract.\n    function supportsCurrencyPair(bytes32 _erc2362id) external view virtual returns (bool);\n\n    /// Returns `true` if given price feed contract is currently serving updates to any known currency pair. \n    function supportsPriceFeed(IERC165 _priceFeed) external view virtual returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}