{
  "address": "0x4A718536cb1e82C6cd7E568d3faF1fa0cEb41C7e",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newActivePoolAddress",
          "type": "address"
        }
      ],
      "name": "ActivePoolAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newBorrowerOperationsAddress",
          "type": "address"
        }
      ],
      "name": "BorrowerOperationsAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newCommunityIssuanceAddress",
          "type": "address"
        }
      ],
      "name": "CommunityIssuanceAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newDefaultPoolAddress",
          "type": "address"
        }
      ],
      "name": "DefaultPoolAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_P",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_S",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_G",
          "type": "uint256"
        }
      ],
      "name": "DepositSnapshotUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_currentEpoch",
          "type": "uint256"
        }
      ],
      "name": "EpochUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "EtherSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_kickbackRate",
          "type": "uint256"
        }
      ],
      "name": "FrontEndRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_P",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_G",
          "type": "uint256"
        }
      ],
      "name": "FrontEndSnapshotUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_newFrontEndStake",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        }
      ],
      "name": "FrontEndStakeChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        }
      ],
      "name": "FrontEndTagSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_G",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_epoch",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_scale",
          "type": "uint256"
        }
      ],
      "name": "G_Updated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_NEON",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_ZKUSDLoss",
          "type": "uint256"
        }
      ],
      "name": "NEONGainWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_P",
          "type": "uint256"
        }
      ],
      "name": "P_Updated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newPriceFeedAddress",
          "type": "address"
        }
      ],
      "name": "PriceFeedAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_S",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_epoch",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_scale",
          "type": "uint256"
        }
      ],
      "name": "S_Updated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_currentScale",
          "type": "uint256"
        }
      ],
      "name": "ScaleUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newSortedTrovesAddress",
          "type": "address"
        }
      ],
      "name": "SortedTrovesAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_newBalance",
          "type": "uint256"
        }
      ],
      "name": "StabilityPoolNEONBalanceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_newBalance",
          "type": "uint256"
        }
      ],
      "name": "StabilityPoolZKUSDBalanceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newTroveManagerAddress",
          "type": "address"
        }
      ],
      "name": "TroveManagerAddressChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_newDeposit",
          "type": "uint256"
        }
      ],
      "name": "UserDepositChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_ZKT",
          "type": "uint256"
        }
      ],
      "name": "ZKTPaidToDepositor",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_ZKT",
          "type": "uint256"
        }
      ],
      "name": "ZKTPaidToFrontEnd",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newZKUSDTokenAddress",
          "type": "address"
        }
      ],
      "name": "ZKUSDTokenAddressChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BORROWING_FEE_FLOOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CCR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DECIMAL_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DefaultKickbackRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MCR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_NET_DEBT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NAME",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "P",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PERCENT_DIVISOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SCALE_FACTOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ZKUSD_GAS_COMPENSATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_100pct",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "activePool",
      "outputs": [
        {
          "internalType": "contract IActivePool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "borrowerOperations",
      "outputs": [
        {
          "internalType": "contract IBorrowerOperations",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "communityIssuance",
      "outputs": [
        {
          "internalType": "contract ICommunityIssuance",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentEpoch",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentScale",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultPool",
      "outputs": [
        {
          "internalType": "contract IDefaultPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "depositSnapshots",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "S",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "P",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "G",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "scale",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "epoch",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "deposits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "epochToScaleToG",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "epochToScaleToSum",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "frontEndSnapshots",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "S",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "P",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "G",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "scale",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "epoch",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "frontEndStakes",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        }
      ],
      "name": "getCompoundedFrontEndStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        }
      ],
      "name": "getCompoundedZKUSDDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        }
      ],
      "name": "getDepositorNEONGain",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        }
      ],
      "name": "getDepositorZKTGain",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEntireSystemColl",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "entireSystemColl",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getEntireSystemDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "entireSystemDebt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_frontEnd",
          "type": "address"
        }
      ],
      "name": "getFrontEndZKTGain",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNEON",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalZKUSDDeposits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastNEONError_Offset",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastZKTError",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastZKUSDLossError_Offset",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_debtToOffset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_collToAdd",
          "type": "uint256"
        }
      ],
      "name": "offset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "priceFeed",
      "outputs": [
        {
          "internalType": "contract IPriceFeed",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "provideToSP",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_borrowerOperationsAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_troveManagerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_activePoolAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_zkusdTokenAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_sortedTrovesAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_priceFeedAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_communityIssuanceAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_treasuryAddress",
          "type": "address"
        }
      ],
      "name": "setAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_defaultKickBackRate",
          "type": "uint256"
        }
      ],
      "name": "setDefaultKickbackRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sortedTroves",
      "outputs": [
        {
          "internalType": "contract ISortedTroves",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "troveManager",
      "outputs": [
        {
          "internalType": "contract ITroveManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFromSP",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_upperHint",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_lowerHint",
          "type": "address"
        }
      ],
      "name": "withdrawNEONGainToTrove",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "zkusdToken",
      "outputs": [
        {
          "internalType": "contract IZKUSDToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x4506320cac34f0fa4e245a456fb915fd62e511ee5f67fb66932a9efa166cca51",
  "receipt": {
    "to": null,
    "from": "0x6352ea70c6FE6c0F09Ab4d9d873E9B9C20079ffe",
    "contractAddress": "0x4A718536cb1e82C6cd7E568d3faF1fa0cEb41C7e",
    "transactionIndex": 0,
    "gasUsed": "100774440",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xffb0339bfb86ddb8e6e36d0b85d13dc1bb36889a5d58757c43f125fc1e33a374",
    "transactionHash": "0x4506320cac34f0fa4e245a456fb915fd62e511ee5f67fb66932a9efa166cca51",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 236682278,
        "transactionHash": "0x4506320cac34f0fa4e245a456fb915fd62e511ee5f67fb66932a9efa166cca51",
        "address": "0x4A718536cb1e82C6cd7E568d3faF1fa0cEb41C7e",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000006352ea70c6fe6c0f09ab4d9d873e9b9c20079ffe"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xffb0339bfb86ddb8e6e36d0b85d13dc1bb36889a5d58757c43f125fc1e33a374"
      }
    ],
    "blockNumber": 236682278,
    "cumulativeGasUsed": "100774440",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "035045f1e037f3a6258fc3cece2987fc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newActivePoolAddress\",\"type\":\"address\"}],\"name\":\"ActivePoolAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newBorrowerOperationsAddress\",\"type\":\"address\"}],\"name\":\"BorrowerOperationsAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCommunityIssuanceAddress\",\"type\":\"address\"}],\"name\":\"CommunityIssuanceAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newDefaultPoolAddress\",\"type\":\"address\"}],\"name\":\"DefaultPoolAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_S\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"}],\"name\":\"DepositSnapshotUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentEpoch\",\"type\":\"uint256\"}],\"name\":\"EpochUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EtherSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_kickbackRate\",\"type\":\"uint256\"}],\"name\":\"FrontEndRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"}],\"name\":\"FrontEndSnapshotUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newFrontEndStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"FrontEndStakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"FrontEndTagSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"G_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_NEON\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ZKUSDLoss\",\"type\":\"uint256\"}],\"name\":\"NEONGainWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"}],\"name\":\"P_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newPriceFeedAddress\",\"type\":\"address\"}],\"name\":\"PriceFeedAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_S\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"S_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentScale\",\"type\":\"uint256\"}],\"name\":\"ScaleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newSortedTrovesAddress\",\"type\":\"address\"}],\"name\":\"SortedTrovesAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"StabilityPoolNEONBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"StabilityPoolZKUSDBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newTroveManagerAddress\",\"type\":\"address\"}],\"name\":\"TroveManagerAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newDeposit\",\"type\":\"uint256\"}],\"name\":\"UserDepositChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ZKT\",\"type\":\"uint256\"}],\"name\":\"ZKTPaidToDepositor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ZKT\",\"type\":\"uint256\"}],\"name\":\"ZKTPaidToFrontEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newZKUSDTokenAddress\",\"type\":\"address\"}],\"name\":\"ZKUSDTokenAddressChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWING_FEE_FLOOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DefaultKickbackRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_NET_DEBT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"P\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SCALE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZKUSD_GAS_COMPENSATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_100pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activePool\",\"outputs\":[{\"internalType\":\"contract IActivePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityIssuance\",\"outputs\":[{\"internalType\":\"contract ICommunityIssuance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPool\",\"outputs\":[{\"internalType\":\"contract IDefaultPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"S\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"P\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochToScaleToG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochToScaleToSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frontEndSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"S\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"P\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frontEndStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"getCompoundedFrontEndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getCompoundedZKUSDDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorNEONGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorZKTGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemColl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"getFrontEndZKTGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNEON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalZKUSDDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastNEONError_Offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastZKTError\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastZKUSDLossError_Offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debtToOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collToAdd\",\"type\":\"uint256\"}],\"name\":\"offset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"provideToSP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrowerOperationsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_troveManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zkusdTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sortedTrovesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_communityIssuanceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_defaultKickBackRate\",\"type\":\"uint256\"}],\"name\":\"setDefaultKickbackRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromSP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lowerHint\",\"type\":\"address\"}],\"name\":\"withdrawNEONGainToTrove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkusdToken\",\"outputs\":[{\"internalType\":\"contract IZKUSDToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/StabilityPool.sol\":\"StabilityPool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":500},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"contracts/dependencies/CheckContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract CheckContract {\\n    /**\\n     * Check that the account is an already deployed non-destroyed contract.\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n     */\\n    function checkContract(address _account) internal view {\\n        require(_account != address(0), \\\"Account cannot be zero address\\\");\\n        require(\\n            Address.isContract(_account),\\n            \\\"Account code size cannot be zero\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xaf457c01990a35e69f187bbaa4daceb410b624d7c34029246b54333816a4bba7\",\"license\":\"MIT\"},\"contracts/dependencies/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary FullMath {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \\u201ctoo high\\u201d could lead to overflows.\\n     * - Making it \\u201ctoo low\\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 NEON,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint256 internal constant NICR_PRECISION = 1e20;\\n\\n    /*\\n     * Multiply two decimal numbers and use normal rounding rules:\\n     * -round product up if 19'th mantissa digit >= 5\\n     * -round product down if 19'th mantissa digit < 5\\n     *\\n     * Used only inside the exponentiation, _decPow().\\n     */\\n    function decMul(\\n        uint256 x,\\n        uint256 y\\n    ) internal pure returns (uint256 decProd) {\\n        uint256 prod_xy = x.mul(y);\\n\\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n     *\\n     * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n     *\\n     * Called by two functions that represent time in units of minutes:\\n     * 1) FullManager._calcDecayedBaseRate\\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n     *\\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n     * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n     *\\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n     * negligibly different from just passing the cap, since:\\n     *\\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n     */\\n    function _decPow(\\n        uint256 _base,\\n        uint256 _minutes\\n    ) internal pure returns (uint256) {\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        } // cap to avoid overflow\\n\\n        if (_minutes == 0) {\\n            return DECIMAL_PRECISION;\\n        }\\n\\n        uint256 y = DECIMAL_PRECISION;\\n        uint256 x = _base;\\n        uint256 n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n.div(2);\\n            } else {\\n                // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n.sub(1)).div(2);\\n            }\\n        }\\n\\n        return decMul(x, y);\\n    }\\n\\n    function _getAbsoluteDifference(\\n        uint256 _a,\\n        uint256 _b\\n    ) internal pure returns (uint256) {\\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n    }\\n\\n    function _computeNominalCR(\\n        uint256 _coll,\\n        uint256 _debt\\n    ) internal pure returns (uint256) {\\n        if (_debt > 0) {\\n            return _coll.mul(NICR_PRECISION).div(_debt);\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return type(uint256).max;\\n        }\\n    }\\n\\n    function _computeCR(\\n        uint256 _coll,\\n        uint256 _debt,\\n        uint256 _price\\n    ) internal pure returns (uint256) {\\n        if (_debt > 0) {\\n            uint256 newCollRatio = _coll.mul(_price).div(_debt);\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return type(uint256).max;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x371483b35a8171382c93c59d446f040b1b8b86bb2e205bd315d34b67ce389b4e\",\"license\":\"MIT\"},\"contracts/dependencies/ZKTProtocolBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IActivePool.sol\\\";\\nimport \\\"../interfaces/IDefaultPool.sol\\\";\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"./FullMath.sol\\\";\\n\\n/*\\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\\n * common functions.\\n */\\nabstract contract ZKTProtocolBase {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant DECIMAL_PRECISION = 1e18;\\n\\n    uint256 public constant _100pct = 1000000000000000000; // 1e18 == 100%\\n\\n    // Minimum collateral ratio for individual troves\\n    uint256 public constant MCR = 1100000000000000000; // 110%\\n\\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\n    uint256 public constant CCR = 1500000000000000000; // 150%\\n\\n    // Amount of ZKUSD to be locked in gas pool on opening troves\\n    uint256 public constant ZKUSD_GAS_COMPENSATION = 50e18;\\n\\n    // Minimum amount of net ZKUSD debt a trove must have\\n    uint256 public constant MIN_NET_DEBT = 450e18;\\n\\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\n\\n    uint256 public constant BORROWING_FEE_FLOOR =\\n        (DECIMAL_PRECISION / 1000) * 5; // 0.5%\\n\\n    IActivePool public activePool;\\n\\n    IDefaultPool public defaultPool;\\n\\n    IPriceFeed public priceFeed;\\n\\n    // --- Gas compensation functions ---\\n\\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\\n    function _getCompositeDebt(uint256 _debt) internal pure returns (uint256) {\\n        return _debt.add(ZKUSD_GAS_COMPENSATION);\\n    }\\n\\n    function _getNetDebt(uint256 _debt) internal pure returns (uint256) {\\n        return _debt.sub(ZKUSD_GAS_COMPENSATION);\\n    }\\n\\n    // Return the amount of NEON to be drawn from a trove's collateral and sent as gas compensation.\\n    function _getCollGasCompensation(\\n        uint256 _entireColl\\n    ) internal pure returns (uint256) {\\n        return _entireColl / PERCENT_DIVISOR;\\n    }\\n\\n    function getEntireSystemColl()\\n        public\\n        view\\n        returns (uint256 entireSystemColl)\\n    {\\n        uint256 activeColl = activePool.getNEON();\\n        uint256 liquidatedColl = defaultPool.getNEON();\\n\\n        return activeColl.add(liquidatedColl);\\n    }\\n\\n    function getEntireSystemDebt()\\n        public\\n        view\\n        returns (uint256 entireSystemDebt)\\n    {\\n        uint256 activeDebt = activePool.getZKUSDDebt();\\n        uint256 closedDebt = defaultPool.getZKUSDDebt();\\n\\n        return activeDebt.add(closedDebt);\\n    }\\n\\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\\n        uint256 entireSystemColl = getEntireSystemColl();\\n        uint256 entireSystemDebt = getEntireSystemDebt();\\n\\n        TCR = FullMath._computeCR(entireSystemColl, entireSystemDebt, _price);\\n\\n        return TCR;\\n    }\\n\\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\\n        uint256 TCR = _getTCR(_price);\\n\\n        return TCR < CCR;\\n    }\\n\\n    function _requireUserAcceptsFee(\\n        uint256 _fee,\\n        uint256 _amount,\\n        uint256 _maxFeePercentage\\n    ) internal pure {\\n        uint256 feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\\n        require(\\n            feePercentage <= _maxFeePercentage,\\n            \\\"Fee exceeded provided maximum\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x065532b6a683f3a6487a35bcd07d05007c3d7921c1a7d2dbef6ceaa23eaf2bd5\",\"license\":\"MIT\"},\"contracts/interfaces/IActivePool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface IActivePool is IPool {\\n    // --- Events ---\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\\n    event ActivePoolNEONBalanceUpdated(uint256 _NEON);\\n\\n    // --- Functions ---\\n    function sendNEON(address _account, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x666016f4a4f781312317f182c462fd5624935f42275cbe3ea42e5a8a71d3fde3\",\"license\":\"MIT\"},\"contracts/interfaces/IBorrowerOperations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ITroveManager.sol\\\";\\nimport \\\"./IZKUSDToken.sol\\\";\\nimport \\\"./IActivePool.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface IBorrowerOperations {\\n    /* --- Variable container structs  ---\\n\\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\\n    \\\"CompilerError: Stack too deep\\\". */\\n\\n    struct LocalVariables_adjustTrove {\\n        uint256 price;\\n        uint256 collChange;\\n        uint256 netDebtChange;\\n        bool isCollIncrease;\\n        uint256 debt;\\n        uint256 coll;\\n        uint256 oldICR;\\n        uint256 newICR;\\n        uint256 newTCR;\\n        uint256 ZKUSDFee;\\n        uint256 newDebt;\\n        uint256 newColl;\\n        uint256 stake;\\n    }\\n\\n    struct LocalVariables_openTrove {\\n        uint256 price;\\n        uint256 ZKUSDFee;\\n        uint256 netDebt;\\n        uint256 compositeDebt;\\n        uint256 ICR;\\n        uint256 NICR;\\n        uint256 stake;\\n        uint256 arrayIndex;\\n    }\\n\\n    struct ContractsCache {\\n        ITroveManager troveManager;\\n        IActivePool activePool;\\n        IZKUSDToken zkusdToken;\\n    }\\n\\n    enum Operation {\\n        openTrove,\\n        closeTrove,\\n        adjustTrove\\n    }\\n\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event ZKUSDTokenAddressChanged(address _zkusdTokenAddress);\\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\\n\\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint256 _debt,\\n        uint256 _coll,\\n        uint256 stake,\\n        Operation operation\\n    );\\n    event ZKUSDBorrowingFeePaid(address indexed _borrower, uint256 _ZKUSDFee);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _sortedTrovesAddress,\\n        address _zkusdTokenAddress,\\n        address _zktStakingAddress\\n    ) external;\\n\\n    function openTrove(\\n        uint256 _maxFee,\\n        uint256 _ZKUSDAmount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external payable;\\n\\n    function addColl(address _upperHint, address _lowerHint) external payable;\\n\\n    function moveNEONGainToTrove(\\n        address _user,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external payable;\\n\\n    function withdrawColl(\\n        uint256 _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function withdrawZKUSD(\\n        uint256 _maxFee,\\n        uint256 _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function repayZKUSD(\\n        uint256 _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function closeTrove() external;\\n\\n    function adjustTrove(\\n        uint256 _maxFee,\\n        uint256 _collWithdrawal,\\n        uint256 _debtChange,\\n        bool isDebtIncrease,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external payable;\\n\\n    function claimCollateral() external;\\n\\n    function getCompositeDebt(uint256 _debt) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0xc947332551f4b1f5bbe30da1d4223885608525191a31bcc5910ef8e3a5bcb3e4\",\"license\":\"MIT\"},\"contracts/interfaces/ICollSurplusPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICollSurplusPool {\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n\\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\\n    event EtherSent(address _to, uint256 _amount);\\n\\n    // --- Contract setters ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress\\n    ) external;\\n\\n    function getNEON() external view returns (uint256);\\n\\n    function getCollateral(address _account) external view returns (uint256);\\n\\n    function accountSurplus(address _account, uint256 _amount) external;\\n\\n    function claimColl(address _account) external;\\n}\\n\",\"keccak256\":\"0x48ed7d74ad9192d4776774de0b94bbe8a1810708d96a109a002f857983c626f5\",\"license\":\"MIT\"},\"contracts/interfaces/ICommunityIssuance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICommunityIssuance {\\n    // --- Events ---\\n\\n    event ZKTokenAddressSet(address _zkTokenAddress);\\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\\n    event TotalZKTIssuedUpdated(uint _totalZKTIssued);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _zkTokenAddress,\\n        address _stabilityPoolAddress\\n    ) external;\\n\\n    function issueZKT() external returns (uint);\\n\\n    function sendZKT(address _account, uint _ZKTamount) external;\\n}\\n\",\"keccak256\":\"0xa1b8e0c4b789ce8ff38a9bdcb0bb2f52ce14befda1e5066f133df4d4c2ce42ac\",\"license\":\"MIT\"},\"contracts/interfaces/IDefaultPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface IDefaultPool is IPool {\\n    // --- Events ---\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event DefaultPoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\\n    event DefaultPoolNEONBalanceUpdated(uint256 _NEON);\\n\\n    // --- Functions ---\\n    function sendNEONToActivePool(uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x14e6882c102f3e4202dbb70723dc9b9acc57d915bab2c53e28724a7edf7389c5\",\"license\":\"MIT\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    // --- Events ---\\n\\n    event NEONBalanceUpdated(uint256 _newBalance);\\n    event ZKUSDBalanceUpdated(uint256 _newBalance);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event EtherSent(address _to, uint256 _amount);\\n\\n    // --- Functions ---\\n\\n    function getNEON() external view returns (uint256);\\n\\n    function getZKUSDDebt() external view returns (uint256);\\n\\n    function increaseZKUSDDebt(uint256 _amount) external;\\n\\n    function decreaseZKUSDDebt(uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x23480740f7ee57233e104ccb5282cbdfb9380d53d5c33eed74d655159bc4edee\",\"license\":\"MIT\"},\"contracts/interfaces/IPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPriceFeed {\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\\n\\n    // --- Function ---\\n    function fetchPrice() external returns (uint256);\\n}\\n\",\"keccak256\":\"0x7f24553ec892c12c1d924bfb1ae70a127ce520c46529631dee6b2ee1b248b6ff\",\"license\":\"MIT\"},\"contracts/interfaces/ISortedTroves.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Common interface for the SortedTroves Doubly Linked List.\\ninterface ISortedTroves {\\n    // --- Events ---\\n\\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event UpdateLink(address _head, address _tail, uint256 _currentSize);\\n    event NodeAdded(\\n        address _id,\\n        address _prevId,\\n        address _nextId,\\n        uint256 _NICR\\n    );\\n    event NodeRemoved(address _id);\\n\\n    // --- Functions ---\\n\\n    function setParams(\\n        uint256 _size,\\n        address _TroveManagerAddress,\\n        address _borrowerOperationsAddress\\n    ) external;\\n\\n    function insert(\\n        address _id,\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external;\\n\\n    function remove(address _id) external;\\n\\n    function reInsert(\\n        address _id,\\n        uint256 _newICR,\\n        address _prevId,\\n        address _nextId\\n    ) external;\\n\\n    function contains(address _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (address);\\n\\n    function getLast() external view returns (address);\\n\\n    function getNext(address _id) external view returns (address);\\n\\n    function getPrev(address _id) external view returns (address);\\n\\n    function validInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (bool);\\n\\n    function findInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (address, address);\\n}\\n\",\"keccak256\":\"0x929f7b0a20d29c02088a0be525c1974966415083a343b2a509a501800dd139a5\",\"license\":\"MIT\"},\"contracts/interfaces/IStabilityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/*\\n * The Stability Pool holds ZKUSD tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its ZKUSD debt gets offset with\\n * ZKUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of ZKUSD tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a ZKUSD loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an NEON gain, as the NEON collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total ZKUSD in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n * --- ZKT ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An ZKT issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued ZKT in proportion to the deposit as a share of total deposits. The ZKT earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n */\\ninterface IStabilityPool {\\n    // --- Events ---\\n\\n    event StabilityPoolNEONBalanceUpdated(uint256 _newBalance);\\n    event StabilityPoolZKUSDBalanceUpdated(uint256 _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n\\n    event P_Updated(uint256 _P);\\n    event S_Updated(uint256 _S, uint256 _epoch, uint256 _scale);\\n    event G_Updated(uint256 _G, uint256 _epoch, uint256 _scale);\\n    event EpochUpdated(uint256 _currentEpoch);\\n    event ScaleUpdated(uint256 _currentScale);\\n\\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\\n\\n    event DepositSnapshotUpdated(\\n        address indexed _depositor,\\n        uint256 _P,\\n        uint256 _S,\\n        uint256 _G\\n    );\\n    event FrontEndSnapshotUpdated(\\n        address indexed _frontEnd,\\n        uint256 _P,\\n        uint256 _G\\n    );\\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\\n    event FrontEndStakeChanged(\\n        address indexed _frontEnd,\\n        uint256 _newFrontEndStake,\\n        address _depositor\\n    );\\n\\n    event NEONGainWithdrawn(\\n        address indexed _depositor,\\n        uint256 _NEON,\\n        uint256 _ZKUSDLoss\\n    );\\n    event ZKTPaidToDepositor(address indexed _depositor, uint256 _ZKT);\\n    event ZKTPaidToFrontEnd(address indexed _frontEnd, uint256 _ZKT);\\n    event EtherSent(address _to, uint256 _amount);\\n\\n    // --- Functions ---\\n\\n    /*\\n     * Called only once on init, to set addresses of other Liquity contracts\\n     * Callable only by owner, renounces ownership at the end\\n     */\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _zkusdTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress,\\n        address _vault\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is not zero\\n     * ---\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (ZKT, NEON) to depositor\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint256 _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is zero or there are no under collateralized troves left in the system\\n     * - User has a non zero deposit\\n     * ---\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's accumulated gains (ZKT, NEON) to depositor\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint256 _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - User has a non zero deposit\\n     * - User has an open trove\\n     * - User has some NEON gain\\n     * ---\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors\\n     * - Sends all depositor's ZKT gain to  depositor\\n     * - Transfers the depositor's entire NEON gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged\\n     */\\n    function withdrawNEONGainToTrove(\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Caller is TroveManager\\n     * ---\\n     * Cancels out the specified debt against the ZKUSD contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's NEON collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint256 _debt, uint256 _coll) external;\\n\\n    /*\\n     * Returns the total amount of NEON held by the pool, accounted in an internal variable instead of `balance`,\\n     * to exclude edge cases like NEON received from a self-destruct.\\n     */\\n    function getNEON() external view returns (uint256);\\n\\n    /*\\n     * Returns ZKUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n     */\\n    function getTotalZKUSDDeposits() external view returns (uint256);\\n\\n    /*\\n     * Calculates the NEON gain earned by the deposit since its last snapshots were taken.\\n     */\\n    function getDepositorNEONGain(\\n        address _depositor\\n    ) external view returns (uint256);\\n\\n    /*\\n     * Calculate the ZKT gain earned by a deposit since its last snapshots were taken.\\n     * The depositor gets a 99.9% cut of what their deposit earned.\\n     * Otherwise, their cut of the deposit's earnings is equal to the defaultKickbackRate\\n     * which they made their deposit.\\n     */\\n    function getDepositorZKTGain(\\n        address _depositor\\n    ) external view returns (uint256);\\n\\n    /*\\n     * Return the ZKT gain earned by the front end(depositor).\\n     */\\n    function getFrontEndZKTGain(\\n        address _frontEnd\\n    ) external view returns (uint256);\\n\\n    /*\\n     * Return the user's compounded deposit.\\n     */\\n    function getCompoundedZKUSDDeposit(\\n        address _depositor\\n    ) external view returns (uint256);\\n\\n    /*\\n     * Return the front end's compounded stake.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n    function getCompoundedFrontEndStake(\\n        address _frontEnd\\n    ) external view returns (uint256);\\n\\n    /*\\n     * Fallback function\\n     * Only callable by Active Pool, it just accounts for NEON received\\n     * receive() external payable;\\n     */\\n}\\n\",\"keccak256\":\"0xe2c01f7bbba4d3bedb03804d9362c40cfd77e352f2265e913bb9dd3bf4742a37\",\"license\":\"MIT\"},\"contracts/interfaces/ITroveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IStabilityPool.sol\\\";\\nimport \\\"./IZKUSDToken.sol\\\";\\nimport \\\"./IZKToken.sol\\\";\\nimport \\\"./IZKTStaking.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveManager {\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event ZKTokenAddressChanged(address _zkTokenAddress);\\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\\n\\n    event Liquidation(\\n        uint256 _liquidatedDebt,\\n        uint256 _liquidatedColl,\\n        uint256 _collGasCompensation,\\n        uint256 _ZKUSDGasCompensation\\n    );\\n    event Redemption(\\n        uint256 _attemptedZKUSDAmount,\\n        uint256 _actualZKUSDAmount,\\n        uint256 _NEONSent,\\n        uint256 _NEONFee\\n    );\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint256 _debt,\\n        uint256 _coll,\\n        uint256 stake,\\n        Operation operation\\n    );\\n    event TroveLiquidated(\\n        address indexed _borrower,\\n        uint256 _debt,\\n        uint256 _coll,\\n        Operation operation\\n    );\\n    event BaseRateUpdated(uint256 _baseRate);\\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\\n    event TotalStakesUpdated(uint256 _newTotalStakes);\\n    event SystemSnapshotsUpdated(\\n        uint256 _totalStakesSnapshot,\\n        uint256 _totalCollateralSnapshot\\n    );\\n    event LTermsUpdated(uint256 _L_Native, uint256 _L_Debt);\\n    event TroveSnapshotsUpdated(\\n        address _borrower,\\n        uint256 _L_Native,\\n        uint256 _L_Debt\\n    );\\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\\n\\n    enum Operation {\\n        applyPendingRewards,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral\\n    }\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _zkusdTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _zkTokenAddress,\\n        address _zktStakingAddress\\n    ) external;\\n\\n    function stabilityPool() external view returns (IStabilityPool);\\n\\n    function zkusdToken() external view returns (IZKUSDToken);\\n\\n    function zkToken() external view returns (IZKToken);\\n\\n    function zktStaking() external view returns (IZKTStaking);\\n\\n    function getTroveOwnersCount() external view returns (uint256);\\n\\n    function getTroveFromTroveOwnersArray(\\n        uint256 _index\\n    ) external view returns (address);\\n\\n    function getNominalICR(address _borrower) external view returns (uint256);\\n\\n    function getCurrentICR(\\n        address _borrower,\\n        uint256 _price\\n    ) external view returns (uint256);\\n\\n    function liquidate(address _borrower) external;\\n\\n    function liquidateTroves(uint256 _n) external;\\n\\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\\n\\n    function redeemCollateral(\\n        uint256 _ZKUSDAmount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint256 _partialRedemptionHintNICR,\\n        uint256 _maxIterations,\\n        uint256 _maxFee\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(\\n        address _borrower\\n    ) external returns (uint256);\\n\\n    function updateTroveRewardSnapshots(address _borrower) external;\\n\\n    function addTroveOwnerToArray(\\n        address _borrower\\n    ) external returns (uint256 index);\\n\\n    function applyPendingRewards(address _borrower) external;\\n\\n    function getPendingNEONReward(\\n        address _borrower\\n    ) external view returns (uint256);\\n\\n    function getPendingZKUSDDebtReward(\\n        address _borrower\\n    ) external view returns (uint256);\\n\\n    function hasPendingRewards(address _borrower) external view returns (bool);\\n\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 debt,\\n            uint256 coll,\\n            uint256 pendingZKUSDDebtReward,\\n            uint256 pendingNEONReward\\n        );\\n\\n    function closeTrove(address _borrower) external;\\n\\n    function removeStake(address _borrower) external;\\n\\n    function getRedemptionRate() external view returns (uint256);\\n\\n    function getRedemptionRateWithDecay() external view returns (uint256);\\n\\n    function getRedemptionFeeWithDecay(\\n        uint256 _NEONDrawn\\n    ) external view returns (uint256);\\n\\n    function getBorrowingRate() external view returns (uint256);\\n\\n    function getBorrowingRateWithDecay() external view returns (uint256);\\n\\n    function getBorrowingFee(uint256 ZKUSDDebt) external view returns (uint256);\\n\\n    function getBorrowingFeeWithDecay(\\n        uint256 _ZKUSDDebt\\n    ) external view returns (uint256);\\n\\n    function decayBaseRateFromBorrowing() external;\\n\\n    function getTroveStatus(address _borrower) external view returns (uint256);\\n\\n    function getTroveStake(address _borrower) external view returns (uint256);\\n\\n    function getTroveDebt(address _borrower) external view returns (uint256);\\n\\n    function getTroveColl(address _borrower) external view returns (uint256);\\n\\n    function setTroveStatus(address _borrower, uint256 num) external;\\n\\n    function increaseTroveColl(\\n        address _borrower,\\n        uint256 _collIncrease\\n    ) external returns (uint256);\\n\\n    function decreaseTroveColl(\\n        address _borrower,\\n        uint256 _collDecrease\\n    ) external returns (uint256);\\n\\n    function increaseTroveDebt(\\n        address _borrower,\\n        uint256 _debtIncrease\\n    ) external returns (uint256);\\n\\n    function decreaseTroveDebt(\\n        address _borrower,\\n        uint256 _collDecrease\\n    ) external returns (uint256);\\n\\n    function getTCR(uint256 _price) external view returns (uint256);\\n\\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe7e3d5da3fbf34b6681c0263fb61939584c66b7278a68d0d9522bf6125731dce\",\"license\":\"MIT\"},\"contracts/interfaces/IZKTStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IZKTStaking {\\n    // --- Events --\\n\\n    event ZKTokenAddressSet(address _zkTokenAddress);\\n    event ZKUSDTokenAddressSet(address _zkusdTokenAddress);\\n    event TroveManagerAddressSet(address _troveManager);\\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\\n    event ActivePoolAddressSet(address _activePoolAddress);\\n\\n    event StakeChanged(address indexed staker, uint256 newStake);\\n    event StakingGainsWithdrawn(\\n        address indexed staker,\\n        uint256 ZKUSDGain,\\n        uint256 NEONGain\\n    );\\n    event F_NEONUpdated(uint256 _F_NEON);\\n    event F_ZKUSDUpdated(uint256 _F_ZKUSD);\\n    event TotalZKTStakedUpdated(uint256 _totalZKTStaked);\\n    event EtherSent(address _account, uint256 _amount);\\n    event StakerSnapshotsUpdated(\\n        address _staker,\\n        uint256 _F_NEON,\\n        uint256 _F_ZKUSD\\n    );\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _zkTokenAddress,\\n        address _zkusdTokenAddress,\\n        address _troveManagerAddress,\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress\\n    ) external;\\n\\n    function stake(uint256 _ZKTamount) external;\\n\\n    function unstake(uint256 _ZKTamount) external;\\n\\n    function increaseF_NEON(uint256 _NEONFee) external;\\n\\n    function increaseF_ZKUSD(uint256 _ZKTFee) external;\\n\\n    function getPendingNEONGain(address _user) external view returns (uint256);\\n\\n    function getPendingZKUSDGain(address _user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5591bb74cca2ed6a0f5c74f37b9225f135196701b6757b49ff2cbad65a146d39\",\"license\":\"MIT\"},\"contracts/interfaces/IZKToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IZKToken is IERC20 {\\n    // --- Events ---\\n\\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\\n    event ZKTStakingAddressSet(address _zktStakingAddress);\\n    event LockupContractFactoryAddressSet(\\n        address _lockupContractFactoryAddress\\n    );\\n\\n    // --- Functions ---\\n\\n    function sendToZKTStaking(address _sender, uint256 _amount) external;\\n\\n    function getDeploymentStartTime() external view returns (uint256);\\n\\n    function getLpRewardsEntitlement() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2957d7a9ae4c53d2454e688c1111a7e29dc267b8e80194acf18656b0330b9c44\",\"license\":\"MIT\"},\"contracts/interfaces/IZKUSDToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IZKUSDToken is IERC20 {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n\\n    event ZKUSDTokenBalanceUpdated(address _user, uint256 _amount);\\n\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n\\n    function sendToPool(\\n        address _sender,\\n        address poolAddress,\\n        uint256 _amount\\n    ) external;\\n\\n    function returnFromPool(\\n        address poolAddress,\\n        address user,\\n        uint256 _amount\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1afab6f094020dd27c3a32ea57339982705d7e599f953e85641c59bbc57bcaec\",\"license\":\"MIT\"},\"contracts/protocol/StabilityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"../interfaces/ITroveManager.sol\\\";\\nimport \\\"../interfaces/IZKUSDToken.sol\\\";\\nimport \\\"../interfaces/ICollSurplusPool.sol\\\";\\nimport \\\"../interfaces/ISortedTroves.sol\\\";\\nimport \\\"../interfaces/IZKTStaking.sol\\\";\\nimport \\\"../interfaces/ICommunityIssuance.sol\\\";\\nimport \\\"../dependencies/CheckContract.sol\\\";\\nimport \\\"../dependencies/FullMath.sol\\\";\\nimport \\\"../dependencies/ZKTProtocolBase.sol\\\";\\n\\n/*\\n * The Stability Pool holds ZKUSD tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its ZKUSD debt gets offset with\\n * ZKUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of ZKUSD tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a ZKUSD loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an NEON gain, as the NEON collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total ZKUSD in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n *\\n * --- IMPLEMENTATION ---\\n *\\n * We use a highly scalable method of tracking deposits and NEON gains that has O(1) complexity.\\n *\\n * When a liquidation occurs, rather than updating each depositor's deposit and NEON gain, we simply update two state variables:\\n * a product P, and a sum S.\\n *\\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\\n * and accumulated NEON gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\\n *\\n * The formula for a depositor's accumulated NEON gain is derived here:\\n *\\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated NEON gain.\\n *\\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding NEON gain\\n * can be calculated using the initial deposit, the depositor\\u2019s snapshots of P and S, and the latest values of P and S.\\n *\\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated NEON gain is paid out, their new deposit is recorded\\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\\n * Essentially, they make a fresh deposit that overwrites the old one.\\n *\\n *\\n * --- SCALE FACTOR ---\\n *\\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\\n *\\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\\n *\\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\\n *\\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\\n * order of 1e-9.\\n *\\n * --- EPOCHS ---\\n *\\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\\n * forever, and break all future reward calculations.\\n *\\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\\n *\\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\\n *\\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\\n *\\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion ZKUSD has depleted to < 1 ZKUSD).\\n *\\n *\\n *  --- TRACKING DEPOSITOR'S NEON GAIN OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\\n *\\n * This allows us to calculate a deposit's accumulated NEON gain, during the epoch in which the deposit was non-zero and earned NEON.\\n *\\n * We calculate the depositor's accumulated NEON gain for the scale at which they made the deposit, using the NEON gain formula:\\n * e_1 = d_t * (S - S_t) / P_t\\n *\\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\\n * e_2 = d_t * S / (P_t * 1e9)\\n *\\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\\n * The deposit therefore was present for reward events from the beginning of that second scale.\\n *\\n *        S_i-S_t + S_{i+1}\\n *      .<--------.------------>\\n *      .         .\\n *      . S_i     .   S_{i+1}\\n *   <--.-------->.<----------->\\n *   S_t.         .\\n *   <->.         .\\n *      t         .\\n *  |---+---------|-------------|-----...\\n *         i            i+1\\n *\\n * The sum of (e_1 + e_2) captures the depositor's total accumulated NEON gain, handling the case where their\\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\\n * deposit is defined as being 0 once it has spanned more than one scale change.\\n *\\n *\\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / NEON gain derivations:\\n *\\n *\\n * --- ZKT ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An ZKT issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued ZKT in proportion to the deposit as a share of total deposits. The ZKT earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * We use the same mathematical product-sum approach to track ZKT gains for depositors, where 'G' is the sum corresponding to ZKT gains.\\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\\n *\\n */\\ncontract StabilityPool is\\n    IStabilityPool,\\n    ZKTProtocolBase,\\n    CheckContract,\\n    Ownable\\n{\\n    using SafeMath for uint256;\\n\\n    string public constant NAME = \\\"StabilityPool\\\";\\n\\n    IBorrowerOperations public borrowerOperations;\\n\\n    ITroveManager public troveManager;\\n\\n    IZKUSDToken public zkusdToken;\\n\\n    // Needed to check if there are pending liquidations\\n    ISortedTroves public sortedTroves;\\n\\n    ICommunityIssuance public communityIssuance;\\n\\n    uint256 internal NEON; // deposited conflux tracker\\n\\n    // Tracker for ZKUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n    uint256 internal totalZKUSDDeposits;\\n\\n    // --- Data structures ---\\n\\n    struct Snapshots {\\n        uint256 S;\\n        uint256 P;\\n        uint256 G;\\n        uint256 scale;\\n        uint256 epoch;\\n    }\\n\\n    mapping(address => uint256) public deposits; // depositor address -> Deposit struct\\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\\n\\n    // remove frontEnd and use adminVault instead, each FrontEnds is treasury address with 99.9% kickbackRate\\n    address public treasury;\\n    uint256 public DefaultKickbackRate =\\n        DECIMAL_PRECISION - (10 * DECIMAL_PRECISION) / 1000;\\n\\n    mapping(address => uint256) public frontEndStakes; // depositer address (front end address)[expired] -> last recorded total deposits, tagged with that front end\\n    mapping(address => Snapshots) public frontEndSnapshots; // depositer address (front end address)[expired] -> snapshots struct\\n\\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\\n     * after a series of liquidations have occurred, each of which cancel some ZKUSD debt with the deposit.\\n     *\\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\\n     */\\n    uint256 public P = DECIMAL_PRECISION;\\n\\n    uint256 public constant SCALE_FACTOR = 1e9;\\n\\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\\n    uint256 public currentScale;\\n\\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\\n    uint256 public currentEpoch;\\n\\n    /* NEON Gain sum 'S': During its lifetime, each deposit d_t earns an NEON gain of ( d_t * [S - S_t] )/P_t, where S_t\\n     * is the depositor's snapshot of S taken at the time t when the deposit was made.\\n     *\\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\\n     *\\n     * - The inner mapping records the sum S at different scales\\n     * - The outer mapping records the (scale => sum) mappings, for different epochs.\\n     */\\n    mapping(uint256 => mapping(uint256 => uint256)) public epochToScaleToSum;\\n\\n    /*\\n     * Similarly, the sum 'G' is used to calculate ZKT gains. During it's lifetime, each deposit d_t earns a ZKT gain of\\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\\n     *\\n     *  ZKT reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\\n     *  In each case, the ZKT reward is issued (i.e. G is updated), before other state changes are made.\\n     */\\n    mapping(uint256 => mapping(uint256 => uint256)) public epochToScaleToG;\\n\\n    // Error tracker for the error correction in the ZKT issuance calculation\\n    uint256 public lastZKTError;\\n    // Error trackers for the error correction in the offset calculation\\n    uint256 public lastNEONError_Offset;\\n    uint256 public lastZKUSDLossError_Offset;\\n\\n    // --- Contract setters ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _zkusdTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress,\\n        address _treasuryAddress\\n    ) external override onlyOwner {\\n        checkContract(_borrowerOperationsAddress);\\n        checkContract(_troveManagerAddress);\\n        checkContract(_activePoolAddress);\\n        checkContract(_zkusdTokenAddress);\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_priceFeedAddress);\\n        checkContract(_communityIssuanceAddress);\\n\\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\\n        troveManager = ITroveManager(_troveManagerAddress);\\n        activePool = IActivePool(_activePoolAddress);\\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\\n        treasury = _treasuryAddress;\\n\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit ZKUSDTokenAddressChanged(_zkusdTokenAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\\n\\n        //renounceOwnership();\\n    }\\n\\n    // --- Getters for public variables. Required by IPool interface ---\\n\\n    function getNEON() external view override returns (uint256) {\\n        return NEON;\\n    }\\n\\n    function getTotalZKUSDDeposits() external view override returns (uint256) {\\n        return totalZKUSDDeposits;\\n    }\\n\\n    function setDefaultKickbackRate(\\n        uint256 _defaultKickBackRate\\n    ) external onlyOwner {\\n        require(_defaultKickBackRate <= DECIMAL_PRECISION, \\\"DECIMAL_PRECISION\\\");\\n        DefaultKickbackRate = _defaultKickBackRate;\\n    }\\n\\n    // --- External Depositor Functions ---\\n\\n    /*  provideToSP():\\n     *\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (ZKT, NEON) to depositor\\n     * - Sends the tagged front end's accumulated ZKT gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint256 _amount) external override {\\n        _requireNonZeroAmount(_amount);\\n\\n        uint256 initialDeposit = deposits[msg.sender];\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerZKTIssuance(communityIssuanceCached);\\n\\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\\n\\n        // First pay out any ZKT gains\\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\\n\\n        // Update front end stake\\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\\n            msg.sender\\n        );\\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\\n\\n        _sendZKUSDtoStabilityPool(msg.sender, _amount);\\n\\n        uint256 newDeposit = compoundedZKUSDDeposit.add(_amount);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss); // ZKUSD Loss required for event log\\n\\n        _sendNEONGainToDepositor(depositorNEONGain);\\n    }\\n\\n    /*  withdrawFromSP():\\n     *\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (ZKT, NEON) to depositor\\n     * - Sends the tagged front end's accumulated ZKT gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint256 _amount) external override {\\n        if (_amount != 0) {\\n            _requireNoUnderCollateralizedTroves();\\n        }\\n        uint256 initialDeposit = deposits[msg.sender];\\n        _requireUserHasDeposit(initialDeposit);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerZKTIssuance(communityIssuanceCached);\\n\\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\\n\\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\\n        uint256 ZKUSDtoWithdraw = Math.min(_amount, compoundedZKUSDDeposit);\\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\\n\\n        // First pay out any ZKT gains\\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\\n\\n        // Update front end stake\\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\\n            msg.sender\\n        );\\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(ZKUSDtoWithdraw);\\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\\n\\n        _sendZKUSDToDepositor(msg.sender, ZKUSDtoWithdraw);\\n\\n        // Update deposit\\n        uint256 newDeposit = compoundedZKUSDDeposit.sub(ZKUSDtoWithdraw);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss); // ZKUSD Loss required for event log\\n\\n        _sendNEONGainToDepositor(depositorNEONGain);\\n    }\\n\\n    /* withdrawNEONGainToTrove:\\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's ZKT gain to  depositor\\n     * - Sends all tagged front end's ZKT gain to the tagged front end\\n     * - Transfers the depositor's entire NEON gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake */\\n    function withdrawNEONGainToTrove(\\n        address _upperHint,\\n        address _lowerHint\\n    ) external override {\\n        uint256 initialDeposit = deposits[msg.sender];\\n        _requireUserHasDeposit(initialDeposit);\\n        _requireUserHasTrove(msg.sender);\\n        _requireUserHasNEONGain(msg.sender);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerZKTIssuance(communityIssuanceCached);\\n\\n        uint256 depositorNEONGain = getDepositorNEONGain(msg.sender);\\n\\n        uint256 compoundedZKUSDDeposit = getCompoundedZKUSDDeposit(msg.sender);\\n        uint256 ZKUSDLoss = initialDeposit.sub(compoundedZKUSDDeposit); // Needed only for event log\\n\\n        // First pay out any ZKT gains\\n        _payOutZKTGains(communityIssuanceCached, msg.sender);\\n\\n        // Update front end stake\\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(\\n            msg.sender\\n        );\\n        uint256 newFrontEndStake = compoundedFrontEndStake;\\n        _updateFrontEndStakeAndSnapshots(msg.sender, newFrontEndStake);\\n        emit FrontEndStakeChanged(msg.sender, newFrontEndStake, msg.sender);\\n\\n        _updateDepositAndSnapshots(msg.sender, compoundedZKUSDDeposit);\\n\\n        /* Emit events before transferring NEON gain to Trove.\\n         This lets the event log make more sense (i.e. so it appears that first the NEON gain is withdrawn\\n        and then it is deposited into the Trove, not the other way around). */\\n        emit NEONGainWithdrawn(msg.sender, depositorNEONGain, ZKUSDLoss);\\n        emit UserDepositChanged(msg.sender, compoundedZKUSDDeposit);\\n\\n        NEON = NEON.sub(depositorNEONGain);\\n        emit StabilityPoolNEONBalanceUpdated(NEON);\\n        emit EtherSent(msg.sender, depositorNEONGain);\\n\\n        borrowerOperations.moveNEONGainToTrove{value: depositorNEONGain}(\\n            msg.sender,\\n            _upperHint,\\n            _lowerHint\\n        );\\n    }\\n\\n    // --- ZKT issuance functions ---\\n\\n    function _triggerZKTIssuance(\\n        ICommunityIssuance _communityIssuance\\n    ) internal {\\n        uint256 ZKTIssuance = _communityIssuance.issueZKT();\\n        _updateG(ZKTIssuance);\\n    }\\n\\n    function _updateG(uint256 _ZKTIssuance) internal {\\n        uint256 totalZKUSD = totalZKUSDDeposits; // cached to save an SLOAD\\n        /*\\n         * When total deposits is 0, G is not updated. In this case, the ZKT issued can not be obtained by later\\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\\n         *\\n         */\\n        if (totalZKUSD == 0 || _ZKTIssuance == 0) {\\n            return;\\n        }\\n\\n        uint256 ZKTPerUnitStaked;\\n        ZKTPerUnitStaked = _computeZKTPerUnitStaked(_ZKTIssuance, totalZKUSD);\\n\\n        uint256 marginalZKTGain = ZKTPerUnitStaked.mul(P);\\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[\\n            currentEpoch\\n        ][currentScale].add(marginalZKTGain);\\n\\n        emit G_Updated(\\n            epochToScaleToG[currentEpoch][currentScale],\\n            currentEpoch,\\n            currentScale\\n        );\\n    }\\n\\n    function _computeZKTPerUnitStaked(\\n        uint256 _ZKTIssuance,\\n        uint256 _totalZKUSDDeposits\\n    ) internal returns (uint256) {\\n        /*\\n         * Calculate the ZKT-per-unit staked.  Division uses a \\\"feedback\\\" error correction, to keep the\\n         * cumulative error low in the running total G:\\n         *\\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratio.\\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store this error for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint256 ZKTNumerator = _ZKTIssuance.mul(DECIMAL_PRECISION).add(\\n            lastZKTError\\n        );\\n\\n        uint256 ZKTPerUnitStaked = ZKTNumerator.div(_totalZKUSDDeposits);\\n        lastZKTError = ZKTNumerator.sub(\\n            ZKTPerUnitStaked.mul(_totalZKUSDDeposits)\\n        );\\n\\n        return ZKTPerUnitStaked;\\n    }\\n\\n    // --- Liquidation functions ---\\n\\n    /*\\n     * Cancels out the specified debt against the ZKUSD contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's NEON collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(\\n        uint256 _debtToOffset,\\n        uint256 _collToAdd\\n    ) external override {\\n        _requireCallerIsTroveManager();\\n        uint256 totalZKUSD = totalZKUSDDeposits; // cached to save an SLOAD\\n        if (totalZKUSD == 0 || _debtToOffset == 0) {\\n            return;\\n        }\\n\\n        _triggerZKTIssuance(communityIssuance);\\n\\n        (\\n            uint256 NEONGainPerUnitStaked,\\n            uint256 ZKUSDLossPerUnitStaked\\n        ) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalZKUSD);\\n\\n        _updateRewardSumAndProduct(\\n            NEONGainPerUnitStaked,\\n            ZKUSDLossPerUnitStaked\\n        ); // updates S and P\\n\\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\\n    }\\n\\n    // --- Offset helper functions ---\\n\\n    function _computeRewardsPerUnitStaked(\\n        uint256 _collToAdd,\\n        uint256 _debtToOffset,\\n        uint256 _totalZKUSDDeposits\\n    )\\n        internal\\n        returns (uint256 NEONGainPerUnitStaked, uint256 ZKUSDLossPerUnitStaked)\\n    {\\n        /*\\n         * Compute the ZKUSD and NEON rewards. Uses a \\\"feedback\\\" error correction, to keep\\n         * the cumulative error in the P and S state variables low:\\n         *\\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratios.\\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store these errors for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint256 NEONNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(\\n            lastNEONError_Offset\\n        );\\n\\n        assert(_debtToOffset <= _totalZKUSDDeposits);\\n        if (_debtToOffset == _totalZKUSDDeposits) {\\n            ZKUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\\n            lastZKUSDLossError_Offset = 0;\\n        } else {\\n            uint256 ZKUSDLossNumerator = _debtToOffset\\n                .mul(DECIMAL_PRECISION)\\n                .sub(lastZKUSDLossError_Offset);\\n            /*\\n             * Add 1 to make error in quotient positive. We want \\\"slightly too much\\\" ZKUSD loss,\\n             * which ensures the error in any given compoundedZKUSDDeposit favors the Stability Pool.\\n             */\\n            ZKUSDLossPerUnitStaked = (\\n                ZKUSDLossNumerator.div(_totalZKUSDDeposits)\\n            ).add(1);\\n            lastZKUSDLossError_Offset = (\\n                ZKUSDLossPerUnitStaked.mul(_totalZKUSDDeposits)\\n            ).sub(ZKUSDLossNumerator);\\n        }\\n\\n        NEONGainPerUnitStaked = NEONNumerator.div(_totalZKUSDDeposits);\\n        lastNEONError_Offset = NEONNumerator.sub(\\n            NEONGainPerUnitStaked.mul(_totalZKUSDDeposits)\\n        );\\n\\n        return (NEONGainPerUnitStaked, ZKUSDLossPerUnitStaked);\\n    }\\n\\n    // Update the Stability Pool reward sum S and product P\\n    function _updateRewardSumAndProduct(\\n        uint256 _NEONGainPerUnitStaked,\\n        uint256 _ZKUSDLossPerUnitStaked\\n    ) internal {\\n        uint256 currentP = P;\\n        uint256 newP;\\n\\n        assert(_ZKUSDLossPerUnitStaked <= DECIMAL_PRECISION);\\n        /*\\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool ZKUSD in the liquidation.\\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - ZKUSDLossPerUnitStaked)\\n         */\\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(\\n            _ZKUSDLossPerUnitStaked\\n        );\\n\\n        uint256 currentScaleCached = currentScale;\\n        uint256 currentEpochCached = currentEpoch;\\n        uint256 currentS = epochToScaleToSum[currentEpochCached][\\n            currentScaleCached\\n        ];\\n\\n        /*\\n         * Calculate the new S first, before we update P.\\n         * The NEON gain for any given depositor from a liquidation depends on the value of their deposit\\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\\n         *\\n         * Since S corresponds to NEON gain, and P to deposit loss, we update S first.\\n         */\\n        uint256 marginalNEONGain = _NEONGainPerUnitStaked.mul(currentP);\\n        uint256 newS = currentS.add(marginalNEONGain);\\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\\n\\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\\n        if (newProductFactor == 0) {\\n            currentEpoch = currentEpochCached.add(1);\\n            emit EpochUpdated(currentEpoch);\\n            currentScale = 0;\\n            emit ScaleUpdated(currentScale);\\n            newP = DECIMAL_PRECISION;\\n\\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\\n        } else if (\\n            currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR\\n        ) {\\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(\\n                DECIMAL_PRECISION\\n            );\\n            currentScale = currentScaleCached.add(1);\\n            emit ScaleUpdated(currentScale);\\n        } else {\\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\\n        }\\n\\n        assert(newP > 0);\\n        P = newP;\\n\\n        emit P_Updated(newP);\\n    }\\n\\n    function _moveOffsetCollAndDebt(\\n        uint256 _collToAdd,\\n        uint256 _debtToOffset\\n    ) internal {\\n        IActivePool activePoolCached = activePool;\\n\\n        // Cancel the liquidated ZKUSD debt with the ZKUSD in the stability pool\\n        activePoolCached.decreaseZKUSDDebt(_debtToOffset);\\n        _decreaseZKUSD(_debtToOffset);\\n\\n        // Burn the debt that was successfully offset\\n        zkusdToken.burn(address(this), _debtToOffset);\\n\\n        activePoolCached.sendNEON(address(this), _collToAdd);\\n    }\\n\\n    function _decreaseZKUSD(uint256 _amount) internal {\\n        uint256 newTotalZKUSDDeposits = totalZKUSDDeposits.sub(_amount);\\n        totalZKUSDDeposits = newTotalZKUSDDeposits;\\n        emit StabilityPoolZKUSDBalanceUpdated(newTotalZKUSDDeposits);\\n    }\\n\\n    // --- Reward calculator functions for depositor and front end ---\\n\\n    /* Calculates the NEON gain earned by the deposit since its last snapshots were taken.\\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorNEONGain(\\n        address _depositor\\n    ) public view override returns (uint256) {\\n        uint256 initialDeposit = deposits[_depositor];\\n\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint256 NEONGain = _getNEONGainFromSnapshots(initialDeposit, snapshots);\\n        return NEONGain;\\n    }\\n\\n    function _getNEONGainFromSnapshots(\\n        uint256 initialDeposit,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint256) {\\n        /*\\n         * Grab the sum 'S' from the epoch at which the stake was made. The NEON gain may span up to one scale change.\\n         * If it does, the second portion of the NEON gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint256 epochSnapshot = snapshots.epoch;\\n        uint256 scaleSnapshot = snapshots.scale;\\n        uint256 S_Snapshot = snapshots.S;\\n        uint256 P_Snapshot = snapshots.P;\\n\\n        uint256 firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot]\\n            .sub(S_Snapshot);\\n        uint256 secondPortion = epochToScaleToSum[epochSnapshot][\\n            scaleSnapshot.add(1)\\n        ].div(SCALE_FACTOR);\\n\\n        uint256 NEONGain = initialDeposit\\n            .mul(firstPortion.add(secondPortion))\\n            .div(P_Snapshot)\\n            .div(DECIMAL_PRECISION);\\n\\n        return NEONGain;\\n    }\\n\\n    /*\\n     * Calculate the ZKT gain earned by a deposit since its last snapshots were taken.\\n     * Given by the formula:  ZKT = d0 * (G - G(0))/P(0)\\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorZKTGain(\\n        address _depositor\\n    ) public view override returns (uint256) {\\n        uint256 initialDeposit = deposits[_depositor];\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint256 ZKTGain = DefaultKickbackRate\\n            .mul(_getZKTGainFromSnapshots(initialDeposit, snapshots))\\n            .div(DECIMAL_PRECISION);\\n\\n        return ZKTGain;\\n    }\\n\\n    /*\\n     * Return the ZKT gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\\n     *\\n     * D0 is the last recorded value of the front end's total tagged deposits.\\n     */\\n    function getFrontEndZKTGain(\\n        address _frontEnd\\n    ) public view override returns (uint256) {\\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\\n        if (frontEndStake == 0) {\\n            return 0;\\n        }\\n\\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(\\n            DefaultKickbackRate\\n        );\\n\\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\\n\\n        uint256 ZKTGain = frontEndShare\\n            .mul(_getZKTGainFromSnapshots(frontEndStake, snapshots))\\n            .div(DECIMAL_PRECISION);\\n        return ZKTGain;\\n    }\\n\\n    function _getZKTGainFromSnapshots(\\n        uint256 initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint256) {\\n        /*\\n         * Grab the sum 'G' from the epoch at which the stake was made. The ZKT gain may span up to one scale change.\\n         * If it does, the second portion of the ZKT gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint256 epochSnapshot = snapshots.epoch;\\n        uint256 scaleSnapshot = snapshots.scale;\\n        uint256 G_Snapshot = snapshots.G;\\n        uint256 P_Snapshot = snapshots.P;\\n\\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot]\\n            .sub(G_Snapshot);\\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][\\n            scaleSnapshot.add(1)\\n        ].div(SCALE_FACTOR);\\n\\n        uint256 ZKTGain = initialStake\\n            .mul(firstPortion.add(secondPortion))\\n            .div(P_Snapshot)\\n            .div(DECIMAL_PRECISION);\\n\\n        return ZKTGain;\\n    }\\n\\n    // --- Compounded deposit and compounded front end stake ---\\n\\n    /*\\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\\n     */\\n    function getCompoundedZKUSDDeposit(\\n        address _depositor\\n    ) public view override returns (uint256) {\\n        uint256 initialDeposit = deposits[_depositor];\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(\\n            initialDeposit,\\n            snapshots\\n        );\\n        return compoundedDeposit;\\n    }\\n\\n    /*\\n     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\\n     * where P(0) is the depositor's snapshot of the product P, taken at the last time\\n     * when one of the front end's tagged deposits updated their deposit.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n    function getCompoundedFrontEndStake(\\n        address _frontEnd\\n    ) public view override returns (uint256) {\\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\\n        if (frontEndStake == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\\n\\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(\\n            frontEndStake,\\n            snapshots\\n        );\\n        return compoundedFrontEndStake;\\n    }\\n\\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\\n    function _getCompoundedStakeFromSnapshots(\\n        uint256 initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint256) {\\n        uint256 snapshot_P = snapshots.P;\\n        uint256 scaleSnapshot = snapshots.scale;\\n        uint256 epochSnapshot = snapshots.epoch;\\n\\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\\n        if (epochSnapshot < currentEpoch) {\\n            return 0;\\n        }\\n\\n        uint256 compoundedStake;\\n        uint256 scaleDiff = currentScale.sub(scaleSnapshot);\\n\\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\\n         * at least 1e-9 -- so return 0.\\n         */\\n        if (scaleDiff == 0) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\\n        } else if (scaleDiff == 1) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(\\n                SCALE_FACTOR\\n            );\\n        } else {\\n            // if scaleDiff >= 2\\n            compoundedStake = 0;\\n        }\\n\\n        /*\\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\\n         *\\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\\n         * corrections should ensure the error in P \\\"favors the Pool\\\", i.e. any given compounded deposit should slightly less\\n         * than it's theoretical value.\\n         *\\n         * Thus it's unclear whether this line is still really needed.\\n         */\\n        if (compoundedStake < initialStake.div(1e9)) {\\n            return 0;\\n        }\\n\\n        return compoundedStake;\\n    }\\n\\n    // --- Sender functions for ZKUSD deposit, NEON gains and ZKT gains ---\\n\\n    // Transfer the ZKUSD tokens from the user to the Stability Pool's address, and update its recorded ZKUSD\\n    function _sendZKUSDtoStabilityPool(\\n        address _address,\\n        uint256 _amount\\n    ) internal {\\n        zkusdToken.sendToPool(_address, address(this), _amount);\\n        uint256 newTotalZKUSDDeposits = totalZKUSDDeposits.add(_amount);\\n        totalZKUSDDeposits = newTotalZKUSDDeposits;\\n        emit StabilityPoolZKUSDBalanceUpdated(newTotalZKUSDDeposits);\\n    }\\n\\n    function _sendNEONGainToDepositor(uint256 _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n        uint256 newNEON = NEON.sub(_amount);\\n        NEON = newNEON;\\n        emit StabilityPoolNEONBalanceUpdated(newNEON);\\n        emit EtherSent(msg.sender, _amount);\\n\\n        (bool success, ) = msg.sender.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"StabilityPool: sending NEON failed\\\");\\n    }\\n\\n    // Send ZKUSD to user and decrease ZKUSD in Pool\\n    function _sendZKUSDToDepositor(\\n        address _depositor,\\n        uint256 ZKUSDWithdrawal\\n    ) internal {\\n        if (ZKUSDWithdrawal == 0) {\\n            return;\\n        }\\n\\n        zkusdToken.returnFromPool(address(this), _depositor, ZKUSDWithdrawal);\\n        _decreaseZKUSD(ZKUSDWithdrawal);\\n    }\\n\\n    // --- External Front End functions ---\\n\\n    function _updateDepositAndSnapshots(\\n        address _depositor,\\n        uint256 _newValue\\n    ) internal {\\n        deposits[_depositor] = _newValue;\\n\\n        if (_newValue == 0) {\\n            delete depositSnapshots[_depositor];\\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\\n            return;\\n        }\\n        uint256 currentScaleCached = currentScale;\\n        uint256 currentEpochCached = currentEpoch;\\n        uint256 currentP = P;\\n\\n        // Get S and G for the current epoch and current scale\\n        uint256 currentS = epochToScaleToSum[currentEpochCached][\\n            currentScaleCached\\n        ];\\n        uint256 currentG = epochToScaleToG[currentEpochCached][\\n            currentScaleCached\\n        ];\\n\\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\\n        depositSnapshots[_depositor].P = currentP;\\n        depositSnapshots[_depositor].S = currentS;\\n        depositSnapshots[_depositor].G = currentG;\\n        depositSnapshots[_depositor].scale = currentScaleCached;\\n        depositSnapshots[_depositor].epoch = currentEpochCached;\\n\\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\\n    }\\n\\n    function _updateFrontEndStakeAndSnapshots(\\n        address _frontEnd,\\n        uint256 _newValue\\n    ) internal {\\n        frontEndStakes[_frontEnd] = _newValue;\\n\\n        if (_newValue == 0) {\\n            delete frontEndSnapshots[_frontEnd];\\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\\n            return;\\n        }\\n\\n        uint256 currentScaleCached = currentScale;\\n        uint256 currentEpochCached = currentEpoch;\\n        uint256 currentP = P;\\n\\n        // Get G for the current epoch and current scale\\n        uint256 currentG = epochToScaleToG[currentEpochCached][\\n            currentScaleCached\\n        ];\\n\\n        // Record new snapshots of the latest running product P and sum G for the front end\\n        frontEndSnapshots[_frontEnd].P = currentP;\\n        frontEndSnapshots[_frontEnd].G = currentG;\\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\\n\\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\\n    }\\n\\n    function _payOutZKTGains(\\n        ICommunityIssuance _communityIssuance,\\n        address _depositor\\n    ) internal {\\n        // Pay out front end's ZKT gain\\n        uint256 frontEndZKTGain = getFrontEndZKTGain(_depositor);\\n        _communityIssuance.sendZKT(treasury, frontEndZKTGain);\\n        emit ZKTPaidToFrontEnd(treasury, frontEndZKTGain);\\n\\n        // Pay out depositor's ZKT gain\\n        uint256 depositorZKTGain = getDepositorZKTGain(_depositor);\\n        _communityIssuance.sendZKT(_depositor, depositorZKTGain);\\n        emit ZKTPaidToDepositor(_depositor, depositorZKTGain);\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsActivePool() internal view {\\n        require(\\n            msg.sender == address(activePool),\\n            \\\"StabilityPool: Caller is not ActivePool\\\"\\n        );\\n    }\\n\\n    function _requireCallerIsTroveManager() internal view {\\n        require(\\n            msg.sender == address(troveManager),\\n            \\\"StabilityPool: Caller is not TroveManager\\\"\\n        );\\n    }\\n\\n    function _requireNoUnderCollateralizedTroves() internal {\\n        uint256 price = priceFeed.fetchPrice();\\n        address lowestTrove = sortedTroves.getLast();\\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove, price);\\n        require(\\n            ICR >= MCR,\\n            \\\"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\\\"\\n        );\\n    }\\n\\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\\n        require(\\n            _initialDeposit > 0,\\n            \\\"StabilityPool: User must have a non-zero deposit\\\"\\n        );\\n    }\\n\\n    function _requireUserHasNoDeposit(address _address) internal view {\\n        uint256 initialDeposit = deposits[_address];\\n        require(\\n            initialDeposit == 0,\\n            \\\"StabilityPool: User must have no deposit\\\"\\n        );\\n    }\\n\\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\\n        require(_amount > 0, \\\"StabilityPool: Amount must be non-zero\\\");\\n    }\\n\\n    function _requireUserHasTrove(address _depositor) internal view {\\n        require(\\n            troveManager.getTroveStatus(_depositor) == 1,\\n            \\\"StabilityPool: caller must have an active trove to withdraw NEONGain to\\\"\\n        );\\n    }\\n\\n    function _requireUserHasNEONGain(address _depositor) internal view {\\n        uint256 NEONGain = getDepositorNEONGain(_depositor);\\n        require(\\n            NEONGain > 0,\\n            \\\"StabilityPool: caller must have non-zero NEON Gain\\\"\\n        );\\n    }\\n\\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\\n        require(\\n            _kickbackRate <= DECIMAL_PRECISION,\\n            \\\"StabilityPool: Kickback rate must be in range [0,1]\\\"\\n        );\\n    }\\n\\n    // --- Fallback function ---\\n\\n    receive() external payable {\\n        _requireCallerIsActivePool();\\n        NEON = NEON.add(msg.value);\\n        emit StabilityPoolNEONBalanceUpdated(NEON);\\n    }\\n}\\n\",\"keccak256\":\"0x10d8dafb926e65af073d7d2f5351f587b3add640cb10fdd5fb019a983382be0f\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526103e86200001c670de0b6b3a7640000600a620000d2565b620000289190620000f2565b6200003c90670de0b6b3a764000062000115565b600e55670de0b6b3a76400006011553480156200005857600080fd5b5062000064336200006a565b6200012b565b600380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b634e487b7160e01b600052601160045260246000fd5b8082028115828204841417620000ec57620000ec620000bc565b92915050565b6000826200011057634e487b7160e01b600052601260045260246000fd5b500490565b81810381811115620000ec57620000ec620000bc565b612fb9806200013b6000396000f3fe60806040526004361061032d5760003560e01c806385554c42116101a5578063aeafa414116100ec578063df9cd84f11610095578063f2fde38b1161006f578063f2fde38b14610998578063f92d3433146109b8578063fbf92d91146109cd578063fc7e286d146109e357600080fd5b8063df9cd84f14610920578063e681526314610940578063eb6b2fa61461096057600080fd5b8063d733cfd0116100c6578063d733cfd0146108cb578063daec271e146108eb578063dbd1e2661461090b57600080fd5b8063aeafa41414610876578063c192645b14610896578063ce4b5bbe146108b357600080fd5b806395fb16bb1161014e578063a4e59ac811610128578063a4e59ac814610820578063a7d7434f14610836578063ae9187541461085657600080fd5b806395fb16bb146107ba578063a20baee61461060f578063a3f4df7e146107da57600080fd5b80638b8fbd921161017f5780638b8fbd92146107715780638da5cb5b1461078757806393346319146107a557600080fd5b806385554c42146106f257806386da082414610712578063887105d31461075c57600080fd5b80635733d58f11610274578063741bef1a1161021d57806378c77a24116101f757806378c77a2414610681578063794e5724146106a1578063795d26c3146106bd5780637f7dde4a146106d257600080fd5b8063741bef1a1461062b578063766718081461064b57806377553ad41461066157600080fd5b806361d027b31161024e57806361d027b3146105da578063715018a6146105fa57806372fe25aa1461060f57600080fd5b80635733d58f146105595780635a0edf77146105755780635d2de642146105ad57600080fd5b806334178d36116102d65780633cc74225116102b05780633cc74225146105045780633d83908a146105245780634870dd9a1461054457600080fd5b806334178d361461049657806335a3f707146104ac57806336f08852146104e457600080fd5b80632e54bf95116103075780632e54bf951461043e5780632ee435bb14610460578063335525ad1461047657600080fd5b806315ec8d791461038657806316b9d3c5146103af5780631bf435551461042157600080fd5b366103815761033a610a10565b6009546103479034610a81565b60098190556040519081527f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a1005b600080fd5b34801561039257600080fd5b5061039c60175481565b6040519081526020015b60405180910390f35b3480156103bb57600080fd5b506103f96103ca366004612d5c565b601060205260009081526040902080546001820154600283015460038401546004909401549293919290919085565b604080519586526020860194909452928401919091526060830152608082015260a0016103a6565b34801561042d57600080fd5b5061039c6818650127cc3dc8000081565b34801561044a57600080fd5b5061045e610459366004612d80565b610a96565b005b34801561046c57600080fd5b5061039c60185481565b34801561048257600080fd5b5061045e610491366004612d99565b610c19565b3480156104a257600080fd5b5061039c600e5481565b3480156104b857600080fd5b506006546104cc906001600160a01b031681565b6040516001600160a01b0390911681526020016103a6565b3480156104f057600080fd5b5061045e6104ff366004612dbb565b610c7b565b34801561051057600080fd5b506001546104cc906001600160a01b031681565b34801561053057600080fd5b506005546104cc906001600160a01b031681565b34801561055057600080fd5b5061039c60c881565b34801561056557600080fd5b5061039c6714d1120d7b16000081565b34801561058157600080fd5b5061039c610590366004612d99565b601560209081526000928352604080842090915290825290205481565b3480156105b957600080fd5b5061039c6105c8366004612d5c565b600f6020526000908152604090205481565b3480156105e657600080fd5b50600d546104cc906001600160a01b031681565b34801561060657600080fd5b5061045e610eb3565b34801561061b57600080fd5b5061039c670de0b6b3a764000081565b34801561063757600080fd5b506002546104cc906001600160a01b031681565b34801561065757600080fd5b5061039c60135481565b34801561066d57600080fd5b506004546104cc906001600160a01b031681565b34801561068d57600080fd5b5061045e61069c366004612d80565b610ec5565b3480156106ad57600080fd5b5061039c670f43fc2c04ee000081565b3480156106c957600080fd5b5061039c61102b565b3480156106de57600080fd5b506000546104cc906001600160a01b031681565b3480156106fe57600080fd5b5061045e61070d366004612d80565b611127565b34801561071e57600080fd5b506103f961072d366004612d5c565b600c60205260009081526040902080546001820154600283015460038401546004909401549293919290919085565b34801561076857600080fd5b5061039c61118c565b34801561077d57600080fd5b5061039c60115481565b34801561079357600080fd5b506003546001600160a01b03166104cc565b3480156107b157600080fd5b5060095461039c565b3480156107c657600080fd5b506008546104cc906001600160a01b031681565b3480156107e657600080fd5b506108136040518060400160405280600d81526020016c14dd18589a5b1a5d1e541bdbdb609a1b81525081565b6040516103a69190612df4565b34801561082c57600080fd5b5061039c60125481565b34801561084257600080fd5b5061039c610851366004612d5c565b611251565b34801561086257600080fd5b506007546104cc906001600160a01b031681565b34801561088257600080fd5b5061039c610891366004612d5c565b6112e0565b3480156108a257600080fd5b5061039c6802b5e3af16b188000081565b3480156108bf57600080fd5b5061039c633b9aca0081565b3480156108d757600080fd5b5061045e6108e6366004612e42565b611384565b3480156108f757600080fd5b5061039c610906366004612d5c565b6115f6565b34801561091757600080fd5b50600a5461039c565b34801561092c57600080fd5b5061039c61093b366004612d5c565b61167c565b34801561094c57600080fd5b5061039c61095b366004612d5c565b611702565b34801561096c57600080fd5b5061039c61097b366004612d99565b601460209081526000928352604080842090915290825290205481565b3480156109a457600080fd5b5061045e6109b3366004612d5c565b6117c9565b3480156109c457600080fd5b5061039c611842565b3480156109d957600080fd5b5061039c60165481565b3480156109ef57600080fd5b5061039c6109fe366004612d5c565b600b6020526000908152604090205481565b6000546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820152602760248201527f53746162696c697479506f6f6c3a2043616c6c6572206973206e6f74204163746044820152661a5d99541bdbdb60ca1b60648201526084015b60405180910390fd5b565b6000610a8d8284612f01565b90505b92915050565b8015610aa457610aa4611864565b336000908152600b6020526040902054610abd81611a5c565b6008546001600160a01b0316610ad281611ad2565b6000610add336115f6565b90506000610aea33611251565b90506000610af88683611b47565b90506000610b068684611b5d565b9050610b128533611b69565b6000610b1d3361167c565b90506000610b2b8285611b5d565b9050610b373382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610b7c3385611e07565b6000610b888686611b5d565b9050610b943382611e88565b60405181815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2604080518881526020810186905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a2610c0d87611fd1565b50505050505050505050565b610c21612103565b600a54801580610c2f575082155b15610c3957505050565b600854610c4e906001600160a01b0316611ad2565b600080610c5c84868561216f565b91509150610c6a828261223d565b610c74848661249c565b5050505050565b336000908152600b6020526040902054610c9481611a5c565b610c9d336125ce565b610ca6336126c1565b6008546001600160a01b0316610cbb81611ad2565b6000610cc6336115f6565b90506000610cd333611251565b90506000610ce18583611b5d565b9050610ced8433611b69565b6000610cf83361167c565b905080610d053382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610d4a3385611e88565b604080518681526020810185905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a260405184815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2600954610dc79086611b5d565b60098190556040519081527f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a160408051338152602081018790527f6109e2559dfa766aaec7118351d48a523f0a4157f49c8d68749c8ac41318ad12910160405180910390a1600480546040516306b26c8760e21b815233928101929092526001600160a01b038b811660248401528a811660448401521690631ac9b21c9087906064016000604051808303818588803b158015610e8f57600080fd5b505af1158015610ea3573d6000803e3d6000fd5b5050505050505050505050505050565b610ebb612744565b610a7f600061279e565b610ece816127fd565b336000908152600b60205260409020546008546001600160a01b0316610ef381611ad2565b6000610efe336115f6565b90506000610f0b33611251565b90506000610f198583611b5d565b9050610f258433611b69565b6000610f303361167c565b90506000610f3e8289610a81565b9050610f4a3382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610f8f338961285c565b6000610f9b858a610a81565b9050610fa73382611e88565b60405181815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2604080518781526020810186905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a261102086611fd1565b505050505050505050565b600080546040805163512a9ebb60e01b8152905183926001600160a01b03169163512a9ebb9160048083019260209291908290030181865afa158015611075573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110999190612f14565b90506000600160009054906101000a90046001600160a01b03166001600160a01b031663512a9ebb6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111149190612f14565b90506111208282610a81565b9250505090565b61112f612744565b670de0b6b3a76400008111156111875760405162461bcd60e51b815260206004820152601160248201527f444543494d414c5f505245434953494f4e0000000000000000000000000000006044820152606401610a76565b600e55565b6000805460408051639334631960e01b8152905183926001600160a01b03169163933463199160048083019260209291908290030181865afa1580156111d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111fa9190612f14565b90506000600160009054906101000a90046001600160a01b03166001600160a01b031663933463196040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110f0573d6000803e3d6000fd5b6001600160a01b0381166000908152600b602052604081205480820361127a5750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612918565b95945050505050565b6001600160a01b0381166000908152600b60205260408120548082036113095750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d7670de0b6b3a764000061137e61137586866129e1565b600e5490612a97565b90612aa3565b61138c612744565b61139588612aaf565b61139e87612aaf565b6113a786612aaf565b6113b085612aaf565b6113b984612aaf565b6113c283612aaf565b6113cb82612aaf565b6004805473ffffffffffffffffffffffffffffffffffffffff199081166001600160a01b038b81169182179093556005805483168b85161790556000805483168a8516179055600680548316898516179055600780548316888516179055600280548316878516179055600880548316868516179055600d80549092169284169290921790556040519081527f3ca631ffcd2a9b5d9ae18543fc82f58eb4ca33af9e6ab01b7a8e95331e6ed9859060200160405180910390a16040516001600160a01b03881681527f143219c9e69b09e07e095fcc889b43d8f46ca892bba65f08dc3a0050869a56789060200160405180910390a16040516001600160a01b03871681527f78f058b189175430c48dc02699e3a0031ea4ff781536dc2fab847de4babdd8829060200160405180910390a16040516001600160a01b03861681527fbce04ccd812fbb02ec2145498f813470d7b7587b19477428388fe8201a1521319060200160405180910390a16040516001600160a01b03851681527f65f4cf077bc01e4742eb5ad98326f6e95b63548ea24b17f8d5e823111fe788009060200160405180910390a16040516001600160a01b03841681527f8c537274438aa850a330284665d81a85dd38267d09e4050d416bfc94142db2649060200160405180910390a16040516001600160a01b03831681527f3055265812fb8447b9ada4a5d804ec43bd528ec40e89c952bbc7b85dc5ac68119060200160405180910390a15050505050505050565b6001600160a01b0381166000908152600b602052604081205480820361161f5750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612b5c565b6001600160a01b0381166000908152600f60205260408120548082036116a55750600092915050565b6001600160a01b0383166000908152601060209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612918565b6001600160a01b0381166000908152600f602052604081205480820361172b5750600092915050565b600061174a600e54670de0b6b3a7640000611b5d90919063ffffffff16565b6001600160a01b0385166000908152601060209081526040808320815160a08101835281548152600182015493810193909352600281015491830191909152600381015460608301526004015460808201529192506117bf670de0b6b3a764000061137e6117b887866129e1565b8690612a97565b9695505050505050565b6117d1612744565b6001600160a01b0381166118365760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610a76565b61183f8161279e565b50565b6118566103e8670de0b6b3a7640000612f2d565b611861906005612f4f565b81565b60025460408051630fdb11cf60e01b815290516000926001600160a01b031691630fdb11cf916004808301926020929190829003018187875af11580156118af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d39190612f14565b90506000600760009054906101000a90046001600160a01b03166001600160a01b0316634d6228316040518163ffffffff1660e01b8152600401602060405180830381865afa15801561192a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194e9190612f66565b600554604051630d293c7160e41b81526001600160a01b038084166004830152602482018690529293506000929091169063d293c71090604401602060405180830381865afa1580156119a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119c99190612f14565b9050670f43fc2c04ee0000811015611a575760405162461bcd60e51b8152602060048201526044602482018190527f53746162696c697479506f6f6c3a2043616e6e6f742077697468647261772077908201527f68696c65207468657265206172652074726f766573207769746820494352203c6064820152631026a1a960e11b608482015260a401610a76565b505050565b6000811161183f5760405162461bcd60e51b815260206004820152603060248201527f53746162696c697479506f6f6c3a2055736572206d757374206861766520612060448201527f6e6f6e2d7a65726f206465706f736974000000000000000000000000000000006064820152608401610a76565b6000816001600160a01b031663a9d394806040518163ffffffff1660e01b81526004016020604051808303816000875af1158015611b14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b389190612f14565b9050611b4381612bbf565b5050565b6000818310611b565781610a8d565b5090919050565b6000610a8d8284612f83565b6000611b7482611702565b600d54604051630e04ac8f60e11b81526001600160a01b03918216600482015260248101839052919250841690631c09591e90604401600060405180830381600087803b158015611bc457600080fd5b505af1158015611bd8573d6000803e3d6000fd5b5050600d546040518481526001600160a01b0390911692507f1b5a24a60494bc3156f87c622d15f9e3fe9afe48f3bad341f020203480721844915060200160405180910390a26000611c29836112e0565b604051630e04ac8f60e11b81526001600160a01b0385811660048301526024820183905291925090851690631c09591e90604401600060405180830381600087803b158015611c7757600080fd5b505af1158015611c8b573d6000803e3d6000fd5b50505050826001600160a01b03167f2100cd07c3a49fa04dd1d90e15284b0b70b3b84a05d9486b474a2a51e631bf0682604051611cca91815260200190565b60405180910390a250505050565b6001600160a01b0382166000908152600f60205260408120829055819003611d74576001600160a01b038216600081815260106020526040808220828155600181018390556002810183905560038101839055600401829055517fbb1322f85cc7cc8bac4e172a5bc5dcc0c1959007f9a030032abf9258205f0e4591611d68918190918252602082015260400190565b60405180910390a25050565b60125460135460115460008281526015602090815260408083208684528252808320546001600160a01b0389168085526010845293829020600181018690556002810182905560038101889055600401869055815185815292830181905292917fbb1322f85cc7cc8bac4e172a5bc5dcc0c1959007f9a030032abf9258205f0e45910160405180910390a2505050505050565b80600003611e13575050565b600654604051631062c15f60e11b81523060048201526001600160a01b03848116602483015260448201849052909116906320c582be90606401600060405180830381600087803b158015611e6757600080fd5b505af1158015611e7b573d6000803e3d6000fd5b50505050611b4381612ca5565b6001600160a01b0382166000908152600b60205260408120829055819003611f1e576001600160a01b0382166000818152600c6020908152604080832083815560018101849055600281018490556003810184905560040183905580518381529182018390528101919091527f2d6cc0bcdf72c9486f6451bde6b80f44066f4558f77f44dbfedbe7d8b295225a90606001611d68565b6012546013546011546000828152601460209081526040808320868452825280832054858452601583528184208785528352818420546001600160a01b038a16808652600c85529483902060018101879055828155600281018290556003810189905560040187905582518681529384018290529183018290529290917f2d6cc0bcdf72c9486f6451bde6b80f44066f4558f77f44dbfedbe7d8b295225a9060600160405180910390a250505050505050565b80600003611fdc5750565b600954600090611fec9083611b5d565b60098190556040518181529091507f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a160408051338152602081018490527f6109e2559dfa766aaec7118351d48a523f0a4157f49c8d68749c8ac41318ad12910160405180910390a1604051600090339084908381818185875af1925050503d80600081146120a2576040519150601f19603f3d011682016040523d82523d6000602084013e6120a7565b606091505b5050905080611a575760405162461bcd60e51b815260206004820152602260248201527f53746162696c697479506f6f6c3a2073656e64696e67204e454f4e206661696c604482015261195960f21b6064820152608401610a76565b6005546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820152602960248201527f53746162696c697479506f6f6c3a2043616c6c6572206973206e6f742054726f6044820152683b32a6b0b730b3b2b960b91b6064820152608401610a76565b600080600061219b601754612195670de0b6b3a764000089612a9790919063ffffffff16565b90610a81565b9050838511156121ad576121ad612f96565b8385036121c9576000601855670de0b6b3a76400009150612211565b6018546000906121eb906121e588670de0b6b3a7640000612a97565b90611b5d565b90506121fc60016121958388612aa3565b925061220c816121e58588612a97565b601855505b61221b8185612aa3565b925061223161222a8486612a97565b8290611b5d565b60175550935093915050565b6011546000670de0b6b3a764000083111561225a5761225a612f96565b600061226e670de0b6b3a764000085611b5d565b60125460135460008181526014602090815260408083208584529091528120549394509192909161229f8988612a97565b905060006122ad8383610a81565b600085815260146020908152604080832089845282529182902083905581518381529081018790529081018790529091507ff258cb8cfa272c0e6630207ad61a9e61acc2a2c4e24ab2500f9d47028f877d109060600160405180910390a1856000036123a05761231e846001610a81565b60138190556040519081527fb33a1f54dde4e0082c45281b338d78b2c4b5be163b6ffffa5d0d6d1050ba5a589060200160405180910390a1600060128190556040519081527f3bed654efb708b58f2d77966f880bd1798be286fdd36983d20cbf0897e186c6e9060200160405180910390a1670de0b6b3a76400009650612448565b633b9aca006123bb670de0b6b3a764000061137e8b8a612a97565b101561242f576123e5670de0b6b3a764000061137e633b9aca006123df8c8b612a97565b90612a97565b96506123f2856001610a81565b60128190556040519081527f3bed654efb708b58f2d77966f880bd1798be286fdd36983d20cbf0897e186c6e9060200160405180910390a1612448565b612445670de0b6b3a764000061137e8a89612a97565b96505b6000871161245857612458612f96565b60118790556040518781527fc1a9618cb59ebca77cbdbc2949f126823c407ff13edb285fd0262519a9c18e8c9060200160405180910390a150505050505050505050565b6000546040516305af902160e31b8152600481018390526001600160a01b03909116908190632d7c810890602401600060405180830381600087803b1580156124e457600080fd5b505af11580156124f8573d6000803e3d6000fd5b5050505061250582612ca5565b600654604051632770a7eb60e21b8152306004820152602481018490526001600160a01b0390911690639dc29fac90604401600060405180830381600087803b15801561255157600080fd5b505af1158015612565573d6000803e3d6000fd5b50506040516373333ae560e11b8152306004820152602481018690526001600160a01b038416925063e66675ca9150604401600060405180830381600087803b1580156125b157600080fd5b505af11580156125c5573d6000803e3d6000fd5b50505050505050565b6005546040516321e3780160e01b81526001600160a01b038381166004830152909116906321e3780190602401602060405180830381865afa158015612618573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061263c9190612f14565b60011461183f5760405162461bcd60e51b815260206004820152604760248201527f53746162696c697479506f6f6c3a2063616c6c6572206d75737420686176652060448201527f616e206163746976652074726f766520746f207769746864726177204e454f4e6064820152664761696e20746f60c81b608482015260a401610a76565b60006126cc826115f6565b905060008111611b435760405162461bcd60e51b815260206004820152603260248201527f53746162696c697479506f6f6c3a2063616c6c6572206d75737420686176652060448201527f6e6f6e2d7a65726f204e454f4e204761696e00000000000000000000000000006064820152608401610a76565b6003546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610a76565b600380546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6000811161183f5760405162461bcd60e51b815260206004820152602660248201527f53746162696c697479506f6f6c3a20416d6f756e74206d757374206265206e6f6044820152656e2d7a65726f60d01b6064820152608401610a76565b600654604051632ee65eeb60e21b81526001600160a01b038481166004830152306024830152604482018490529091169063bb997bac90606401600060405180830381600087803b1580156128b057600080fd5b505af11580156128c4573d6000803e3d6000fd5b5050600a54600092506128d8915083610a81565b600a8190556040518181529091507fc5ee6fb858a22859c568a103df828f481b378a432ae4e0a5cbc076430130bdb29060200160405180910390a1505050565b6020810151606082015160808301516013546000939291908110156129435760009350505050610a90565b60008061295b84601254611b5d90919063ffffffff16565b9050806000036129855761297e8561137e6011548b612a9790919063ffffffff16565b91506129b3565b806001036129ae5761297e633b9aca0061137e8761137e6011548d612a9790919063ffffffff16565b600091505b6129c188633b9aca00612aa3565b8210156129d657600095505050505050610a90565b509695505050505050565b608081015160608201516040808401516020808601516000868152601583528481208682529092529281205490949392908590612a1e9084611b5d565b600086815260156020526040812091925090612a6390633b9aca009083612a46896001610a81565b815260200190815260200160002054612aa390919063ffffffff16565b90506000612a89670de0b6b3a764000061137e8681612a828888610a81565b8f90612a97565b9a9950505050505050505050565b6000610a8d8284612f4f565b6000610a8d8284612f2d565b6001600160a01b038116612b055760405162461bcd60e51b815260206004820152601e60248201527f4163636f756e742063616e6e6f74206265207a65726f206164647265737300006044820152606401610a76565b6001600160a01b0381163b61183f5760405162461bcd60e51b815260206004820181905260248201527f4163636f756e7420636f64652073697a652063616e6e6f74206265207a65726f6044820152606401610a76565b60808101516060820151825160208085015160008581526014835260408082208683529093529182205491949392918590612b979084611b5d565b600086815260146020526040812091925090612a6390633b9aca009083612a46896001610a81565b600a54801580612bcd575081155b15612bd6575050565b6000612be28383612cf4565b90506000612bfb60115483612a9790919063ffffffff16565b60135460009081526015602090815260408083206012548452909152902054909150612c279082610a81565b6013805460009081526015602081815260408084206012805486529083528185209690965593548084529181528383209454808452948152918390205483519081529182015280820192909252517ff183c509dedcdb1c9bd9cdcbf39fa395eedecb48f9666dcef9da50f7f2084e529181900360600190a150505050565b600a54600090612cb59083611b5d565b600a8190556040518181529091507fc5ee6fb858a22859c568a103df828f481b378a432ae4e0a5cbc076430130bdb29060200160405180910390a15050565b600080612d18601654612195670de0b6b3a764000087612a9790919063ffffffff16565b90506000612d268285612aa3565b9050612d3c612d358286612a97565b8390611b5d565b601655949350505050565b6001600160a01b038116811461183f57600080fd5b600060208284031215612d6e57600080fd5b8135612d7981612d47565b9392505050565b600060208284031215612d9257600080fd5b5035919050565b60008060408385031215612dac57600080fd5b50508035926020909101359150565b60008060408385031215612dce57600080fd5b8235612dd981612d47565b91506020830135612de981612d47565b809150509250929050565b600060208083528351808285015260005b81811015612e2157858101830151858201604001528201612e05565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600080600080610100898b031215612e5f57600080fd5b8835612e6a81612d47565b97506020890135612e7a81612d47565b96506040890135612e8a81612d47565b95506060890135612e9a81612d47565b94506080890135612eaa81612d47565b935060a0890135612eba81612d47565b925060c0890135612eca81612d47565b915060e0890135612eda81612d47565b809150509295985092959890939650565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a9057610a90612eeb565b600060208284031215612f2657600080fd5b5051919050565b600082612f4a57634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417610a9057610a90612eeb565b600060208284031215612f7857600080fd5b8151612d7981612d47565b81810381811115610a9057610a90612eeb565b634e487b7160e01b600052600160045260246000fdfea164736f6c6343000811000a",
  "deployedBytecode": "0x60806040526004361061032d5760003560e01c806385554c42116101a5578063aeafa414116100ec578063df9cd84f11610095578063f2fde38b1161006f578063f2fde38b14610998578063f92d3433146109b8578063fbf92d91146109cd578063fc7e286d146109e357600080fd5b8063df9cd84f14610920578063e681526314610940578063eb6b2fa61461096057600080fd5b8063d733cfd0116100c6578063d733cfd0146108cb578063daec271e146108eb578063dbd1e2661461090b57600080fd5b8063aeafa41414610876578063c192645b14610896578063ce4b5bbe146108b357600080fd5b806395fb16bb1161014e578063a4e59ac811610128578063a4e59ac814610820578063a7d7434f14610836578063ae9187541461085657600080fd5b806395fb16bb146107ba578063a20baee61461060f578063a3f4df7e146107da57600080fd5b80638b8fbd921161017f5780638b8fbd92146107715780638da5cb5b1461078757806393346319146107a557600080fd5b806385554c42146106f257806386da082414610712578063887105d31461075c57600080fd5b80635733d58f11610274578063741bef1a1161021d57806378c77a24116101f757806378c77a2414610681578063794e5724146106a1578063795d26c3146106bd5780637f7dde4a146106d257600080fd5b8063741bef1a1461062b578063766718081461064b57806377553ad41461066157600080fd5b806361d027b31161024e57806361d027b3146105da578063715018a6146105fa57806372fe25aa1461060f57600080fd5b80635733d58f146105595780635a0edf77146105755780635d2de642146105ad57600080fd5b806334178d36116102d65780633cc74225116102b05780633cc74225146105045780633d83908a146105245780634870dd9a1461054457600080fd5b806334178d361461049657806335a3f707146104ac57806336f08852146104e457600080fd5b80632e54bf95116103075780632e54bf951461043e5780632ee435bb14610460578063335525ad1461047657600080fd5b806315ec8d791461038657806316b9d3c5146103af5780631bf435551461042157600080fd5b366103815761033a610a10565b6009546103479034610a81565b60098190556040519081527f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a1005b600080fd5b34801561039257600080fd5b5061039c60175481565b6040519081526020015b60405180910390f35b3480156103bb57600080fd5b506103f96103ca366004612d5c565b601060205260009081526040902080546001820154600283015460038401546004909401549293919290919085565b604080519586526020860194909452928401919091526060830152608082015260a0016103a6565b34801561042d57600080fd5b5061039c6818650127cc3dc8000081565b34801561044a57600080fd5b5061045e610459366004612d80565b610a96565b005b34801561046c57600080fd5b5061039c60185481565b34801561048257600080fd5b5061045e610491366004612d99565b610c19565b3480156104a257600080fd5b5061039c600e5481565b3480156104b857600080fd5b506006546104cc906001600160a01b031681565b6040516001600160a01b0390911681526020016103a6565b3480156104f057600080fd5b5061045e6104ff366004612dbb565b610c7b565b34801561051057600080fd5b506001546104cc906001600160a01b031681565b34801561053057600080fd5b506005546104cc906001600160a01b031681565b34801561055057600080fd5b5061039c60c881565b34801561056557600080fd5b5061039c6714d1120d7b16000081565b34801561058157600080fd5b5061039c610590366004612d99565b601560209081526000928352604080842090915290825290205481565b3480156105b957600080fd5b5061039c6105c8366004612d5c565b600f6020526000908152604090205481565b3480156105e657600080fd5b50600d546104cc906001600160a01b031681565b34801561060657600080fd5b5061045e610eb3565b34801561061b57600080fd5b5061039c670de0b6b3a764000081565b34801561063757600080fd5b506002546104cc906001600160a01b031681565b34801561065757600080fd5b5061039c60135481565b34801561066d57600080fd5b506004546104cc906001600160a01b031681565b34801561068d57600080fd5b5061045e61069c366004612d80565b610ec5565b3480156106ad57600080fd5b5061039c670f43fc2c04ee000081565b3480156106c957600080fd5b5061039c61102b565b3480156106de57600080fd5b506000546104cc906001600160a01b031681565b3480156106fe57600080fd5b5061045e61070d366004612d80565b611127565b34801561071e57600080fd5b506103f961072d366004612d5c565b600c60205260009081526040902080546001820154600283015460038401546004909401549293919290919085565b34801561076857600080fd5b5061039c61118c565b34801561077d57600080fd5b5061039c60115481565b34801561079357600080fd5b506003546001600160a01b03166104cc565b3480156107b157600080fd5b5060095461039c565b3480156107c657600080fd5b506008546104cc906001600160a01b031681565b3480156107e657600080fd5b506108136040518060400160405280600d81526020016c14dd18589a5b1a5d1e541bdbdb609a1b81525081565b6040516103a69190612df4565b34801561082c57600080fd5b5061039c60125481565b34801561084257600080fd5b5061039c610851366004612d5c565b611251565b34801561086257600080fd5b506007546104cc906001600160a01b031681565b34801561088257600080fd5b5061039c610891366004612d5c565b6112e0565b3480156108a257600080fd5b5061039c6802b5e3af16b188000081565b3480156108bf57600080fd5b5061039c633b9aca0081565b3480156108d757600080fd5b5061045e6108e6366004612e42565b611384565b3480156108f757600080fd5b5061039c610906366004612d5c565b6115f6565b34801561091757600080fd5b50600a5461039c565b34801561092c57600080fd5b5061039c61093b366004612d5c565b61167c565b34801561094c57600080fd5b5061039c61095b366004612d5c565b611702565b34801561096c57600080fd5b5061039c61097b366004612d99565b601460209081526000928352604080842090915290825290205481565b3480156109a457600080fd5b5061045e6109b3366004612d5c565b6117c9565b3480156109c457600080fd5b5061039c611842565b3480156109d957600080fd5b5061039c60165481565b3480156109ef57600080fd5b5061039c6109fe366004612d5c565b600b6020526000908152604090205481565b6000546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820152602760248201527f53746162696c697479506f6f6c3a2043616c6c6572206973206e6f74204163746044820152661a5d99541bdbdb60ca1b60648201526084015b60405180910390fd5b565b6000610a8d8284612f01565b90505b92915050565b8015610aa457610aa4611864565b336000908152600b6020526040902054610abd81611a5c565b6008546001600160a01b0316610ad281611ad2565b6000610add336115f6565b90506000610aea33611251565b90506000610af88683611b47565b90506000610b068684611b5d565b9050610b128533611b69565b6000610b1d3361167c565b90506000610b2b8285611b5d565b9050610b373382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610b7c3385611e07565b6000610b888686611b5d565b9050610b943382611e88565b60405181815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2604080518881526020810186905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a2610c0d87611fd1565b50505050505050505050565b610c21612103565b600a54801580610c2f575082155b15610c3957505050565b600854610c4e906001600160a01b0316611ad2565b600080610c5c84868561216f565b91509150610c6a828261223d565b610c74848661249c565b5050505050565b336000908152600b6020526040902054610c9481611a5c565b610c9d336125ce565b610ca6336126c1565b6008546001600160a01b0316610cbb81611ad2565b6000610cc6336115f6565b90506000610cd333611251565b90506000610ce18583611b5d565b9050610ced8433611b69565b6000610cf83361167c565b905080610d053382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610d4a3385611e88565b604080518681526020810185905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a260405184815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2600954610dc79086611b5d565b60098190556040519081527f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a160408051338152602081018790527f6109e2559dfa766aaec7118351d48a523f0a4157f49c8d68749c8ac41318ad12910160405180910390a1600480546040516306b26c8760e21b815233928101929092526001600160a01b038b811660248401528a811660448401521690631ac9b21c9087906064016000604051808303818588803b158015610e8f57600080fd5b505af1158015610ea3573d6000803e3d6000fd5b5050505050505050505050505050565b610ebb612744565b610a7f600061279e565b610ece816127fd565b336000908152600b60205260409020546008546001600160a01b0316610ef381611ad2565b6000610efe336115f6565b90506000610f0b33611251565b90506000610f198583611b5d565b9050610f258433611b69565b6000610f303361167c565b90506000610f3e8289610a81565b9050610f4a3382611cd8565b604080518281523360208201819052917f99920012339b5a3368d3a04b8606ce412c46ed92b7dcd8602d41fc8862cb8f25910160405180910390a2610f8f338961285c565b6000610f9b858a610a81565b9050610fa73382611e88565b60405181815233907fbce78369dccab09eec1986f4d409ab09ffbb47d65423e5148fcf98411c5111c99060200160405180910390a2604080518781526020810186905233917fa184c2a23328c4d34e34c78db11f79e4637ea59c07338e5a8dcb5e292b1580f8910160405180910390a261102086611fd1565b505050505050505050565b600080546040805163512a9ebb60e01b8152905183926001600160a01b03169163512a9ebb9160048083019260209291908290030181865afa158015611075573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110999190612f14565b90506000600160009054906101000a90046001600160a01b03166001600160a01b031663512a9ebb6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111149190612f14565b90506111208282610a81565b9250505090565b61112f612744565b670de0b6b3a76400008111156111875760405162461bcd60e51b815260206004820152601160248201527f444543494d414c5f505245434953494f4e0000000000000000000000000000006044820152606401610a76565b600e55565b6000805460408051639334631960e01b8152905183926001600160a01b03169163933463199160048083019260209291908290030181865afa1580156111d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111fa9190612f14565b90506000600160009054906101000a90046001600160a01b03166001600160a01b031663933463196040518163ffffffff1660e01b8152600401602060405180830381865afa1580156110f0573d6000803e3d6000fd5b6001600160a01b0381166000908152600b602052604081205480820361127a5750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612918565b95945050505050565b6001600160a01b0381166000908152600b60205260408120548082036113095750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d7670de0b6b3a764000061137e61137586866129e1565b600e5490612a97565b90612aa3565b61138c612744565b61139588612aaf565b61139e87612aaf565b6113a786612aaf565b6113b085612aaf565b6113b984612aaf565b6113c283612aaf565b6113cb82612aaf565b6004805473ffffffffffffffffffffffffffffffffffffffff199081166001600160a01b038b81169182179093556005805483168b85161790556000805483168a8516179055600680548316898516179055600780548316888516179055600280548316878516179055600880548316868516179055600d80549092169284169290921790556040519081527f3ca631ffcd2a9b5d9ae18543fc82f58eb4ca33af9e6ab01b7a8e95331e6ed9859060200160405180910390a16040516001600160a01b03881681527f143219c9e69b09e07e095fcc889b43d8f46ca892bba65f08dc3a0050869a56789060200160405180910390a16040516001600160a01b03871681527f78f058b189175430c48dc02699e3a0031ea4ff781536dc2fab847de4babdd8829060200160405180910390a16040516001600160a01b03861681527fbce04ccd812fbb02ec2145498f813470d7b7587b19477428388fe8201a1521319060200160405180910390a16040516001600160a01b03851681527f65f4cf077bc01e4742eb5ad98326f6e95b63548ea24b17f8d5e823111fe788009060200160405180910390a16040516001600160a01b03841681527f8c537274438aa850a330284665d81a85dd38267d09e4050d416bfc94142db2649060200160405180910390a16040516001600160a01b03831681527f3055265812fb8447b9ada4a5d804ec43bd528ec40e89c952bbc7b85dc5ac68119060200160405180910390a15050505050505050565b6001600160a01b0381166000908152600b602052604081205480820361161f5750600092915050565b6001600160a01b0383166000908152600c60209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612b5c565b6001600160a01b0381166000908152600f60205260408120548082036116a55750600092915050565b6001600160a01b0383166000908152601060209081526040808320815160a0810183528154815260018201549381019390935260028101549183019190915260038101546060830152600401546080820152906112d78383612918565b6001600160a01b0381166000908152600f602052604081205480820361172b5750600092915050565b600061174a600e54670de0b6b3a7640000611b5d90919063ffffffff16565b6001600160a01b0385166000908152601060209081526040808320815160a08101835281548152600182015493810193909352600281015491830191909152600381015460608301526004015460808201529192506117bf670de0b6b3a764000061137e6117b887866129e1565b8690612a97565b9695505050505050565b6117d1612744565b6001600160a01b0381166118365760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610a76565b61183f8161279e565b50565b6118566103e8670de0b6b3a7640000612f2d565b611861906005612f4f565b81565b60025460408051630fdb11cf60e01b815290516000926001600160a01b031691630fdb11cf916004808301926020929190829003018187875af11580156118af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118d39190612f14565b90506000600760009054906101000a90046001600160a01b03166001600160a01b0316634d6228316040518163ffffffff1660e01b8152600401602060405180830381865afa15801561192a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194e9190612f66565b600554604051630d293c7160e41b81526001600160a01b038084166004830152602482018690529293506000929091169063d293c71090604401602060405180830381865afa1580156119a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119c99190612f14565b9050670f43fc2c04ee0000811015611a575760405162461bcd60e51b8152602060048201526044602482018190527f53746162696c697479506f6f6c3a2043616e6e6f742077697468647261772077908201527f68696c65207468657265206172652074726f766573207769746820494352203c6064820152631026a1a960e11b608482015260a401610a76565b505050565b6000811161183f5760405162461bcd60e51b815260206004820152603060248201527f53746162696c697479506f6f6c3a2055736572206d757374206861766520612060448201527f6e6f6e2d7a65726f206465706f736974000000000000000000000000000000006064820152608401610a76565b6000816001600160a01b031663a9d394806040518163ffffffff1660e01b81526004016020604051808303816000875af1158015611b14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b389190612f14565b9050611b4381612bbf565b5050565b6000818310611b565781610a8d565b5090919050565b6000610a8d8284612f83565b6000611b7482611702565b600d54604051630e04ac8f60e11b81526001600160a01b03918216600482015260248101839052919250841690631c09591e90604401600060405180830381600087803b158015611bc457600080fd5b505af1158015611bd8573d6000803e3d6000fd5b5050600d546040518481526001600160a01b0390911692507f1b5a24a60494bc3156f87c622d15f9e3fe9afe48f3bad341f020203480721844915060200160405180910390a26000611c29836112e0565b604051630e04ac8f60e11b81526001600160a01b0385811660048301526024820183905291925090851690631c09591e90604401600060405180830381600087803b158015611c7757600080fd5b505af1158015611c8b573d6000803e3d6000fd5b50505050826001600160a01b03167f2100cd07c3a49fa04dd1d90e15284b0b70b3b84a05d9486b474a2a51e631bf0682604051611cca91815260200190565b60405180910390a250505050565b6001600160a01b0382166000908152600f60205260408120829055819003611d74576001600160a01b038216600081815260106020526040808220828155600181018390556002810183905560038101839055600401829055517fbb1322f85cc7cc8bac4e172a5bc5dcc0c1959007f9a030032abf9258205f0e4591611d68918190918252602082015260400190565b60405180910390a25050565b60125460135460115460008281526015602090815260408083208684528252808320546001600160a01b0389168085526010845293829020600181018690556002810182905560038101889055600401869055815185815292830181905292917fbb1322f85cc7cc8bac4e172a5bc5dcc0c1959007f9a030032abf9258205f0e45910160405180910390a2505050505050565b80600003611e13575050565b600654604051631062c15f60e11b81523060048201526001600160a01b03848116602483015260448201849052909116906320c582be90606401600060405180830381600087803b158015611e6757600080fd5b505af1158015611e7b573d6000803e3d6000fd5b50505050611b4381612ca5565b6001600160a01b0382166000908152600b60205260408120829055819003611f1e576001600160a01b0382166000818152600c6020908152604080832083815560018101849055600281018490556003810184905560040183905580518381529182018390528101919091527f2d6cc0bcdf72c9486f6451bde6b80f44066f4558f77f44dbfedbe7d8b295225a90606001611d68565b6012546013546011546000828152601460209081526040808320868452825280832054858452601583528184208785528352818420546001600160a01b038a16808652600c85529483902060018101879055828155600281018290556003810189905560040187905582518681529384018290529183018290529290917f2d6cc0bcdf72c9486f6451bde6b80f44066f4558f77f44dbfedbe7d8b295225a9060600160405180910390a250505050505050565b80600003611fdc5750565b600954600090611fec9083611b5d565b60098190556040518181529091507f811b7ed7711f0ba505cb26488475859e4ad0abac3249fd69ed3345e854dd07089060200160405180910390a160408051338152602081018490527f6109e2559dfa766aaec7118351d48a523f0a4157f49c8d68749c8ac41318ad12910160405180910390a1604051600090339084908381818185875af1925050503d80600081146120a2576040519150601f19603f3d011682016040523d82523d6000602084013e6120a7565b606091505b5050905080611a575760405162461bcd60e51b815260206004820152602260248201527f53746162696c697479506f6f6c3a2073656e64696e67204e454f4e206661696c604482015261195960f21b6064820152608401610a76565b6005546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820152602960248201527f53746162696c697479506f6f6c3a2043616c6c6572206973206e6f742054726f6044820152683b32a6b0b730b3b2b960b91b6064820152608401610a76565b600080600061219b601754612195670de0b6b3a764000089612a9790919063ffffffff16565b90610a81565b9050838511156121ad576121ad612f96565b8385036121c9576000601855670de0b6b3a76400009150612211565b6018546000906121eb906121e588670de0b6b3a7640000612a97565b90611b5d565b90506121fc60016121958388612aa3565b925061220c816121e58588612a97565b601855505b61221b8185612aa3565b925061223161222a8486612a97565b8290611b5d565b60175550935093915050565b6011546000670de0b6b3a764000083111561225a5761225a612f96565b600061226e670de0b6b3a764000085611b5d565b60125460135460008181526014602090815260408083208584529091528120549394509192909161229f8988612a97565b905060006122ad8383610a81565b600085815260146020908152604080832089845282529182902083905581518381529081018790529081018790529091507ff258cb8cfa272c0e6630207ad61a9e61acc2a2c4e24ab2500f9d47028f877d109060600160405180910390a1856000036123a05761231e846001610a81565b60138190556040519081527fb33a1f54dde4e0082c45281b338d78b2c4b5be163b6ffffa5d0d6d1050ba5a589060200160405180910390a1600060128190556040519081527f3bed654efb708b58f2d77966f880bd1798be286fdd36983d20cbf0897e186c6e9060200160405180910390a1670de0b6b3a76400009650612448565b633b9aca006123bb670de0b6b3a764000061137e8b8a612a97565b101561242f576123e5670de0b6b3a764000061137e633b9aca006123df8c8b612a97565b90612a97565b96506123f2856001610a81565b60128190556040519081527f3bed654efb708b58f2d77966f880bd1798be286fdd36983d20cbf0897e186c6e9060200160405180910390a1612448565b612445670de0b6b3a764000061137e8a89612a97565b96505b6000871161245857612458612f96565b60118790556040518781527fc1a9618cb59ebca77cbdbc2949f126823c407ff13edb285fd0262519a9c18e8c9060200160405180910390a150505050505050505050565b6000546040516305af902160e31b8152600481018390526001600160a01b03909116908190632d7c810890602401600060405180830381600087803b1580156124e457600080fd5b505af11580156124f8573d6000803e3d6000fd5b5050505061250582612ca5565b600654604051632770a7eb60e21b8152306004820152602481018490526001600160a01b0390911690639dc29fac90604401600060405180830381600087803b15801561255157600080fd5b505af1158015612565573d6000803e3d6000fd5b50506040516373333ae560e11b8152306004820152602481018690526001600160a01b038416925063e66675ca9150604401600060405180830381600087803b1580156125b157600080fd5b505af11580156125c5573d6000803e3d6000fd5b50505050505050565b6005546040516321e3780160e01b81526001600160a01b038381166004830152909116906321e3780190602401602060405180830381865afa158015612618573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061263c9190612f14565b60011461183f5760405162461bcd60e51b815260206004820152604760248201527f53746162696c697479506f6f6c3a2063616c6c6572206d75737420686176652060448201527f616e206163746976652074726f766520746f207769746864726177204e454f4e6064820152664761696e20746f60c81b608482015260a401610a76565b60006126cc826115f6565b905060008111611b435760405162461bcd60e51b815260206004820152603260248201527f53746162696c697479506f6f6c3a2063616c6c6572206d75737420686176652060448201527f6e6f6e2d7a65726f204e454f4e204761696e00000000000000000000000000006064820152608401610a76565b6003546001600160a01b03163314610a7f5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610a76565b600380546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6000811161183f5760405162461bcd60e51b815260206004820152602660248201527f53746162696c697479506f6f6c3a20416d6f756e74206d757374206265206e6f6044820152656e2d7a65726f60d01b6064820152608401610a76565b600654604051632ee65eeb60e21b81526001600160a01b038481166004830152306024830152604482018490529091169063bb997bac90606401600060405180830381600087803b1580156128b057600080fd5b505af11580156128c4573d6000803e3d6000fd5b5050600a54600092506128d8915083610a81565b600a8190556040518181529091507fc5ee6fb858a22859c568a103df828f481b378a432ae4e0a5cbc076430130bdb29060200160405180910390a1505050565b6020810151606082015160808301516013546000939291908110156129435760009350505050610a90565b60008061295b84601254611b5d90919063ffffffff16565b9050806000036129855761297e8561137e6011548b612a9790919063ffffffff16565b91506129b3565b806001036129ae5761297e633b9aca0061137e8761137e6011548d612a9790919063ffffffff16565b600091505b6129c188633b9aca00612aa3565b8210156129d657600095505050505050610a90565b509695505050505050565b608081015160608201516040808401516020808601516000868152601583528481208682529092529281205490949392908590612a1e9084611b5d565b600086815260156020526040812091925090612a6390633b9aca009083612a46896001610a81565b815260200190815260200160002054612aa390919063ffffffff16565b90506000612a89670de0b6b3a764000061137e8681612a828888610a81565b8f90612a97565b9a9950505050505050505050565b6000610a8d8284612f4f565b6000610a8d8284612f2d565b6001600160a01b038116612b055760405162461bcd60e51b815260206004820152601e60248201527f4163636f756e742063616e6e6f74206265207a65726f206164647265737300006044820152606401610a76565b6001600160a01b0381163b61183f5760405162461bcd60e51b815260206004820181905260248201527f4163636f756e7420636f64652073697a652063616e6e6f74206265207a65726f6044820152606401610a76565b60808101516060820151825160208085015160008581526014835260408082208683529093529182205491949392918590612b979084611b5d565b600086815260146020526040812091925090612a6390633b9aca009083612a46896001610a81565b600a54801580612bcd575081155b15612bd6575050565b6000612be28383612cf4565b90506000612bfb60115483612a9790919063ffffffff16565b60135460009081526015602090815260408083206012548452909152902054909150612c279082610a81565b6013805460009081526015602081815260408084206012805486529083528185209690965593548084529181528383209454808452948152918390205483519081529182015280820192909252517ff183c509dedcdb1c9bd9cdcbf39fa395eedecb48f9666dcef9da50f7f2084e529181900360600190a150505050565b600a54600090612cb59083611b5d565b600a8190556040518181529091507fc5ee6fb858a22859c568a103df828f481b378a432ae4e0a5cbc076430130bdb29060200160405180910390a15050565b600080612d18601654612195670de0b6b3a764000087612a9790919063ffffffff16565b90506000612d268285612aa3565b9050612d3c612d358286612a97565b8390611b5d565b601655949350505050565b6001600160a01b038116811461183f57600080fd5b600060208284031215612d6e57600080fd5b8135612d7981612d47565b9392505050565b600060208284031215612d9257600080fd5b5035919050565b60008060408385031215612dac57600080fd5b50508035926020909101359150565b60008060408385031215612dce57600080fd5b8235612dd981612d47565b91506020830135612de981612d47565b809150509250929050565b600060208083528351808285015260005b81811015612e2157858101830151858201604001528201612e05565b506000604082860101526040601f19601f8301168501019250505092915050565b600080600080600080600080610100898b031215612e5f57600080fd5b8835612e6a81612d47565b97506020890135612e7a81612d47565b96506040890135612e8a81612d47565b95506060890135612e9a81612d47565b94506080890135612eaa81612d47565b935060a0890135612eba81612d47565b925060c0890135612eca81612d47565b915060e0890135612eda81612d47565b809150509295985092959890939650565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a9057610a90612eeb565b600060208284031215612f2657600080fd5b5051919050565b600082612f4a57634e487b7160e01b600052601260045260246000fd5b500490565b8082028115828204841417610a9057610a90612eeb565b600060208284031215612f7857600080fd5b8151612d7981612d47565b81810381811115610a9057610a90612eeb565b634e487b7160e01b600052600160045260246000fdfea164736f6c6343000811000a",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4126,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "activePool",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IActivePool)4320"
      },
      {
        "astId": 4129,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "defaultPool",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IDefaultPool)4673"
      },
      {
        "astId": 4132,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "priceFeed",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IPriceFeed)4759"
      },
      {
        "astId": 53,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "_owner",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 13024,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "borrowerOperations",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(IBorrowerOperations)4556"
      },
      {
        "astId": 13027,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "troveManager",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(ITroveManager)5581"
      },
      {
        "astId": 13030,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "zkusdToken",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(IZKUSDToken)5817"
      },
      {
        "astId": 13033,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "sortedTroves",
        "offset": 0,
        "slot": "7",
        "type": "t_contract(ISortedTroves)4907"
      },
      {
        "astId": 13036,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "communityIssuance",
        "offset": 0,
        "slot": "8",
        "type": "t_contract(ICommunityIssuance)4650"
      },
      {
        "astId": 13038,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "NEON",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 13040,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "totalZKUSDDeposits",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 13055,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "deposits",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 13060,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "depositSnapshots",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_address,t_struct(Snapshots)13051_storage)"
      },
      {
        "astId": 13062,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "treasury",
        "offset": 0,
        "slot": "13",
        "type": "t_address"
      },
      {
        "astId": 13072,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "DefaultKickbackRate",
        "offset": 0,
        "slot": "14",
        "type": "t_uint256"
      },
      {
        "astId": 13076,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "frontEndStakes",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 13081,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "frontEndSnapshots",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_address,t_struct(Snapshots)13051_storage)"
      },
      {
        "astId": 13084,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "P",
        "offset": 0,
        "slot": "17",
        "type": "t_uint256"
      },
      {
        "astId": 13089,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "currentScale",
        "offset": 0,
        "slot": "18",
        "type": "t_uint256"
      },
      {
        "astId": 13091,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "currentEpoch",
        "offset": 0,
        "slot": "19",
        "type": "t_uint256"
      },
      {
        "astId": 13097,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "epochToScaleToSum",
        "offset": 0,
        "slot": "20",
        "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 13103,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "epochToScaleToG",
        "offset": 0,
        "slot": "21",
        "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 13105,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "lastZKTError",
        "offset": 0,
        "slot": "22",
        "type": "t_uint256"
      },
      {
        "astId": 13107,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "lastNEONError_Offset",
        "offset": 0,
        "slot": "23",
        "type": "t_uint256"
      },
      {
        "astId": 13109,
        "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
        "label": "lastZKUSDLossError_Offset",
        "offset": 0,
        "slot": "24",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IActivePool)4320": {
        "encoding": "inplace",
        "label": "contract IActivePool",
        "numberOfBytes": "20"
      },
      "t_contract(IBorrowerOperations)4556": {
        "encoding": "inplace",
        "label": "contract IBorrowerOperations",
        "numberOfBytes": "20"
      },
      "t_contract(ICommunityIssuance)4650": {
        "encoding": "inplace",
        "label": "contract ICommunityIssuance",
        "numberOfBytes": "20"
      },
      "t_contract(IDefaultPool)4673": {
        "encoding": "inplace",
        "label": "contract IDefaultPool",
        "numberOfBytes": "20"
      },
      "t_contract(IPriceFeed)4759": {
        "encoding": "inplace",
        "label": "contract IPriceFeed",
        "numberOfBytes": "20"
      },
      "t_contract(ISortedTroves)4907": {
        "encoding": "inplace",
        "label": "contract ISortedTroves",
        "numberOfBytes": "20"
      },
      "t_contract(ITroveManager)5581": {
        "encoding": "inplace",
        "label": "contract ITroveManager",
        "numberOfBytes": "20"
      },
      "t_contract(IZKUSDToken)5817": {
        "encoding": "inplace",
        "label": "contract IZKUSDToken",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(Snapshots)13051_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct StabilityPool.Snapshots)",
        "numberOfBytes": "32",
        "value": "t_struct(Snapshots)13051_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Snapshots)13051_storage": {
        "encoding": "inplace",
        "label": "struct StabilityPool.Snapshots",
        "members": [
          {
            "astId": 13042,
            "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
            "label": "S",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 13044,
            "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
            "label": "P",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 13046,
            "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
            "label": "G",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 13048,
            "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
            "label": "scale",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 13050,
            "contract": "contracts/protocol/StabilityPool.sol:StabilityPool",
            "label": "epoch",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}