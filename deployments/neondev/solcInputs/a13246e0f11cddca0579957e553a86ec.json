{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n     */\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n        require(\n            Address.isContract(_account),\n            \"Account code size cannot be zero\"\n        );\n    }\n}\n"
    },
    "contracts/dependencies/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary FullMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 NEON,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint256 internal constant NICR_PRECISION = 1e20;\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x.mul(y);\n\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) FullManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(\n        uint256 _base,\n        uint256 _minutes\n    ) internal pure returns (uint256) {\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n.div(2);\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n.sub(1)).div(2);\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(\n        uint256 _a,\n        uint256 _b\n    ) internal pure returns (uint256) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeNominalCR(\n        uint256 _coll,\n        uint256 _debt\n    ) internal pure returns (uint256) {\n        if (_debt > 0) {\n            return _coll.mul(NICR_PRECISION).div(_debt);\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n\n    function _computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/ZKTProtocolBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"./FullMath.sol\";\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\nabstract contract ZKTProtocolBase {\n    using SafeMath for uint256;\n\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    uint256 public constant _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint256 public constant MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1500000000000000000; // 150%\n\n    // Amount of ZKUSD to be locked in gas pool on opening troves\n    uint256 public constant ZKUSD_GAS_COMPENSATION = 50e18;\n\n    // Minimum amount of net ZKUSD debt a trove must have\n    uint256 public constant MIN_NET_DEBT = 450e18;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint256 public constant BORROWING_FEE_FLOOR =\n        (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n\n    IActivePool public activePool;\n\n    IDefaultPool public defaultPool;\n\n    IPriceFeed public priceFeed;\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint256 _debt) internal pure returns (uint256) {\n        return _debt.add(ZKUSD_GAS_COMPENSATION);\n    }\n\n    function _getNetDebt(uint256 _debt) internal pure returns (uint256) {\n        return _debt.sub(ZKUSD_GAS_COMPENSATION);\n    }\n\n    // Return the amount of NEON to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(\n        uint256 _entireColl\n    ) internal pure returns (uint256) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function getEntireSystemColl()\n        public\n        view\n        returns (uint256 entireSystemColl)\n    {\n        uint256 activeColl = activePool.getNEON();\n        uint256 liquidatedColl = defaultPool.getNEON();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt()\n        public\n        view\n        returns (uint256 entireSystemDebt)\n    {\n        uint256 activeDebt = activePool.getZKUSDDebt();\n        uint256 closedDebt = defaultPool.getZKUSDDebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl();\n        uint256 entireSystemDebt = getEntireSystemDebt();\n\n        TCR = FullMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\n        uint256 TCR = _getTCR(_price);\n\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    ) internal pure {\n        uint256 feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\n        require(\n            feePercentage <= _maxFeePercentage,\n            \"Fee exceeded provided maximum\"\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IPool.sol\";\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\n    event ActivePoolNEONBalanceUpdated(uint256 _NEON);\n\n    // --- Functions ---\n    function sendNEON(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ITroveManager.sol\";\nimport \"./IZKUSDToken.sol\";\nimport \"./IActivePool.sol\";\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 ZKUSDFee;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 ZKUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IZKUSDToken zkusdToken;\n    }\n\n    enum Operation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event ZKUSDTokenAddressChanged(address _zkusdTokenAddress);\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        Operation operation\n    );\n    event ZKUSDBorrowingFeePaid(address indexed _borrower, uint256 _ZKUSDFee);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _zkusdTokenAddress,\n        address _zktStakingAddress\n    ) external;\n\n    function openTrove(\n        uint256 _maxFee,\n        uint256 _ZKUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function addColl(address _upperHint, address _lowerHint) external payable;\n\n    function moveNEONGainToTrove(\n        address _user,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function withdrawColl(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function withdrawZKUSD(\n        uint256 _maxFee,\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function repayZKUSD(\n        uint256 _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(\n        uint256 _maxFee,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint256 _debt) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICollSurplusPool {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);\n    event EtherSent(address _to, uint256 _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getNEON() external view returns (uint256);\n\n    function getCollateral(address _account) external view returns (uint256);\n\n    function accountSurplus(address _account, uint256 _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IPool.sol\";\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolZKUSDDebtUpdated(uint256 _ZKUSDDebt);\n    event DefaultPoolNEONBalanceUpdated(uint256 _NEON);\n\n    // --- Functions ---\n    function sendNEONToActivePool(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n\n    event NEONBalanceUpdated(uint256 _newBalance);\n    event ZKUSDBalanceUpdated(uint256 _newBalance);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event EtherSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    function getNEON() external view returns (uint256);\n\n    function getZKUSDDebt() external view returns (uint256);\n\n    function increaseZKUSDDebt(uint256 _amount) external;\n\n    function decreaseZKUSDDebt(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    // --- Events ---\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\n\n    // --- Function ---\n    function fetchPrice() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event UpdateLink(address _head, address _tail, uint256 _currentSize);\n    event NodeAdded(\n        address _id,\n        address _prevId,\n        address _nextId,\n        uint256 _NICR\n    );\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n\n    function setParams(\n        uint256 _size,\n        address _TroveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external;\n\n    function insert(\n        address _id,\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function remove(address _id) external;\n\n    function reInsert(\n        address _id,\n        uint256 _newICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (bool);\n\n    function findInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n * The Stability Pool holds ZKUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its ZKUSD debt gets offset with\n * ZKUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of ZKUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a ZKUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an NEON gain, as the NEON collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total ZKUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * --- ZKT ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An ZKT issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued ZKT in proportion to the deposit as a share of total deposits. The ZKT earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n */\ninterface IStabilityPool {\n    // --- Events ---\n\n    event StabilityPoolNEONBalanceUpdated(uint256 _newBalance);\n    event StabilityPoolZKUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(uint256 _S, uint256 _epoch, uint256 _scale);\n    event G_Updated(uint256 _G, uint256 _epoch, uint256 _scale);\n    event EpochUpdated(uint256 _currentEpoch);\n    event ScaleUpdated(uint256 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(\n        address indexed _depositor,\n        uint256 _P,\n        uint256 _S,\n        uint256 _G\n    );\n    event FrontEndSnapshotUpdated(\n        address indexed _frontEnd,\n        uint256 _P,\n        uint256 _G\n    );\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event NEONGainWithdrawn(\n        address indexed _depositor,\n        uint256 _NEON,\n        uint256 _ZKUSDLoss\n    );\n    event ZKTPaidToDepositor(address indexed _depositor, uint256 _ZKT);\n    event ZKTPaidToFrontEnd(address indexed _frontEnd, uint256 _ZKT);\n    event EtherSent(address _to, uint256 _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other Liquity contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress,\n        address _vault\n    ) external;\n\n    /*\n     * Initial checks:\n     * - _amount is not zero\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's accumulated gains (ZKT, NEON) to depositor\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some NEON gain\n     * ---\n     * - Triggers a ZKT issuance, based on time passed since the last issuance. The ZKT issuance is shared between *all* depositors\n     * - Sends all depositor's ZKT gain to  depositor\n     * - Transfers the depositor's entire NEON gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged\n     */\n    function withdrawNEONGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the ZKUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's NEON collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint256 _debt, uint256 _coll) external;\n\n    /*\n     * Returns the total amount of NEON held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like NEON received from a self-destruct.\n     */\n    function getNEON() external view returns (uint256);\n\n    /*\n     * Returns ZKUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalZKUSDDeposits() external view returns (uint256);\n\n    /*\n     * Calculates the NEON gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorNEONGain(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Calculate the ZKT gain earned by a deposit since its last snapshots were taken.\n     * The depositor gets a 99.9% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the defaultKickbackRate\n     * which they made their deposit.\n     */\n    function getDepositorZKTGain(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Return the ZKT gain earned by the front end(depositor).\n     */\n    function getFrontEndZKTGain(\n        address _frontEnd\n    ) external view returns (uint256);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedZKUSDDeposit(\n        address _depositor\n    ) external view returns (uint256);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(\n        address _frontEnd\n    ) external view returns (uint256);\n\n    /*\n     * Fallback function\n     * Only callable by Active Pool, it just accounts for NEON received\n     * receive() external payable;\n     */\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IStabilityPool.sol\";\nimport \"./IZKUSDToken.sol\";\nimport \"./IZKToken.sol\";\nimport \"./IZKTStaking.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event ZKUSDTokenAddressChanged(address _newZKUSDTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event ZKTokenAddressChanged(address _zkTokenAddress);\n    event ZKTStakingAddressChanged(address _zktStakingAddress);\n\n    event Liquidation(\n        uint256 _liquidatedDebt,\n        uint256 _liquidatedColl,\n        uint256 _collGasCompensation,\n        uint256 _ZKUSDGasCompensation\n    );\n    event Redemption(\n        uint256 _attemptedZKUSDAmount,\n        uint256 _actualZKUSDAmount,\n        uint256 _NEONSent,\n        uint256 _NEONFee\n    );\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        Operation operation\n    );\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        Operation operation\n    );\n    event BaseRateUpdated(uint256 _baseRate);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n    event TotalStakesUpdated(uint256 _newTotalStakes);\n    event SystemSnapshotsUpdated(\n        uint256 _totalStakesSnapshot,\n        uint256 _totalCollateralSnapshot\n    );\n    event LTermsUpdated(uint256 _L_Native, uint256 _L_Debt);\n    event TroveSnapshotsUpdated(\n        address _borrower,\n        uint256 _L_Native,\n        uint256 _L_Debt\n    );\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\n\n    enum Operation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _zkTokenAddress,\n        address _zktStakingAddress\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n\n    function zkusdToken() external view returns (IZKUSDToken);\n\n    function zkToken() external view returns (IZKToken);\n\n    function zktStaking() external view returns (IZKTStaking);\n\n    function getTroveOwnersCount() external view returns (uint256);\n\n    function getTroveFromTroveOwnersArray(\n        uint256 _index\n    ) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint256);\n\n    function getCurrentICR(\n        address _borrower,\n        uint256 _price\n    ) external view returns (uint256);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint256 _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint256 _ZKUSDAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFee\n    ) external;\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external returns (uint256);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external returns (uint256 index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingNEONReward(\n        address _borrower\n    ) external view returns (uint256);\n\n    function getPendingZKUSDDebtReward(\n        address _borrower\n    ) external view returns (uint256);\n\n    function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 pendingZKUSDDebtReward,\n            uint256 pendingNEONReward\n        );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint256);\n\n    function getRedemptionRateWithDecay() external view returns (uint256);\n\n    function getRedemptionFeeWithDecay(\n        uint256 _NEONDrawn\n    ) external view returns (uint256);\n\n    function getBorrowingRate() external view returns (uint256);\n\n    function getBorrowingRateWithDecay() external view returns (uint256);\n\n    function getBorrowingFee(uint256 ZKUSDDebt) external view returns (uint256);\n\n    function getBorrowingFeeWithDecay(\n        uint256 _ZKUSDDebt\n    ) external view returns (uint256);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint256);\n\n    function getTroveStake(address _borrower) external view returns (uint256);\n\n    function getTroveDebt(address _borrower) external view returns (uint256);\n\n    function getTroveColl(address _borrower) external view returns (uint256);\n\n    function setTroveStatus(address _borrower, uint256 num) external;\n\n    function increaseTroveColl(\n        address _borrower,\n        uint256 _collIncrease\n    ) external returns (uint256);\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint256 _collDecrease\n    ) external returns (uint256);\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint256 _debtIncrease\n    ) external returns (uint256);\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint256 _collDecrease\n    ) external returns (uint256);\n\n    function getTCR(uint256 _price) external view returns (uint256);\n\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IZKToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IZKToken is IERC20 {\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\n    event ZKTStakingAddressSet(address _zktStakingAddress);\n    event LockupContractFactoryAddressSet(\n        address _lockupContractFactoryAddress\n    );\n\n    // --- Functions ---\n\n    function sendToZKTStaking(address _sender, uint256 _amount) external;\n\n    function getDeploymentStartTime() external view returns (uint256);\n\n    function getLpRewardsEntitlement() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZKTStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IZKTStaking {\n    // --- Events --\n\n    event ZKTokenAddressSet(address _zkTokenAddress);\n    event ZKUSDTokenAddressSet(address _zkusdTokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n\n    event StakeChanged(address indexed staker, uint256 newStake);\n    event StakingGainsWithdrawn(\n        address indexed staker,\n        uint256 ZKUSDGain,\n        uint256 NEONGain\n    );\n    event F_NEONUpdated(uint256 _F_NEON);\n    event F_ZKUSDUpdated(uint256 _F_ZKUSD);\n    event TotalZKTStakedUpdated(uint256 _totalZKTStaked);\n    event EtherSent(address _account, uint256 _amount);\n    event StakerSnapshotsUpdated(\n        address _staker,\n        uint256 _F_NEON,\n        uint256 _F_ZKUSD\n    );\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _zkTokenAddress,\n        address _zkusdTokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function stake(uint256 _ZKTamount) external;\n\n    function unstake(uint256 _ZKTamount) external;\n\n    function increaseF_NEON(uint256 _NEONFee) external;\n\n    function increaseF_ZKUSD(uint256 _ZKTFee) external;\n\n    function getPendingNEONGain(address _user) external view returns (uint256);\n\n    function getPendingZKUSDGain(address _user) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IZKUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IZKUSDToken is IERC20 {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n\n    event ZKUSDTokenBalanceUpdated(address _user, uint256 _amount);\n\n    // --- Functions ---\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(\n        address _sender,\n        address poolAddress,\n        uint256 _amount\n    ) external;\n\n    function returnFromPool(\n        address poolAddress,\n        address user,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/mocks/TroveManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../dependencies/FullMath.sol\";\nimport \"../protocol/TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions\nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n    function computeICR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    ) external pure returns (uint256) {\n        return FullMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(\n        uint256 _coll\n    ) external pure returns (uint256) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getZKUSDGasCompensation() external pure returns (uint256) {\n        return ZKUSD_GAS_COMPENSATION;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing()\n        external\n        returns (uint256)\n    {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= DECIMAL_PRECISION);\n\n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint256) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint256 _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(\n        uint256 _NEONDrawn\n    ) external view returns (uint256) {\n        return _getRedemptionFee(_NEONDrawn);\n    }\n\n    function getActualDebtFromComposite(\n        uint256 _debtVal\n    ) external pure returns (uint256) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint256 troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/protocol/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        uint256 snapshotNEON;\n        uint256 snapshotZKUSDDebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(\n        int256 _startIdx,\n        uint256 _count\n    ) external view returns (CombinedTroveData[] memory _troves) {\n        uint256 startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint256(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint256(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint256 sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint256 maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotNEON,\n                _troves[idx].snapshotZKUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(\n        uint256 _startIdx,\n        uint256 _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint256 idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint256 idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotNEON,\n                _troves[idx].snapshotZKUSDDebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/protocol/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../dependencies/CheckContract.sol\";\n\n/*\n * A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n * change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n * but maintains their order. A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n * to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n *\n *\n * Changes made in the Liquity implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the NEON:USD price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n */\ncontract SortedTroves is ISortedTroves, CheckContract, Ownable {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"SortedTroves\";\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId; // Id of next node (smaller NICR) in the list\n        address prevId; // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head; // Head of the list. Also the node in the list with the largest NICR\n        address tail; // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize; // Maximum size of the list\n        uint256 size; // Current size of the list\n        mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters ---\n\n    function setParams(\n        uint256 _size,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external override onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cannot be zero\");\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        //renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function _insert(\n        ITroveManager _troveManager,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(\n                _troveManager,\n                _NICR,\n                prevId,\n                nextId\n            );\n        }\n\n        data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size = data.size.add(1);\n        emit UpdateLink(data.head, data.tail, data.size);\n        emit NodeAdded(_id, _prevId, _nextId, _NICR);\n    }\n\n    function remove(address _id) external override {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data\n                    .nodes[_id]\n                    .nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data\n                    .nodes[_id]\n                    .prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size = data.size.sub(1);\n        emit UpdateLink(data.head, data.tail, data.size);\n        emit NodeRemoved(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external override {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view override returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view override returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view override returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view override returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view override returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view override returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view override returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view override returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view override returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return\n                data.head == _nextId &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return\n                data.tail == _prevId &&\n                _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return\n                data.nodes[_prevId].nextId == _nextId &&\n                _troveManager.getNominalICR(_prevId) >= _NICR &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (\n            data.head == _startId &&\n            _NICR >= _troveManager.getNominalICR(_startId)\n        ) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (\n            prevId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (\n            data.tail == _startId &&\n            _NICR <= _troveManager.getNominalICR(_startId)\n        ) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (\n            nextId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view override returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (\n                !contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)\n            ) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (\n                !contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)\n            ) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"SortedTroves: Caller is not the TroveManager\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM(\n        ITroveManager _troveManager\n    ) internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == address(_troveManager),\n            \"SortedTroves: Caller is neither BO nor TroveM\"\n        );\n    }\n}\n"
    },
    "contracts/protocol/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"../interfaces/IBorrowerOperations.sol\";\nimport \"../interfaces/ITroveManager.sol\";\nimport \"../interfaces/ISortedTroves.sol\";\nimport \"../interfaces/ICollSurplusPool.sol\";\nimport \"../interfaces/IStabilityPool.sol\";\nimport \"../interfaces/IZKUSDToken.sol\";\nimport \"../interfaces/IZKToken.sol\";\nimport \"../interfaces/IZKTStaking.sol\";\nimport \"../dependencies/CheckContract.sol\";\nimport \"../dependencies/FullMath.sol\";\nimport \"../dependencies/ZKTProtocolBase.sol\";\n\ncontract TroveManager is\n    ITroveManager,\n    ZKTProtocolBase,\n    CheckContract,\n    Ownable\n{\n    using SafeMath for uint256;\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public override stabilityPool;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IZKUSDToken public override zkusdToken;\n\n    IZKToken public override zkToken;\n\n    IZKTStaking public override zktStaking;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint256 public constant MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint256 public constant REDEMPTION_FEE_FLOOR =\n        (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n    uint256 public constant MAX_BORROWING_FEE = (DECIMAL_PRECISION / 100) * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n//    uint256 public constant BOOTSTRAP_PERIOD = 14 days;\n    uint256 public constant BOOTSTRAP_PERIOD = 10 minutes;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the white paper.\n     */\n    uint256 public constant BETA = 2;\n\n    uint256 public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new ZKUSD issuance)\n    uint256 public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint256 arrayIndex;\n    }\n\n    mapping(address => Trove) public Troves;\n\n    uint256 public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint256 public totalCollateralSnapshot;\n\n    /*\n     * L_NEON and L_ZKUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n     *\n     * A NEON gain of ( stake * [L_NEON - L_NEON(0)] )\n     * A ZKUSDDebt increase  of ( stake * [L_ZKUSDDebt - L_ZKUSDDebt(0)] )\n     *\n     * Where L_NEON(0) and L_ZKUSDDebt(0) are snapshots of L_NEON and L_ZKUSDDebt for the active Trove taken at the instant the stake was made\n     */\n    uint256 public L_NEON;\n    uint256 public L_ZKUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping(address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the NEON and ZKUSD snapshots for a given active trove\n    struct RewardSnapshot {\n        uint256 NEON;\n        uint256 ZKUSDDebt;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint256 public lastNEONError_Redistribution;\n    uint256 public lastZKUSDDebtError_Redistribution;\n\n    /*\n     * --- Variable container structs for liquidations ---\n     *\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\n     **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 price;\n        uint256 ZKUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n        uint256 liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint256 collToLiquidate;\n        uint256 pendingDebtReward;\n        uint256 pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingZKUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        uint256 entireTroveColl;\n        uint256 collGasCompensation;\n        uint256 ZKUSDGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalCollInSequence;\n        uint256 totalDebtInSequence;\n        uint256 totalCollGasCompensation;\n        uint256 totalZKUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        uint256 totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        uint256 totalCollToRedistribute;\n        uint256 totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        IZKUSDToken zkusdToken;\n        IZKTStaking zktStaking;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n        address gasPoolAddress;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint256 remainingZKUSD;\n        uint256 totalZKUSDToRedeem;\n        uint256 totalNEONDrawn;\n        uint256 NEONFee;\n        uint256 NEONToSendToRedeemer;\n        uint256 decayedBaseRate;\n        uint256 price;\n        uint256 totalZKUSDSupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint256 ZKUSDLot;\n        uint256 NEONLot;\n        bool cancelledPartial;\n    }\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _zkusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _zkTokenAddress,\n        address _zktStakingAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_zkusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_zkTokenAddress);\n        checkContract(_zktStakingAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        zkusdToken = IZKUSDToken(_zkusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        zkToken = IZKToken(_zkTokenAddress);\n        zktStaking = IZKTStaking(_zktStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit ZKUSDTokenAddressChanged(_zkusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit ZKTokenAddressChanged(_zkTokenAddress);\n        emit ZKTStakingAddressChanged(_zktStakingAddress);\n\n        //renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint256) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(\n        uint256 _index\n    ) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ZKUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        );\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n        uint256 collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute\n        ) = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            collToLiquidate,\n            _ZKUSDInStabPool\n        );\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            Operation.liquidateInNormalMode\n        );\n        emit TroveUpdated(_borrower, 0, 0, 0, Operation.liquidateInNormalMode);\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _ZKUSDInStabPool,\n        uint256 _TCR,\n        uint256 _price\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {\n            return singleLiquidation;\n        } // don't liquidate if last trove\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation\n                .entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n\n            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            (\n                singleLiquidation.debtToOffset,\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.debtToRedistribute,\n                singleLiquidation.collToRedistribute\n            ) = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _ZKUSDInStabPool\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n            /*\n             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is ZKUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             */\n        } else if (\n            (_ICR >= MCR) &&\n            (_ICR < _TCR) &&\n            (singleLiquidation.entireTroveDebt <= _ZKUSDInStabPool)\n        ) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            assert(_ZKUSDInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                _price\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(\n                    _borrower,\n                    singleLiquidation.collSurplus\n                );\n            }\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.collToSendToSP,\n                Operation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                Operation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _ZKUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves.\n     */\n    function _getOffsetAndRedistributionVals(\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _ZKUSDInStabPool\n    )\n        internal\n        pure\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute\n        )\n    {\n        if (_ZKUSDInStabPool > 0) {\n            /*\n             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             *\n             *  If the trove's debt is larger than the deposited ZKUSD in the Stability Pool:\n             *\n             *  - Offset an amount of the trove's debt equal to the ZKUSD in the Stability Pool\n             *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n             *\n             */\n            debtToOffset = Math.min(_debt, _ZKUSDInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n     *  Get its offset coll/debt and NEON gas comp, and close the trove.\n     */\n    function _getCappedOffsetVals(\n        uint256 _entireTroveDebt,\n        uint256 _entireTroveColl,\n        uint256 _price\n    ) internal pure returns (LiquidationValues memory singleLiquidation) {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint256 cappedCollPortion = _entireTroveDebt.mul(MCR).div(_price);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            cappedCollPortion\n        );\n        singleLiquidation.ZKUSDGasCompensation = ZKUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(\n            singleLiquidation.collGasCompensation\n        );\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n     * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards\n     */\n    function liquidateTroves(uint256 _n) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            IZKUSDToken(address(0)),\n            IZKTStaking(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0)),\n            address(0)\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.ZKUSDInStabPool = stabilityPoolCached.getTotalZKUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n                contractsCache,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _n\n            );\n        } else {\n            // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _n\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated NEON and ZKUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            contractsCache.activePool,\n            contractsCache.defaultPool,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendNEON(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            contractsCache.activePool,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalZKUSDGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            contractsCache.activePool,\n            msg.sender,\n            totals.totalZKUSDGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n        ContractsCache memory _contractsCache,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        uint256 _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingZKUSDInStabPool == 0) {\n                    break;\n                }\n\n                uint256 TCR = FullMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingZKUSDInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        uint256 _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(\n        address[] memory _troveArray\n    ) public override {\n        require(\n            _troveArray.length != 0,\n            \"TroveManager: Calldata address array must not be empty\"\n        );\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.ZKUSDInStabPool = stabilityPoolCached.getTotalZKUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.ZKUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated NEON and ZKUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendNEON(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalZKUSDGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            msg.sender,\n            totals.totalZKUSDGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) {\n                continue;\n            }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR >= MCR && vars.remainingZKUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = FullMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingZKUSDInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _price,\n        uint256 _ZKUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingZKUSDInStabPool = _ZKUSDInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingZKUSDInStabPool\n                );\n                vars.remainingZKUSDInStabPool = vars\n                    .remainingZKUSDInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals\n            .totalCollGasCompensation\n            .add(singleLiquidation.collGasCompensation);\n        newTotals.totalZKUSDGasCompensation = oldTotals\n            .totalZKUSDGasCompensation\n            .add(singleLiquidation.ZKUSDGasCompensation);\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(\n            singleLiquidation.entireTroveColl\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals\n            .totalDebtToRedistribute\n            .add(singleLiquidation.debtToRedistribute);\n        newTotals.totalCollToRedistribute = oldTotals\n            .totalCollToRedistribute\n            .add(singleLiquidation.collToRedistribute);\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(\n            singleLiquidation.collSurplus\n        );\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        if (_ZKUSD > 0) {\n            zkusdToken.returnFromPool(gasPoolAddress, _liquidator, _ZKUSD);\n        }\n\n        if (_NEON > 0) {\n            _activePool.sendNEON(_liquidator, _NEON);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        _defaultPool.decreaseZKUSDDebt(_ZKUSD);\n        _activePool.increaseZKUSDDebt(_ZKUSD);\n        _defaultPool.sendNEONToActivePool(_NEON);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for ZKUSD up to _maxZKUSDamount\n    function _redeemCollateralFromTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint256 _maxZKUSDamount,\n        uint256 _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.ZKUSDLot = Math.min(\n            _maxZKUSDamount,\n            Troves[_borrower].debt.sub(ZKUSD_GAS_COMPENSATION)\n        );\n\n        // Get the NEONLot of equivalent value in USD\n        singleRedemption.NEONLot = singleRedemption\n            .ZKUSDLot\n            .mul(DECIMAL_PRECISION)\n            .div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the ZKUSD lot and corresponding NEON to send\n        uint256 newDebt = (Troves[_borrower].debt).sub(\n            singleRedemption.ZKUSDLot\n        );\n        uint256 newColl = (Troves[_borrower].coll).sub(singleRedemption.NEONLot);\n\n        if (newDebt == ZKUSD_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(\n                _contractsCache,\n                _borrower,\n                ZKUSD_GAS_COMPENSATION,\n                newColl\n            );\n            emit TroveUpdated(_borrower, 0, 0, 0, Operation.redeemCollateral);\n        } else {\n            uint256 newNICR = FullMath._computeNominalCR(newColl, newDebt);\n\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n             */\n            if (\n                newNICR != _partialRedemptionHintNICR ||\n                _getNetDebt(newDebt) < MIN_NET_DEBT\n            ) {\n                console.log(\"newNICR: \", newNICR);\n                console.log(\"_partialRedemptionHintNICR: \", _partialRedemptionHintNICR);\n                console.log(\"_getNetDebt(newDebt): \", _getNetDebt(newDebt));\n                console.log(\"MIN_NET_DEBT): \", MIN_NET_DEBT);\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            _contractsCache.sortedTroves.reInsert(\n                _borrower,\n                newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                newDebt,\n                newColl,\n                Troves[_borrower].stake,\n                Operation.redeemCollateral\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n     * Called when a full redemption occurs, and closes the trove.\n     * The redeemer swaps (debt - liquidation reserve) ZKUSD for (debt - liquidation reserve) worth of NEON, so the ZKUSD liquidation reserve left corresponds to the remaining debt.\n     * In order to close the trove, the ZKUSD liquidation reserve is burned, and the corresponding debt is removed from the active pool.\n     * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n     * Any surplus NEON left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n     */\n    function _redeemCloseTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint256 _ZKUSD,\n        uint256 _NEON\n    ) internal {\n        _contractsCache.zkusdToken.burn(gasPoolAddress, _ZKUSD);\n        // Update Active Pool ZKUSD, and send NEON to account\n        _contractsCache.activePool.decreaseZKUSDDebt(_ZKUSD);\n\n        // send NEON from Active Pool to CollSurplus Pool\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _NEON);\n        _contractsCache.activePool.sendNEON(\n            address(_contractsCache.collSurplusPool),\n            _NEON\n        );\n    }\n\n    function _isValidFirstRedemptionHint(\n        ISortedTroves _sortedTroves,\n        address _firstRedemptionHint,\n        uint256 _price\n    ) internal view returns (bool) {\n        if (\n            _firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n        return\n            nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _ZKUSDamount ZKUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n     * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n     *\n     * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n     * splitting the total _amount in appropriate chunks and calling the function multiple times.\n     *\n     * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n     * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n     * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n     * costs can vary.\n     *\n     * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n     * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n     * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n     * in the sortedTroves list along with the ICR value that the hint was found for.\n     *\n     * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n     * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n     * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining ZKUSD amount, which they can attempt\n     * to redeem later.\n     */\n    function redeemCollateral(\n        uint256 _ZKUSDamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external override {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            zkusdToken,\n            zktStaking,\n            sortedTroves,\n            collSurplusPool,\n            gasPoolAddress\n        );\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice();\n        _requireTCRoverMCR(totals.price);\n        _requireAmountGreaterThanZero(_ZKUSDamount);\n        _requireZKUSDBalanceCoversRedemption(\n            contractsCache.zkusdToken,\n            msg.sender,\n            _ZKUSDamount\n        );\n\n        totals.totalZKUSDSupplyAtStart = getEntireSystemDebt();\n        // Confirm redeemer's balance is less than total ZKUSD supply\n        assert(\n            contractsCache.zkusdToken.balanceOf(msg.sender) <=\n                totals.totalZKUSDSupplyAtStart\n        );\n\n        totals.remainingZKUSD = _ZKUSDamount;\n        address currentBorrower;\n\n        if (\n            _isValidFirstRedemptionHint(\n                contractsCache.sortedTroves,\n                _firstRedemptionHint,\n                totals.price\n            )\n        ) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = contractsCache.sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (\n                currentBorrower != address(0) &&\n                getCurrentICR(currentBorrower, totals.price) < MCR\n            ) {\n                currentBorrower = contractsCache.sortedTroves.getPrev(\n                    currentBorrower\n                );\n            }\n        }\n        console.log(\"remainingZKUSD\", totals.remainingZKUSD);\n        console.log(\"currentBorrower: \", currentBorrower);\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of ZKUSD is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n        while (\n            currentBorrower != address(0) &&\n            totals.remainingZKUSD > 0 &&\n            _maxIterations > 0\n        ) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(\n                currentBorrower\n            );\n\n            _applyPendingRewards(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                currentBorrower\n            );\n\n            SingleRedemptionValues\n                memory singleRedemption = _redeemCollateralFromTrove(\n                    contractsCache,\n                    currentBorrower,\n                    totals.remainingZKUSD,\n                    totals.price,\n                    _upperPartialRedemptionHint,\n                    _lowerPartialRedemptionHint,\n                    _partialRedemptionHintNICR\n                );\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n\n            totals.totalZKUSDToRedeem = totals.totalZKUSDToRedeem.add(\n                singleRedemption.ZKUSDLot\n            );\n            totals.totalNEONDrawn = totals.totalNEONDrawn.add(\n                singleRedemption.NEONLot\n            );\n\n            totals.remainingZKUSD = totals.remainingZKUSD.sub(\n                singleRedemption.ZKUSDLot\n            );\n            currentBorrower = nextUserToCheck;\n            console.log(\"totalNEONDrawn: \", totals.totalNEONDrawn);\n            console.log(\"NEONLot: \", singleRedemption.NEONLot);\n        }\n        require(\n            totals.totalNEONDrawn > 0,\n            \"TroveManager: Unable to redeem any amount\"\n        );\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total ZKUSD supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(\n            totals.totalNEONDrawn,\n            totals.price,\n            totals.totalZKUSDSupplyAtStart\n        );\n\n        // Calculate the NEON fee\n        totals.NEONFee = _getRedemptionFee(totals.totalNEONDrawn);\n\n        _requireUserAcceptsFee(\n            totals.NEONFee,\n            totals.totalNEONDrawn,\n            _maxFeePercentage\n        );\n\n        // Send the NEON fee to the ZK staking contract\n        contractsCache.activePool.sendNEON(\n            address(contractsCache.zktStaking),\n            totals.NEONFee\n        );\n        contractsCache.zktStaking.increaseF_NEON(totals.NEONFee);\n\n        totals.NEONToSendToRedeemer = totals.totalNEONDrawn.sub(totals.NEONFee);\n\n        emit Redemption(\n            _ZKUSDamount,\n            totals.totalZKUSDToRedeem,\n            totals.totalNEONDrawn,\n            totals.NEONFee\n        );\n\n        // Burn the total ZKUSD that is cancelled with debt, and send the redeemed NEON to msg.sender\n        contractsCache.zkusdToken.burn(msg.sender, totals.totalZKUSDToRedeem);\n        // Update Active Pool ZKUSD, and send NEON to account\n        contractsCache.activePool.decreaseZKUSDDebt(totals.totalZKUSDToRedeem);\n        contractsCache.activePool.sendNEON(\n            msg.sender,\n            totals.NEONToSendToRedeemer\n        );\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(\n        address _borrower\n    ) public view override returns (uint256) {\n        (\n            uint256 currentNEON,\n            uint256 currentZKUSDDebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint256 NICR = FullMath._computeNominalCR(currentNEON, currentZKUSDDebt);\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(\n        address _borrower,\n        uint256 _price\n    ) public view override returns (uint256) {\n        (\n            uint256 currentNEON,\n            uint256 currentZKUSDDebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint256 ICR = FullMath._computeCR(currentNEON, currentZKUSDDebt, _price);\n        return ICR;\n    }\n\n    function _getCurrentTroveAmounts(\n        address _borrower\n    ) internal view returns (uint256, uint256) {\n        uint256 pendingNEONReward = getPendingNEONReward(_borrower);\n        uint256 pendingZKUSDDebtReward = getPendingZKUSDDebtReward(_borrower);\n\n        uint256 currentNEON = Troves[_borrower].coll.add(pendingNEONReward);\n        uint256 currentZKUSDDebt = Troves[_borrower].debt.add(\n            pendingZKUSDDebtReward\n        );\n\n        return (currentNEON, currentZKUSDDebt);\n    }\n\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower\n    ) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending rewards\n            uint256 pendingNEONReward = getPendingNEONReward(_borrower);\n            uint256 pendingZKUSDDebtReward = getPendingZKUSDDebtReward(\n                _borrower\n            );\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(\n                pendingNEONReward\n            );\n            Troves[_borrower].debt = Troves[_borrower].debt.add(\n                pendingZKUSDDebtReward\n            );\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                pendingZKUSDDebtReward,\n                pendingNEONReward\n            );\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].coll,\n                Troves[_borrower].stake,\n                Operation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_NEON and L_ZKUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].NEON = L_NEON;\n        rewardSnapshots[_borrower].ZKUSDDebt = L_ZKUSDDebt;\n        emit TroveSnapshotsUpdated(_borrower, L_NEON, L_ZKUSDDebt);\n    }\n\n    // Get the borrower's pending accumulated NEON reward, earned by their stake\n    function getPendingNEONReward(\n        address _borrower\n    ) public view override returns (uint256) {\n        uint256 snapshotNEON = rewardSnapshots[_borrower].NEON;\n        uint256 rewardPerUnitStaked = L_NEON.sub(snapshotNEON);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint256 stake = Troves[_borrower].stake;\n\n        uint256 pendingNEONReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingNEONReward;\n    }\n\n    // Get the borrower's pending accumulated ZKUSD reward, earned by their stake\n    function getPendingZKUSDDebtReward(\n        address _borrower\n    ) public view override returns (uint256) {\n        uint256 snapshotZKUSDDebt = rewardSnapshots[_borrower].ZKUSDDebt;\n        uint256 rewardPerUnitStaked = L_ZKUSDDebt.sub(snapshotZKUSDDebt);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint256 stake = Troves[_borrower].stake;\n\n        uint256 pendingZKUSDDebtReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingZKUSDDebtReward;\n    }\n\n    function hasPendingRewards(\n        address _borrower\n    ) public view override returns (bool) {\n        /*\n         * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n         * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n         * pending rewards\n         */\n        if (Troves[_borrower].status != Status.active) {\n            return false;\n        }\n\n        return (rewardSnapshots[_borrower].NEON < L_NEON);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 pendingZKUSDDebtReward,\n            uint256 pendingNEONReward\n        )\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingZKUSDDebtReward = getPendingZKUSDDebtReward(_borrower);\n        pendingNEONReward = getPendingNEONReward(_borrower);\n\n        debt = debt.add(pendingZKUSDDebtReward);\n        coll = coll.add(pendingNEONReward);\n    }\n\n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint256 stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(\n        address _borrower\n    ) internal returns (uint256) {\n        uint256 newStake = _computeNewStake(Troves[_borrower].coll);\n        uint256 oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n        emit TotalStakesUpdated(totalStakes);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n             * The following assert() holds true because:\n             * - The system always contains >= 1 trove\n             * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n             * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _debt,\n        uint256 _coll\n    ) internal {\n        if (_debt == 0) {\n            return;\n        }\n\n        /*\n         * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n         * error correction, to keep the cumulative error low in the running totals L_NEON and L_ZKUSDDebt:\n         *\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store these errors for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint256 NEONNumerator = _coll.mul(DECIMAL_PRECISION).add(\n            lastNEONError_Redistribution\n        );\n        uint256 ZKUSDDebtNumerator = _debt.mul(DECIMAL_PRECISION).add(\n            lastZKUSDDebtError_Redistribution\n        );\n\n        // Get the per-unit-staked terms\n        uint256 NEONRewardPerUnitStaked = NEONNumerator.div(totalStakes);\n        uint256 ZKUSDDebtRewardPerUnitStaked = ZKUSDDebtNumerator.div(\n            totalStakes\n        );\n\n        lastNEONError_Redistribution = NEONNumerator.sub(\n            NEONRewardPerUnitStaked.mul(totalStakes)\n        );\n        lastZKUSDDebtError_Redistribution = ZKUSDDebtNumerator.sub(\n            ZKUSDDebtRewardPerUnitStaked.mul(totalStakes)\n        );\n\n        // Add per-unit-staked terms to the running totals\n        L_NEON = L_NEON.add(NEONRewardPerUnitStaked);\n        L_ZKUSDDebt = L_ZKUSDDebt.add(ZKUSDDebtRewardPerUnitStaked);\n\n        emit LTermsUpdated(L_NEON, L_ZKUSDDebt);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseZKUSDDebt(_debt);\n        _defaultPool.increaseZKUSDDebt(_debt);\n        _activePool.sendNEON(address(_defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        assert(\n            closedStatus != Status.nonExistent && closedStatus != Status.active\n        );\n\n        uint256 TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].NEON = 0;\n        rewardSnapshots[_borrower].ZKUSDDebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /*\n     * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n     * Used in a liquidation sequence.\n     *\n     * The calculation excludes a portion of collateral that is in the ActivePool:\n     *\n     * the total NEON gas compensation from the liquidation sequence\n     *\n     * The NEON as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n     */\n    function _updateSystemSnapshots_excludeCollRemainder(\n        IActivePool _activePool,\n        uint256 _collRemainder\n    ) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint256 activeColl = _activePool.getNEON();\n        uint256 liquidatedColl = defaultPool.getNEON();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(\n            liquidatedColl\n        );\n\n        emit SystemSnapshotsUpdated(\n            totalStakesSnapshot,\n            totalCollateralSnapshot\n        );\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external override returns (uint256 index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(\n        address _borrower\n    ) internal returns (uint256 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum ZKUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 ZKUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint256(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /*\n     * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n     * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n     */\n    function _removeTroveOwner(\n        address _borrower,\n        uint256 TroveOwnersArrayLength\n    ) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function `_closeTrove`\n        assert(\n            troveStatus != Status.nonExistent && troveStatus != Status.active\n        );\n\n        uint256 index = Troves[_borrower].arrayIndex;\n        uint256 length = TroveOwnersArrayLength;\n        uint256 idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR(uint256 _price) external view override returns (uint256) {\n        return _getTCR(_price);\n    }\n\n    function checkRecoveryMode(\n        uint256 _price\n    ) external view override returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an NEON:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint256 _entireSystemColl,\n        uint256 _entireSystemDebt,\n        uint256 _price\n    ) internal pure returns (bool) {\n        uint256 TCR = FullMath._computeCR(\n            _entireSystemColl,\n            _entireSystemDebt,\n            _price\n        );\n\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or ZKUSD borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint256 _NEONDrawn,\n        uint256 _price,\n        uint256 _totalZKUSDSupply\n    ) internal returns (uint256) {\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn NEON back to ZKUSD at face value rate (1 ZKUSD:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint256 redeemedZKUSDFraction = _NEONDrawn.mul(_price).div(\n            _totalZKUSDSupply\n        );\n\n        uint256 newBaseRate = decayedBaseRate.add(\n            redeemedZKUSDFraction.div(BETA)\n        );\n        newBaseRate = Math.min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view override returns (uint256) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(\n        uint256 _baseRate\n    ) internal pure returns (uint256) {\n        return\n            Math.min(\n                REDEMPTION_FEE_FLOOR.add(_baseRate),\n                DECIMAL_PRECISION // cap at a maximum of 100%\n            );\n    }\n\n    function _getRedemptionFee(\n        uint256 _NEONDrawn\n    ) internal view returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRate(), _NEONDrawn);\n    }\n\n    function getRedemptionFeeWithDecay(\n        uint256 _NEONDrawn\n    ) external view override returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _NEONDrawn);\n    }\n\n    function _calcRedemptionFee(\n        uint256 _redemptionRate,\n        uint256 _NEONDrawn\n    ) internal pure returns (uint256) {\n        uint256 redemptionFee = _redemptionRate.mul(_NEONDrawn).div(\n            DECIMAL_PRECISION\n        );\n        require(\n            redemptionFee < _NEONDrawn,\n            \"TroveManager: Fee would eat up all returned collateral\"\n        );\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint256) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(\n        uint256 _baseRate\n    ) internal pure returns (uint256) {\n        return Math.min(BORROWING_FEE_FLOOR.add(_baseRate), MAX_BORROWING_FEE);\n    }\n\n    function getBorrowingFee(\n        uint256 _ZKUSDDebt\n    ) external view override returns (uint256) {\n        return _calcBorrowingFee(getBorrowingRate(), _ZKUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(\n        uint256 _ZKUSDDebt\n    ) external view override returns (uint256) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _ZKUSDDebt);\n    }\n\n    function _calcBorrowingFee(\n        uint256 _borrowingRate,\n        uint256 _ZKUSDDebt\n    ) internal pure returns (uint256) {\n        return _borrowingRate.mul(_ZKUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or ZKUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint256 decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION); // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint256 timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint256 decayFactor = FullMath._decPow(\n            MINUTE_DECAY_FACTOR,\n            minutesPassed\n        );\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {\n        return\n            (block.timestamp.sub(lastFeeOperationTime)).div(\n                SECONDS_IN_ONE_MINUTE\n            );\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"TroveManager: Caller is not the BorrowerOperations contract\"\n        );\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(\n            Troves[_borrower].status == Status.active,\n            \"TroveManager: Trove does not exist or is closed\"\n        );\n    }\n\n    function _requireZKUSDBalanceCoversRedemption(\n        IZKUSDToken _zkusdToken,\n        address _redeemer,\n        uint256 _amount\n    ) internal view {\n        require(\n            _zkusdToken.balanceOf(_redeemer) >= _amount,\n            \"TroveManager: Requested redemption amount must be <= user's ZKUSD token balance\"\n        );\n    }\n\n    function _requireMoreThanOneTroveInSystem(\n        uint256 TroveOwnersArrayLength\n    ) internal view {\n        require(\n            TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1,\n            \"TroveManager: Only one trove in the system\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    function _requireTCRoverMCR(uint256 _price) internal view {\n        require(\n            _getTCR(_price) >= MCR,\n            \"TroveManager: Cannot redeem when TCR < MCR\"\n        );\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint256 systemDeploymentTime = zkToken.getDeploymentStartTime();\n        require(\n            block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD),\n            \"TroveManager: Redemptions are not allowed during bootstrap phase\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint256 _maxFeePercentage\n    ) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR &&\n                _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(\n        address _borrower\n    ) external view override returns (uint256) {\n        return uint256(Troves[_borrower].status);\n    }\n\n    function getTroveStake(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(\n        address _borrower\n    ) external view override returns (uint256) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint256 _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(\n        address _borrower,\n        uint256 _collIncrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint256 _collDecrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint256 _debtIncrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint256 _debtDecrease\n    ) external override returns (uint256) {\n        _requireCallerIsBorrowerOperations();\n        uint256 newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}